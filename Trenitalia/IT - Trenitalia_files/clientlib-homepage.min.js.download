!function($) {
    var SmartBanner = function(options) {
        this.origHtmlMargin = parseFloat($('html').css('margin-top')) // Get the original margin-top of the HTML element so we can take that into account
        this.options = $.extend({}, $.smartbanner.defaults, options)
        
        var standalone = navigator.standalone // Check if it's already a standalone web app or running within a webui view of an app (not mobile safari)

        // Detect banner type (iOS or Android)
        if (this.options.force) {
            this.type = this.options.force
        } else if (navigator.userAgent.match(/iPad|iPhone|iPod/i) != null) {
            if (navigator.userAgent.match(/Safari/i) != null &&
               (navigator.userAgent.match(/CriOS/i) != null ||
               window.Number(navigator.userAgent.substr(navigator.userAgent.indexOf('OS ') + 3, 3).replace('_', '.')) < 6)) this.type = 'ios' // Check webview and native smart banner support (iOS 6+)
        } else if (navigator.userAgent.match(/Android/i) != null) {
            this.type = 'android'
        }
        
        // Don't show banner if device isn't iOS or Android, website is loaded in app or user dismissed banner
        if (!this.type || standalone || this.getCookie('sb-closed') || this.getCookie('sb-installed')) {
            return
        }
        
        // Calculate scale
        this.scale = this.options.scale == 'auto' ? $(window).width() / window.screen.width : this.options.scale
        if (this.scale < 1) this.scale = 1

        // Get info from meta data
		//var meta = $(this.type=='android' ? 'meta[name="google-play-app"]' : 'meta[name="apple-itunes-app"]');
        //if (meta.length == 0) return
        
		if(this.type=='android'){
			this.appId = this.options.androidAppId;
		}else{
			this.appId = this.options.appleAppId;			
		}
        //this.appId = /app-id=([^\s,]+)/.exec(meta.attr('content'))[1]
        this.title = this.options.title; // ? this.options.title : meta.data('title') || $('title').text().replace(/\s*[|\-·].*$/, '')
        this.author = this.options.author; //? this.options.author : meta.data('author') || ($('meta[name="author"]').length ? $('meta[name="author"]').attr('content') : window.location.hostname)
        this.iconUrl = ''; //meta.data('icon-url');
        this.price = ''; //meta.data('price');
		
        // Create banner
        this.create()
        this.show()
        this.listen()
    }
        
    SmartBanner.prototype = {

        constructor: SmartBanner
    
      , create: function() {
            var iconURL
              , link=(this.options.url ? this.options.url : (this.type=='android' ? 'market://details?id=' : ('https://itunes.apple.com/' + this.options.appStoreLanguage + '/app/id')) + this.appId)
              , price = this.price || this.options.price
              , inStore = price ? price + ' - ' + (this.type=='android' ? this.options.inGooglePlay : this.options.inAppStore) : ''
              , gloss=this.options.iconGloss === null ? (this.type=='ios') : this.options.iconGloss

            $('body').append('<div id="smartbanner" class="'+ 'ios'/*this.type*/ +'"><div class="sb-container"><a href="#" class="sb-close">&times;</a><span class="sb-icon"></span><div class="sb-info"><strong>'+this.title+'</strong><span>'+this.author+'</span><span>'+inStore+'</span></div><a href="'+link+'" class="sb-button"><span>'+this.options.button+'</span></a></div></div>')
            
            if (this.options.icon) {
                iconURL = this.options.icon
            } else if(this.iconUrl) {
                iconURL = this.iconUrl;
            } else if ($('link[rel="apple-touch-icon-precomposed"]').length > 0) {
                iconURL = $('link[rel="apple-touch-icon-precomposed"]').attr('href')
                if (this.options.iconGloss === null) gloss = false
            } else if ($('link[rel="apple-touch-icon"]').length > 0) {
                iconURL = $('link[rel="apple-touch-icon"]').attr('href')
            }
            if (iconURL) {
                $('#smartbanner .sb-icon').css('background-image','url('+iconURL+')')
                if (gloss) $('#smartbanner .sb-icon').addClass('gloss')
            } else{
                $('#smartbanner').addClass('no-icon')
            }

            this.bannerHeight = $('#smartbanner').outerHeight() + 2

            if (this.scale > 1) {
                $('#smartbanner')
                    .css('top', parseFloat($('#smartbanner').css('top')) * this.scale)
                    .css('height', parseFloat($('#smartbanner').css('height')) * this.scale)
                $('#smartbanner .sb-container')
                    .css('-webkit-transform', 'scale('+this.scale+')')
                    .css('-msie-transform', 'scale('+this.scale+')')
                    .css('-moz-transform', 'scale('+this.scale+')')
                    .css('width', $(window).width() / this.scale)
            }
        }
        
      , listen: function () {
            $('#smartbanner .sb-close').on('click',$.proxy(this.close, this))
            $('#smartbanner .sb-button').on('click',$.proxy(this.install, this))
        }
        
      , show: function(callback) {
            $('#smartbanner').stop().animate({top:0},this.options.speedIn).addClass('shown')
            $('html').animate({marginTop:this.origHtmlMargin+(this.bannerHeight*this.scale)},this.options.speedIn,'swing',callback)
        }
        
      , hide: function(callback) {
            $('#smartbanner').stop().animate({top:-1*this.bannerHeight*this.scale},this.options.speedOut).removeClass('shown')
            $('html').animate({marginTop:this.origHtmlMargin},this.options.speedOut,'swing',callback)
        }
      
      , close: function(e) {
            e.preventDefault()
            this.hide()
            this.setCookie('sb-closed','true',this.options.daysHidden)
        }
       
      , install: function(e) {
            this.hide()
            this.setCookie('sb-installed','true',this.options.daysReminder)
        }
       
      , setCookie: function(name, value, exdays) {
            var exdate = new Date()
            exdate.setDate(exdate.getDate()+exdays)
            value=escape(value)+((exdays==null)?'':'; expires='+exdate.toUTCString())
            document.cookie=name+'='+value+'; path=/;'
        }
        
      , getCookie: function(name) {
            var i,x,y,ARRcookies = document.cookie.split(";")
            for(i=0;i<ARRcookies.length;i++) {
                x = ARRcookies[i].substr(0,ARRcookies[i].indexOf("="))
                y = ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1)
                x = x.replace(/^\s+|\s+$/g,"")
                if (x==name) {
                    return unescape(y)
                }
            }
            return null
        }
      
      // Demo only
      , switchType: function() {
          var that = this
          
          this.hide(function() {
            that.type = that.type=='android' ? 'ios' : 'android'
            var meta = $(that.type=='android' ? 'meta[name="google-play-app"]' : 'meta[name="apple-itunes-app"]').attr('content')
            that.appId = /app-id=([^\s,]+)/.exec(meta)[1]
            
            $('#smartbanner').detach()
            that.create()
            that.show()
          })
        }
    }

    $.smartbanner = function(option) {
        var $window = $(window)
        , data = $window.data('typeahead')
        , options = typeof option == 'object' && option
      if (!data) $window.data('typeahead', (data = new SmartBanner(options)))
      if (typeof option == 'string') data[option]()
    }
    
    // override these globally if you like (they are all optional)
    $.smartbanner.defaults = {
        title: null, // What the title of the app should be in the banner (defaults to <title>)
        author: null, // What the author of the app should be in the banner (defaults to <meta name="author"> or hostname)
        price: 'FREE', // Price of the app
        appStoreLanguage: 'us', // Language code for App Store
        inAppStore: 'On the App Store', // Text of price for iOS
        inGooglePlay: 'In Google Play', // Text of price for Android
        icon: null, // The URL of the icon (defaults to <meta name="apple-touch-icon">)
        iconGloss: null, // Force gloss effect for iOS even for precomposed
        button: 'VIEW', // Text for the install button
        url: null, // The URL for the button. Keep null if you want the button to link to the app store.
        scale: 'auto', // Scale based on viewport size (set to 1 to disable)
        speedIn: 300, // Show animation speed of the banner
        speedOut: 400, // Close animation speed of the banner
        daysHidden: 15, // Duration to hide the banner after being closed (0 = always show banner)
        daysReminder: 90, // Duration to hide the banner after "VIEW" is clicked *separate from when the close button is clicked* (0 = always show banner)
        force: null // Choose 'ios' or 'android'. Don't do a browser check, just always show this banner
    }
    
    $.smartbanner.Constructor = SmartBanner

}(window.jQuery);

    /* Fa refresh del browser solo se c'è la cache */
    (function () {
        window.onpageshow = function (event) {
          $("#biglietti_ar").prop("checked", false);
           if (event.persisted) {
                window.location.reload();
            }
        };
    })();
    var closeMsg, monthsList, selectedInput, containerDP;
    $(document).ready(function () {
        var isIE = !!window.MSInputMethodContext && !!document.documentMode;

        //monthsList = $('#datepickerMonths') ? $('#datepickerMonths').val() : '';
        monthsList = "gennaio,febbraio,marzo,aprile,maggio,giugno,luglio,agosto,settembre,ottobre,novembre,dicembre";
        //console.log("monthsList: "+monthsList);
        var $mobileP = $('#biglietti_data_p_mobile');
        var $mobileA = $('#biglietti_data_a_mobile');
        // console.log("- monthsList: "+monthsList);
        if (!isIE) {

            var tzoffset = (new Date()).getTimezoneOffset() * 60000;
            var localISOTime = (new Date(Date.now() - tzoffset)).toISOString().slice(0, -1);
            var today = localISOTime.split('T')[0];

            $mobileP.attr('min', today);
            $mobileA.attr('min', today);
            $mobileP.val(today);
            $mobileA.val(today);

            function compareDates(d1, d2) {
                var fromDate = Date.parse(d1);
                var toDate = Date.parse(d2);

                return fromDate < toDate;
            }

            $('#biglietti_data_p_mobile').change(function () {
                var thisVal = $(this).val();
                if (thisVal && thisVal.length === 10) {
                    var dateAr = thisVal.split('-');
                    var newDate = dateAr[2] + '-' + dateAr[1] + '-' + dateAr[0];
                    $('#biglietti_data_p').attr('value', newDate);
                    $('#biglietti_data_p').val(newDate);
                }
                $('#biglietti_data_a_mobile').attr('min', (thisVal ? thisVal : today));
                if (compareDates($('#biglietti_data_a_mobile').val(), thisVal)) {
                    $('#biglietti_data_a_mobile').val(thisVal);
                }
            });

            $('#biglietti_data_a_mobile').change(function () {
                var thisVal = $(this).val();
                if (thisVal && thisVal.length === 10) {
                    var dateAr = thisVal.split('-');
                    var newDate = dateAr[2] + '-' + dateAr[1] + '-' + dateAr[0];
                    $('#biglietti_data_a').attr('value', newDate);
                    $('#biglietti_data_a').val(newDate);
                }
            });

            $mobileP.trigger('change');
            $mobileA.trigger('change');
        } else {
            $mobileP.remove();
            $mobileA.remove();
            $('#biglietti_data_p').show();
            $('#biglietti_data_a').show();
        }

        $(document).on('click', '#ui-datepicker-div .ui-datepicker-close', function () {
            closeCalendar(true);
        });

    });

    function dayTripper(partArr) {
        setTimeout(function () {
            var today = $('.ui-datepicker-today a')[0];
            var currentDay =  $('.ui-datepicker-current-day a')[0];
            if (!today) {
                today = $('.ui-state-active')[0] ||
                $('.ui-state-default')[0];
            }

            //TORNO INDIETRO DAL CALENDARIO CON IL TAB
            $(today).on('keydown', function(e){
                ritornoKey=e.which;
                ritornoKeyShift=e.shiftKey
            });

            $(today).on('focusout', function(){
                if(ritornoKeyShift){
                    removeAria();
                    closeCalendar();
                    setTimeout(function () {
                        $('#biglietti_ar_circular').focus();
                    }, 100);
                }
            });


            // Hide the entire page (except the date picker)
            // from screen readers to prevent document navigation
            // (by headings, etc.) while the popup is open
            $('body > div:not("#ui-datepicker-div")').addClass('dp-container');
            $(".dp-container").attr('aria-hidden', 'true');
            $("#skipnav").attr('aria-hidden', 'true');

            // Hide the "today" button because it doesn't do what
            // you think it supposed to do
            if(today === currentDay){
                today.focus();
            }else{
                currentDay.focus();
                $('.ui-state-highlight').removeClass('ui-state-highlight');
            }
            datePickHandler(partArr);
        }, 0);
    }

    function datePickHandler(partArr) {
        var activeDate;
        containerDP = document.getElementById('ui-datepicker-div');

        if (!containerDP || !selectedInput.length) {
            return;
        }

        // $(container).find('table').first().attr('role', 'grid');

        containerDP.setAttribute('role', 'application');
        //containerDP.setAttribute('aria-label', 'Calendar view date-picker');
        containerDP.setAttribute('aria-label', 'data di ' + partArr + ' premi invio per scegliere, frecce orizzontali per spostarsi di giorno in giorno, frecce verticali per spostarsi di settimana');

        // the top controls:
        var prev = $('.ui-datepicker-prev', containerDP)[0],
            next = $('.ui-datepicker-next', containerDP)[0];

        // This is the line that needs to be fixed for use on pages with base URL set in head
        next.href = 'javascript:void(0)';
        prev.href = 'javascript:void(0)';

        next.setAttribute('role', 'button');
        next.removeAttribute('title');
        prev.setAttribute('role', 'button');
        prev.removeAttribute('title');

        appendOffscreenMonthText(next);
        appendOffscreenMonthText(prev);

        // delegation won't work here for whatever reason, so we are
        // forced to attach individual click listeners to the prev /
        // next month buttons each time they are added to the DOM
        $(next).on('click', handleNextClicks);
        $(prev).on('click', handlePrevClicks);

        monthDayYearText();

        $(containerDP).on('keydown', function calendarKeyboardListener(keyVent) {
            var which = keyVent.which;

            var target = keyVent.target;
            var dateCurrent = getCurrentDate(containerDP);

            if (!dateCurrent) {
                dateCurrent = $('a.ui-state-default')[0];
                setHighlightState(dateCurrent, containerDP);
            }

            if (27 === which) {
                keyVent.stopPropagation();
                return closeCalendar(true);
            } else if (which === 9 && keyVent.shiftKey) { // SHIFT + TAB
                keyVent.preventDefault();
                if ($(target).hasClass('ui-datepicker-close')) { // close button
                    $('.ui-datepicker-prev')[0].focus();
                } else if ($(target).hasClass('ui-state-default')) { // a date link
                    $('.ui-datepicker-close')[0].focus();
                } else if ($(target).hasClass('ui-datepicker-prev')) { // the prev link
                    $('.ui-datepicker-next')[0].focus();
                } else if ($(target).hasClass('ui-datepicker-next')) { // the next link
                    activeDate = $('.ui-state-highlight') ||
                        $('.ui-state-active')[0];
                    if (activeDate) {
                        activeDate.focus();
                    }
                }
            } else if (which === 9) { // TAB
                keyVent.preventDefault();
                if ($(target).hasClass('ui-datepicker-close')) { // close button
                    activeDate = $('.ui-state-highlight') ||
                        $('.ui-state-active')[0];
                    if (activeDate) {
                        activeDate.focus();
                    }
                } else if ($(target).hasClass('ui-state-default')) {
                    $('.ui-datepicker-next')[0].focus();
                } else if ($(target).hasClass('ui-datepicker-next')) {
                    $('.ui-datepicker-prev')[0].focus();
                } else if ($(target).hasClass('ui-datepicker-prev')) {
                    $('.ui-datepicker-close')[0].focus();
                }
            } else if (which === 37) { // LEFT arrow key
                // if we're on a date link...
                if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                    keyVent.preventDefault();
                    //Torno indietro dal primo giornodel mese successiavo all'ultimo di quello del mese precedente
                    let ultimo = target.attributes[3].value
                    if (ultimo === '1'){
                        var container = document.getElementById('ui-datepicker-div');
                        setTimeout(function () {
                            var trs = $('tr', container)
                            if (trs.length === 13 || trs.length === 14){
                                var lastRowTdLinks = $('td a.ui-state-default', trs[trs.length - 8])
                            }else{
                                var lastRowTdLinks = $('td a.ui-state-default', trs[trs.length - 7])
                            }

                            var lastDate = lastRowTdLinks[lastRowTdLinks.length - 1]
                            setTimeout(function () {
                                $('.ui-state-highlight').removeClass('ui-state-highlight');
                                lastDate.focus();
                                $(lastDate).addClass('ui-state-highlight');
                            }, 100);

                        }, 0);
                    }
                    previousDay(target);
                }
            } else if (which === 39) { // RIGHT arrow key
                // if we're on a date link...
                if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                    keyVent.preventDefault();
                    nextDay(target);
                }
            } else if (which === 38) { // UP arrow key
                if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                    keyVent.preventDefault();
                    upHandler(target, containerDP, prev);
                }
            } else if (which === 40) { // DOWN arrow key
                if (!$(target).hasClass('ui-datepicker-close') && $(target).hasClass('ui-state-default')) {
                    keyVent.preventDefault();
                    downHandler(target, containerDP, next);
                }
            } else if (which === 13) { // ENTER

                //alert("target: "+target);
                if ($(target).hasClass('ui-state-default')) {
                    setTimeout(function () {
                        //alert("ho premuto invio");
                        closeCalendar();
                        //biglietti_ora_p
                        focusSucc(partArr);

                    }, 100);
                } else if ($(target).hasClass('ui-datepicker-prev')) {
                    handlePrevClicks();
                } else if ($(target).hasClass('ui-datepicker-next')) {
                    handleNextClicks();
                }
            } else if (32 === which) {

                if ($(target).hasClass('ui-datepicker-prev') || $(target).hasClass('ui-datepicker-next')) {
                    target.click();
                }
            } else if (33 === which) { // PAGE UP
                moveOneMonth(target, 'prev');
            } else if (34 === which) { // PAGE DOWN
                moveOneMonth(target, 'next');
            } else if (36 === which) { // HOME
                var firstOfMonth = $(target).closest('tbody').find('.ui-state-default')[0];
                if (firstOfMonth) {
                    firstOfMonth.focus();
                    setHighlightState(firstOfMonth, $('#ui-datepicker-div')[0]);
                }
            } else if (35 === which) { // END
                var $daysOfMonth = $(target).closest('tbody').find('.ui-state-default');
                var lastDay = $daysOfMonth[$daysOfMonth.length - 1];
                if (lastDay) {
                    lastDay.focus();
                    setHighlightState(lastDay, $('#ui-datepicker-div')[0]);
                }
            }
        });
    }

    function closeCalendar(focus) {

        if (selectedInput.length) {
            var input = selectedInput.first();
            input.datepicker('hide');
            if (focus) {
                input.off('focus');
                input.focus();
                setTimeout(function () {
                    input.on('focus', function () {
                        $(this).datepicker('show');
                    });
                }, 500);
            }
        }
    }

    function focusSucc(partArr){
        removeAria();
        if(partArr === 'partenza'){
            $("#biglietti_ora_p_but").focus();
        }else if(partArr === 'ritorno'){
            $('#biglietti_ora_a_but').focus();
        }
    }

    function closeAndataCalendar() {
        removeAria();
        closeCalendar();
        $('#biglietti_data_pVISIBLE').focus();
    }

    function closeRitornoCalendar() {
        removeAria();
        closeCalendar();
        $('#biglietti_data_aVISIBLE').focus();
    }


    function removeAria() {
        // make the rest of the page accessible again:
        $(".dp-container").removeAttr('aria-hidden');
        $("#skipnav").removeAttr('aria-hidden');
        $(containerDP).off('keydown');
    }

    ///////////////////////////////
    //////////////////////////// //
    ///////////////////////// // //
    // UTILITY-LIKE THINGS // // //
    ///////////////////////// // //
    //////////////////////////// //
    ///////////////////////////////
    function isOdd(num) {
        return num % 2;
    }

    function moveOneMonth(currentDate, dir) {
        var button = (dir === 'next')
            ? $('.ui-datepicker-next')[0]
            : $('.ui-datepicker-prev')[0];

        if (!button) {
            return;
        }

        var ENABLED_SELECTOR = '#ui-datepicker-div tbody td:not(.ui-state-disabled)';
        var $currentCells = $(ENABLED_SELECTOR);
        var currentIdx = $.inArray(currentDate.parentNode, $currentCells);

        button.click();
        setTimeout(function () {
            updateHeaderElements();

            var $newCells = $(ENABLED_SELECTOR);
            var newTd = $newCells[currentIdx];
            var newAnchor = newTd && $(newTd).find('a')[0];

            while (!newAnchor) {
                currentIdx--;
                newTd = $newCells[currentIdx];
                newAnchor = newTd && $(newTd).find('a')[0];
            }

            setHighlightState(newAnchor, $('#ui-datepicker-div')[0]);
            newAnchor.focus();

        }, 0);

    }

    function handleNextClicks() {
        setTimeout(function () {
            updateHeaderElements();
            prepHighlightState();
            $('.ui-datepicker-next').focus();
        }, 0);
    }

    function handlePrevClicks() {
        setTimeout(function () {
            updateHeaderElements();
            prepHighlightState();
            $('.ui-datepicker-prev').focus();
        }, 0);
    }

    function previousDay(dateLink) {
        var container = document.getElementById('ui-datepicker-div');
        if (!dateLink) {
            return;
        }
        var td = $(dateLink).closest('td');
        if (!td) {
            return;
        }

        var prevTd = $(td).prev(),
            prevDateLink = $('a.ui-state-default', prevTd)[0];

        if (prevTd && prevDateLink) {
            setHighlightState(prevDateLink, container);
            prevDateLink.focus();
        } else {
            handlePrevious(dateLink);
        }
    }

    function handlePrevious(target) {
        var container = document.getElementById('ui-datepicker-div');
        if (!target) {
            return;
        }
        var currentRow = $(target).closest('tr');
        if (!currentRow) {
            return;
        }
        var previousRow = $(currentRow).prev();

        if (!previousRow || previousRow.length === 0) {
            // there is not previous row, so we go to previous month...
            previousMonth();
        } else {
            var prevRowDates = $('td a.ui-state-default', previousRow);
            var prevRowDate = prevRowDates[prevRowDates.length - 1];

            if (prevRowDate) {
                setTimeout(function () {
                    setHighlightState(prevRowDate, container);
                    prevRowDate.focus();
                }, 0);
            }
        }
    }

    function previousMonth() {
        var prevLink = $('.ui-datepicker-prev')[0];
        var container = document.getElementById('ui-datepicker-div');
        prevLink.click();
        // focus last day of new month
        setTimeout(function () {
            var trs = $('tr', container),
                lastRowTdLinks = $('td a.ui-state-default', trs[trs.length - 1]),
                lastDate = lastRowTdLinks[lastRowTdLinks.length - 1];

            // updating the cached header elements
            updateHeaderElements();

            setHighlightState(lastDate, container);
            lastDate.focus();

        }, 0);
    }

    ///////////////// NEXT /////////////////
    /**
     * Handles right arrow key navigation
     * @param  {HTMLElement} dateLink The target of the keyboard event
     */
    function nextDay(dateLink) {
        var container = document.getElementById('ui-datepicker-div');
        if (!dateLink) {
            return;
        }
        var td = $(dateLink).closest('td');
        if (!td) {
            return;
        }
        var nextTd = $(td).next(),
            nextDateLink = $('a.ui-state-default', nextTd)[0];

        if (nextTd && nextDateLink) {
            setHighlightState(nextDateLink, container);
            nextDateLink.focus(); // the next day (same row)
        } else {
            handleNext(dateLink);
        }
    }

    function handleNext(target) {
        var container = document.getElementById('ui-datepicker-div');
        if (!target) {
            return;
        }
        var currentRow = $(target).closest('tr'),
            nextRow = $(currentRow).next();

        if (!nextRow || nextRow.length === 0) {
            nextMonth();
        } else {
            var nextRowFirstDate = $('a.ui-state-default', nextRow)[0];
            if (nextRowFirstDate) {
                setHighlightState(nextRowFirstDate, container);
                nextRowFirstDate.focus();
            }
        }
    }

    function nextMonth() {
        nextMon = $('.ui-datepicker-next')[0];
        var container = document.getElementById('ui-datepicker-div');
        nextMon.click();
        // focus the first day of the new month
        setTimeout(function () {
            // updating the cached header elements
            updateHeaderElements();

            var firstDate = $('a.ui-state-default', container)[0];
            setHighlightState(firstDate, container);
            firstDate.focus();
        }, 0);
    }

    /////////// UP ///////////
    /**
     * Handle the up arrow navigation through dates
     * @param  {HTMLElement} target   The target of the keyboard event (day)
     * @param  {HTMLElement} cont     The calendar container
     * @param  {HTMLElement} prevLink Link to navigate to previous month
     */
    function upHandler(target, cont, prevLink) {
        prevLink = $('.ui-datepicker-prev')[0];
        var rowContext = $(target).closest('tr');
        if (!rowContext) {
            return;
        }
        var rowTds = $('td', rowContext),
            rowLinks = $('a.ui-state-default', rowContext),
            targetIndex = $.inArray(target, rowLinks),
            prevRow = $(rowContext).prev(),
            prevRowTds = $('td', prevRow),
            parallel = prevRowTds[targetIndex],
            linkCheck = $('a.ui-state-default', parallel)[0];

        if (prevRow && parallel && linkCheck) {
            // there is a previous row, a td at the same index
            // of the target AND theres a link in that td
            setHighlightState(linkCheck, cont);
            linkCheck.focus();
        } else if (!$(prevLink).hasClass('ui-state-disabled')) {
            // we're either on the first row of a month, or we're on the
            // second and there is not a date link directly above the target
            prevLink.click();
            setTimeout(function () {
                // updating the cached header elements
                updateHeaderElements();
                var newRows = $('tr', cont),
                    lastRow = newRows[newRows.length - 1],
                    lastRowTds = $('td', lastRow),
                    tdParallelIndex = $.inArray(target.parentNode, rowTds),
                    newParallel = lastRowTds[tdParallelIndex],
                    newCheck = $('a.ui-state-default', newParallel)[0];

                if (lastRow && newParallel && newCheck) {
                    setHighlightState(newCheck, cont);
                    newCheck.focus();
                } else {
                    // theres no date link on the last week (row) of the new month
                    // meaning its an empty cell, so we'll try the 2nd to last week
                    var secondLastRow = newRows[newRows.length - 2],
                        secondTds = $('td', secondLastRow),
                        targetTd = secondTds[tdParallelIndex],
                        linkCheck = $('a.ui-state-default', targetTd)[0];

                    if (linkCheck) {
                        setHighlightState(linkCheck, cont);
                        linkCheck.focus();
                    }

                }
            }, 0);
        }
    }

    //////////////// DOWN ////////////////
    /**
     * Handles down arrow navigation through dates in calendar
     * @param  {HTMLElement} target   The target of the keyboard event (day)
     * @param  {HTMLElement} cont     The calendar container
     * @param  {HTMLElement} nextLink Link to navigate to next month
     */
    function downHandler(target, cont, nextLink) {
        nextLink = $('.ui-datepicker-next')[0];
        var targetRow = $(target).closest('tr');
        if (!targetRow) {
            return;
        }
        var targetCells = $('td', targetRow),
            cellIndex = $.inArray(target.parentNode, targetCells), // the td (parent of target) index
            nextRow = $(targetRow).next(),
            nextRowCells = $('td', nextRow),
            nextWeekTd = nextRowCells[cellIndex],
            nextWeekCheck = $('a.ui-state-default', nextWeekTd)[0];

        if (nextRow && nextWeekTd && nextWeekCheck) {
            // theres a next row, a TD at the same index of `target`,
            // and theres an anchor within that td
            setHighlightState(nextWeekCheck, cont);
            nextWeekCheck.focus();
        } else {
            nextLink.click();

            setTimeout(function () {
                // updating the cached header elements
                updateHeaderElements();

                var nextMonthTrs = $('tbody tr', cont),
                    firstTds = $('td', nextMonthTrs[0]),
                    firstParallel = firstTds[cellIndex],
                    firstCheck = $('a.ui-state-default', firstParallel)[0];

                if (firstParallel && firstCheck) {
                    setHighlightState(firstCheck, cont);
                    firstCheck.focus();
                } else {
                    // lets try the second row b/c we didnt find a
                    // date link in the first row at the target's index
                    var secondRow = nextMonthTrs[1],
                        secondTds = $('td', secondRow),
                        secondRowTd = secondTds[cellIndex],
                        secondCheck = $('a.ui-state-default', secondRowTd)[0];

                    if (secondRow && secondCheck) {
                        setHighlightState(secondCheck, cont);
                        secondCheck.focus();
                    }
                }
            }, 0);
        }
    }


    function onCalendarHide() {
        closeCalendar();
    }

    // add an aria-label to the date link indicating the currently focused date
    // (formatted identically to the required format: mm/dd/yyyy)
    function monthDayYearText() {
        var cleanUps = $('.amaze-date');

        $(cleanUps).each(function (clean) {
            // each(cleanUps, function (clean) {
            clean.parentNode.removeChild(clean);
        });

        var datePickDiv = document.getElementById('ui-datepicker-div');
        // in case we find no datepick div
        if (!datePickDiv) {
            return;
        }

        var dates = $('a.ui-state-default', datePickDiv);
        $(dates).attr('role', 'button').on('keydown', function (e) {
            if (e.which === 32) {

                e.preventDefault();
                e.target.click();
                setTimeout(function () {
                    closeCalendar();
                }, 100);
            }
        });
        $(dates).each(function (index, date) {
            var currentRow = $(date).closest('tr'),
                currentTds = $('td', currentRow),
                currentIndex = $.inArray(date.parentNode, currentTds),
                headThs = $('thead tr th', datePickDiv),
                dayIndex = headThs[currentIndex],
                daySpan = $('span', dayIndex)[0],
                monthName = $('.ui-datepicker-month', datePickDiv)[0].innerHTML,
                year = $('.ui-datepicker-year', datePickDiv)[0].innerHTML,
                number = date.innerHTML;

            if (!daySpan || !monthName || !number || !year) {
                return;
            }

            // AT Reads: {month} {date} {year} {day}
            // "December 18 2014 Thursday"
            var dateText = date.innerHTML + ' ' + monthName + ' ' + year + ' ' + daySpan.title;
            // AT Reads: {date(number)} {name of day} {name of month} {year(number)}
            // var dateText = date.innerHTML + ' ' + daySpan.title + ' ' + monthName + ' ' + year;
            // add an aria-label to the date link reading out the currently focused date
            date.setAttribute('aria-label', dateText);
        });
    }

    // update the cached header elements because we're in a new month or year
    function updateHeaderElements() {
        var context = document.getElementById('ui-datepicker-div');
        if (!context) {
            return;
        }

        prev = $('.ui-datepicker-prev', context)[0];
        next = $('.ui-datepicker-next', context)[0];

        //make them click/focus - able
        next.href = 'javascript:void(0)';
        prev.href = 'javascript:void(0)';

        next.setAttribute('role', 'button');
        prev.setAttribute('role', 'button');
        appendOffscreenMonthText(next);
        appendOffscreenMonthText(prev);

        $(next).on('click', handleNextClicks);
        $(prev).on('click', handlePrevClicks);

        // add month day year text
        monthDayYearText();
    }

    function prepHighlightState() {
        var highlight;
        var cage = document.getElementById('ui-datepicker-div');
        highlight = $('.ui-state-highlight', cage)[0] ||
            $('.ui-state-default', cage)[0];
        if (highlight && cage) {
            setHighlightState(highlight, cage);
        }
    }

    // Set the highlighted class to date elements, when focus is received
    function setHighlightState(newHighlight, container) {
        var prevHighlight = getCurrentDate(container);
        // remove the highlight state from previously
        // highlighted date and add it to our newly active date
        $(prevHighlight).removeClass('ui-state-highlight');
        $(newHighlight).addClass('ui-state-highlight');
    }

    // grabs the current date based on the highlight class
    function getCurrentDate(container) {
        var currentDate = $('.ui-state-highlight', container)[0];
        return currentDate;
    }

    /**
     * Appends logical next/prev month text to the buttons
     * - ex: Next Month, January 2015
     *       Previous Month, November 2014
     */
    function appendOffscreenMonthText(button) {
        var buttonText;
        var isNext = $(button).hasClass('ui-datepicker-next');


        var months = monthsList ? monthsList.split(',') : [];


        var monthName = $('.ui-datepicker-title .ui-datepicker-month');
        var yearName = $('.ui-datepicker-title .ui-datepicker-year');
        var prevMonth, currentMonth, currentYear, monthIndex, modifier;

        // console.log("months: "+months);

        if (monthName.length > 1) {
            prevMonth = monthName.first().text().toLowerCase();
            currentMonth = monthName.last().text().toLowerCase();
            currentYear = yearName.last().text();

            modifier = 2;

        } else {
            prevMonth = currentMonth = monthName.text().toLowerCase();
            currentYear = yearName.text();
            modifier = 1;
        }

        // console.log("currentMonth: "+currentMonth);
        // console.log("modifier: "+modifier);

        monthIndex = $.inArray(currentMonth, months);
        // console.log("monthIndex: "+monthIndex);

        var adjacentIndex = (isNext) ? monthIndex + 1 : monthIndex - modifier;
        // console.log("adjacentIndex: "+adjacentIndex);

        if (isNext && currentMonth === months[11]) {
            currentYear = parseInt(currentYear, 10) + 1;
            adjacentIndex = 0;
        } else if (!isNext && prevMonth === months[0]) {
            currentYear = parseInt(currentYear, 10) - 1;
            adjacentIndex = months.length - 1;
        }
        // console.log("adjacentIndex: "+adjacentIndex);
        // Bonificata anomalia navigazione calendario con doppio mese visualizzato 22/07/2020 - Start
        if (adjacentIndex == -2) {
            adjacentIndex = 10;
        }

        var monthText = firstToCap(months[adjacentIndex]);

        buttonText = (isNext) ? 'Prossimo Mese, ' + monthText + ' ' + currentYear :
            'Mese Precedente, ' + monthText + ' ' + currentYear;

        $(button).find('.ui-icon').html(buttonText);

    }

    // Returns the string with the first letter capitalized
    function firstToCap(s) {
        if (s != undefined) return s.charAt(0).toUpperCase() + s.slice(1);
    }

    /*
     * lastMod 13-07-2018 h1200
     * floodlight-stazioni su cruscotto v2
     * addSmartBannerMobile new msg
     */

    /* Start: tcom18 */
    var tcom18 = {
        lang: ($('html').attr('lang') == 'en') ? 'en' : 'it',
        mSize: (Modernizr.touchevents) ? 700 : 683,
        /* _label : ((($('html').attr('lang')=='en')?'en':'it')=='en') ?_labels.en : _labels.it, */
        _label: _labels.it,
        frecce: [],
        allTrain: [],
        _roundTripInternal: "false",

        /* Start: init */
        init: function () {
            try {
                isSafariBrwsr = (navigator.vendor && navigator.vendor.indexOf('Apple') > -1) && (navigator.userAgent && !navigator.userAgent.match('CriOS'));
            } catch (e) {
            }

            try {
                tcom18.calendari();
            } catch (e) {
            }

            try {
                tcom18.initFormCruscotto(); /* init suggestion e valori predefiniti nella form biglietti */
            } catch (e) {
            }

            try {
                tcom18.addLastTrainSearchListBox();
            } catch (e) {
            }

            /* init form ricerca nel sito */
            try {
                $('#searchNew').val($('#searchNew').attr('title'));
                $('#searchTopNew').val($('#searchTopNew').attr('title'));
            } catch (e) {
            }

            /* script x pags interne */
            try {
                tcom18.initAccordion();
            } catch (e) {
            }
            //		try{
            //			tcom18.fixBoxSocialPos();
            //		}catch(e){}
            try {
                setTimeout(function () {
                    tcom18.fixElemLeftOuterHeight();
                }, 200);
                setTimeout(function () {
                    tcom18.fixElemLeftOuterHeight();
                }, 7000);
            } catch (e) {
            }

            try {
                tcom18.emotional.init();
            } catch (e) {
            }

            try {
                tcom18.addPlaceHolder();
            } catch (e) {
            }

            try {
                tcom18.addSmartBannerMobile();
            } catch (e) {
            }

            try {
                tcom18.fixInputTypeSearchFields();
            } catch (e) {
            }
            /*
            try{
                tcom18.fixMouseOverMenuTablet();
            }catch(e){}
            */
        },
        /* End: init */


        /*
            checkForm : function(e){
                return true;
            },
        */

        /* Start: calendari */
        calendari: function () {
            if ($('#formcruscotto').length > 0) {

                now = new Date();
                myDate = new Date();
                oDate = new Date();
                // ------------------------- fine old data

                Lang = $('html').attr('lang');
                AddHours = Lang == 'fr' ? 3 : 1;
                msRange = 60 * 60 * 1000 * AddHours;
                //intervalloOrarioMinuti = 60;

                CurrentDateTime = new Date();
                DataAttuale = formatTo2Char(CurrentDateTime.getDate()) + ' ' + _labels.it.monthNamesShort[CurrentDateTime.getMonth()] + ' ' + CurrentDateTime.getFullYear();

                DateTimePartenza = formatTo15Min(new Date(CurrentDateTime));
                DateTimeRitorno = formatTo15Min(new Date(DateTimePartenza));

                DateTimeRitorno.setHours(DateTimeRitorno.getHours() + AddHours);

                function getDataToString(scope) {
                    let dataToString;
                    switch (scope) {
                        case 'a':
                            dataToString = formatTo2Char(DateTimeRitorno.getDate()) + ' ' + _labels.it.monthNamesShort[DateTimeRitorno.getMonth()] + ' ' + DateTimeRitorno.getFullYear();
                            break;

                        default:
                            dataToString = formatTo2Char(DateTimePartenza.getDate()) + ' ' + _labels.it.monthNamesShort[DateTimePartenza.getMonth()] + ' ' + DateTimePartenza.getFullYear();
                            break;
                    }
                    return dataToString
                };

                function initAR() {
                    $('#biglietti_data_p').val(getDataToString());
                    $('#biglietti_data_aVISIBLE').val(getDataToString('a'));
                    $('#biglietti_data_p').val(getDataToString());
                    $('#biglietti_data_a').val(getDataToString('a'));
                    setTime();
                    setTime('a');
                };

                function setTime(scope) {
                    let orarioToSet, newTime;
                    switch (scope) {
                        case 'a':
                            // orarioToSet = $('#biglietti_ora_a');
                            newTime = formatTo2Char(DateTimeRitorno.getHours()) + ':' + formatTo2Char(DateTimeRitorno.getMinutes());
                            $('#biglietti_ora_a').val(newTime);
                            $('#biglietti_ora_a_but').val(newTime);
                            break;
                        default:
                            // orarioToSet = $('#biglietti_ora_p');
                            newTime = formatTo2Char(DateTimePartenza.getHours()) + ':' + formatTo2Char(DateTimePartenza.getMinutes());
                            $('#biglietti_ora_p').val(newTime);
                            $('#biglietti_ora_p_but').val(newTime);
                            break;
                    }

                    // orarioToSet.val(newTime);
                    // orarioToSet.children('option')
                    //     .removeAttr('selected')
                    //     .filter('[value="'+ newTime + '"]')
                    //     .attr('selected', true);
                };

                function setDate(scope) {
                    switch (scope) {
                        case 'a':
                            $('#biglietti_data_aVISIBLE').datepicker("setDate", DateTimeRitorno);
                            $('#biglietti_data_aVISIBLE').datepicker("option", "minDate", $('#biglietti_data_p').val());
                            $('#biglietti_data_a').val($('#biglietti_data_aVISIBLE').val());
                            break;
                        default:
                            $('#biglietti_data_p').datepicker("setDate", DateTimePartenza);
                            $('#biglietti_data_p').val($('#biglietti_data_pVISIBLE').val());
                            break;
                    }
                };

                function resetTime(scope) {
                    let orarioToReset
                    switch (scope) {
                        case 'a':
                            // update dateObj_R
                            DateTimeRitorno.setHours(0);
                            DateTimeRitorno.setMinutes(0);
                            // select DOM selector
                            // orarioToReset = $('#biglietti_ora_a');
                            $('#biglietti_ora_a').val("00:00");
                            $('#biglietti_ora_a_but').val("00:00");

                            break;

                        default:
                            // update dateObj_P
                            DateTimePartenza.setHours(0);
                            DateTimePartenza.setMinutes(0);
                            // select DOM selector
                            // orarioToReset = $('#biglietti_ora_p');
                            $('#biglietti_ora_p').val("00:00");
                            $('#biglietti_ora_p_but').val("00:00");
                            break;
                    }
                    // update DOM
                    // orarioToReset.children('option')
                    //     .removeAttr('selected')
                    //     .filter('[value="00:00"]')
                    //     .attr('selected', true);
                }

                function checkRitorno(isOnlyMsRange) {
                    if (isOnlyMsRange) {
                        DateTimeRitorno = new Date(DateTimePartenza);
                        DateTimeRitorno.setHours(DateTimePartenza.getHours() + AddHours);
                    } else if ((DateTimeRitorno - DateTimePartenza) < msRange) {
                        // update dateObj
                        DateTimeRitorno = new Date(DateTimePartenza);
                        DateTimeRitorno.setHours(DateTimeRitorno.getHours() + AddHours);
                    }
                    // update DOM
                    setDate('a');
                    setTime('a');
                    $('#biglietti_data_aVISIBLE').datepicker("option", "minDate", $('#biglietti_data_p').val());
                };

                $(document).ready(function() {
                    initAR();
                    $('#biglietti_ora_p').on('change', function (e) {
                        e.preventDefault();
                        currentTime = CurrentDateTime.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});
                        previousTime = $('#biglietti_ora_p').val();
                        if ($('#biglietti_data_p').val() == DataAttuale && previousTime < currentTime) {
                            alert('selezionare un orario valido');
                            setTime('p');
                        } else {
                            newTime = $(e.target).val().split(":");
                            // update dateObj
                            var isOnlyMsRange = false;
                            if ((DateTimeRitorno - DateTimePartenza) == msRange) {
                                isOnlyMsRange = true;
                            }
                            // update dateObj
                            DateTimePartenza.setHours(newTime[0]);
                            DateTimePartenza.setMinutes(newTime[1]);
                            // update DOM
                            setTime('p');
                            checkRitorno(isOnlyMsRange);
                        }
                    });

                    $('#biglietti_ora_a').on('change', function (e) {
                        e.preventDefault();

                        newTime = $(e.target).val().split(':');
                        // update dateObj
                        DateTimeRitorno.setHours(newTime[0]);
                        DateTimeRitorno.setMinutes(newTime[1]);
                        // update DOM
                        setTime('a');
                        checkRitorno();

                    });
                });

                $('#biglietti_data_pVISIBLE').on('mouseenter', function (e) {
                    $('#biglietti_data_pVISIBLE').blur();
                })

                $("#biglietti_data_pVISIBLE").datepicker({
                    // buttonImage: 		_cfg.calImg,
                    // buttonImageOnly: 	true,
                    firstDay: _cfg.firstDayCalendar,
                    /*
                    monthNames: 		_labels.it.monthNames,
                    */
                    monthNames: _labels.it.monthNames,
                    monthNamesShort: _labels.it.monthNamesShort,
                    dayNamesMin: _labels.it.dayNamesMin,
                    dayNames: _labels.it.dayNames,
                    // showOn: 			"focus",
                    buttonText: _labels.it.buttonCal,
                    showButtonPanel: true,
                    closeText: _labels.it.buttonCloseText,
                    dateFormat: "dd M yy",
                    //dateFormat: 		"dd-mm-yy",
                    showOtherMonths: false,
                    selectOtherMonths: false,
                    minDate: 0,
                    changeMonth: false,
                    numberOfMonths: 2,
                    //onClose: function(dateText, inst){},
                    onClose: closeAndataCalendar,
                    beforeShow: function (input, inst) {
                        // fabio 3 start
                        //$("#selHoursDep").slideUp();
                        //$("#selHoursRet").slideUp();
                        // fabio 3 end

                        if ($(window).width() > tcom18.mSize) {
                            $("#biglietti_data_pVISIBLE").datepicker("option", "numberOfMonths", 2);
                        } else {
                            $("#biglietti_data_pVISIBLE").datepicker("option", "numberOfMonths", 1);
                        }
                        /* $(this).attr("disabled", true); */
                        dayTripper("partenza");
                        selectedInput = $(input);
                    },
                    onSelect: function onSelectDatepickerDate(selectedDate, datepickerInstance) {
                        var now = formatTo15Min(new Date());
                        var currentTime = formatTo15Min(new Date()).toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        var scope = (datepickerInstance.input[0].id).substring(15, 16);
                        var orarioPartenza = DateTimePartenza.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        var orarioRitorno = DateTimeRitorno.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });

                        if (selectedDate !== datepickerInstance.lastVal) {
                            switch (scope) {
                                case 'a':
                                    DateTimeRitorno.setFullYear(datepickerInstance.selectedYear, datepickerInstance.selectedMonth, datepickerInstance.selectedDay);
                                    if (selectedDate != datepickerInstance.lastVal && selectedDate != $('#biglietti_data_p').val()) {
                                        if (Lang == 'fr') {
                                            resetTime(scope);
                                        } else {
                                            DateTimeRitorno.setHours(now.getHours());
                                            DateTimeRitorno.setMinutes(now.getMinutes());
                                            setTime('a');
                                        }
                                    }
                                    checkRitorno();
                                    break;
                                default:
                                    // update dateObj_P
                                    DateTimePartenza.setFullYear(datepickerInstance.selectedYear, datepickerInstance.selectedMonth, datepickerInstance.selectedDay);
                                    // update DOM
                                    setDate(scope);

                                    if (selectedDate != DataAttuale && Lang == 'fr') {
                                        resetTime(scope);
                                    }

                                    if ((selectedDate == DataAttuale) && (orarioPartenza < currentTime)) {
                                        DateTimePartenza.setHours(now.getHours());
                                        DateTimePartenza.setMinutes(now.getMinutes());
                                        setTime();
                                    }
                                    ;
                                    if (!isAR()) {
                                        setDate('a');
                                        checkRitorno(true);
                                    } else {
                                        checkRitorno();
                                    }
                                    break;
                            }
                            ;

                        }


                    }
                }).css("z-index", 10);

                //Controllo se l'input delle date rimane vuoto...se rimane vuoto ci metto la data di oggi
                $(".hasDatepicker").on("click", function (e) {
                    if ($('#biglietti_data_pVISIBLE').val() == '') {
                        var thetime = new Date();
                        nhours = thetime.getHours();
                        var gg = thetime.getDate();
                        var mm = thetime.getMonth()
                        mm++;
                        if (String(nhours).length == 1) nhours = '0' + nhours;
                        if (String(gg).length == 1) gg = '0' + gg;
                        if (String(mm).length == 1) mm = '0' + mm;
                        DataAttuale = gg + ' ' + _labels.it.monthNamesShort[thetime.getMonth()];
                        $("#biglietti_data_pVISIBLE").val(DataAttuale);
                        $("#biglietti_data_p").val(DataAttuale);
                    }
                    if ($('#biglietti_data_aVISIBLE').val() == '') {
                        
                        var thetime = new Date();
                        nhours = thetime.getHours();
                        var gg = thetime.getDate();
                        var mm = thetime.getMonth()
                        mm++;
                        if (String(nhours).length == 1) nhours = '0' + nhours;
                        if (String(gg).length == 1) gg = '0' + gg;
                        if (String(mm).length == 1) mm = '0' + mm;
                        DataAttuale = gg + ' ' + _labels.it.monthNamesShort[thetime.getMonth()];
                        $("#biglietti_data_aVISIBLE").val(DataAttuale);
                        $("#biglietti_data_a").val(DataAttuale);
                    }
                });

                // fabio start
                // Permette di abilitare la data di ritorno cliccando direttamente sul campo stesso
                $(document).ready(function () {
                    $("#label_ritorno").click(function () {
                        $('[name=isRoundTrip]').trigger('click');
                        // $("#andata-ritorno").trigger('click');
                    });

                    $("#label_ritorno_img").click(function () {
                        var x = $('#label_ritorno_img').attr('for');
                        console.log("Valore attr: " + x);

                        if (x != "biglietti_data_aVISIBLE") {
                            console.log("attributo NON trovato");
                            $('[name=isRoundTrip]').trigger('click');
                            // $("#andata-ritorno").trigger('click');
                        }
                    });
                });

                function setAttrFor() {
                    setTimeout(function () {
                        $('#label_ritorno_img').attr({for: 'biglietti_data_aVISIBLE'});
                    }, 500);
                }

                function isAR() {
                    return $('#biglietti_ar').prop('checked');
                }

                // fabio end

                // Se clicco sul check andata e ritorno
                //$('#biglietti_ar').click(function(){
                $("[name=isRoundTrip]").click(function () {
                    tcom18._roundTripInternal = $("[name=isRoundTrip]:checked").val();
                    if (tcom18._roundTripInternal == "true") {
                        $('#ritorno').removeClass("disabled");
                        $('#biglietti_data_aVISIBLE').removeAttr("disabled");
                        setAttrFor(); // fabio
                        $('#biglietti_ora_a').removeAttr("disabled");
                        // fabio 3 start
                        $('#biglietti_ora_a_but').removeAttr("disabled");
                        // fabio 3 end
                        $("#biglietti_data_aVISIBLE").datepicker("setDate", $("#biglietti_data_pVISIBLE").datepicker("getDate"));
                        $("#biglietti_data_a").val($("#biglietti_data_p").val());
                        //$("#biglietti_ora_a").val($("#biglietti_ora_p").val()); // fabio
                        $('#biglietti_data_aVISIBLE').datepicker("option", "minDate", $('#biglietti_data_aVISIBLE').val());
                        //Label ritorno spenta
                        $('#label_ritorno').css("display", "none");
                        $('#biglietti_data_aVISIBLE').css("display", "inline-block");
                        // fabio 3 start
                        //$('#biglietti_ora_a').css("display", "inline-block");
                        $('#biglietti_ora_a_but').css("display", "inline-block");
                        // fabio 3 end
                        $("#andata-ritorno-mobile .spento").css('display', "none");
                        $("#andata-ritorno-mobile .acceso").css('display', "block");
                    } else {
                        $('#ritorno').addClass("disabled");
                        $('#biglietti_data_aVISIBLE').attr("disabled", "disabled");
                        $('#biglietti_ora_aVISIBLE').attr("disabled", "disabled");
                        // fabio 3 start
                        $('#label_ritorno_img').attr({for: ''});
                        $("#selHoursRet").slideUp();
                        // fabio 3 end
                        //console.log("Ho cliccato sul check desktop e sono SPENTO");
                        //label ritorno accesa
                        $('#label_ritorno').css("display", "inline-block");
                        $('#biglietti_data_aVISIBLE').css("display", "none");
                        // fabio 3 start
                        //$('#biglietti_ora_a').css("display", "none");
                        $('#biglietti_ora_a_but').css("display", "none");
                        // fabio 3 end
                        $("#andata-ritorno-mobile .spento").css('display', "block");
                        $("#andata-ritorno-mobile .acceso").css('display', "none");
                    }
                    $("#biglietti_ar_circular").focus();
                });

                $("[name=checkMigliorPrezzo]").click(function () {
                    $("#boxMigliorPrezzo_circular").focus();
                });


                // Allinea il check andata e ritorno desktop con quello del andata-ritorno-mobile (sono due check differenti)
                var andataRitMobile = false;
                $(document).ready(function () {
                    $("#andata-ritorno-mobile").click(function () {
                        if ($("#andata-ritorno-mobile img.acceso").css('display') == "block") {
                            console.log("Sono ACCESO");
                            tcom18._roundTripInternal = "true";
                            andataRitMobile = true;
                        } else {
                            console.log("Sono SPENTO");
                            tcom18._roundTripInternal = "false";
                            andataRitMobile = false;
                        }
                        if (tcom18._roundTripInternal == "true") {
                            // Andata e ritorno True
                            console.log("tcom18 - Sono nel ramo true");
                            $('#ritorno').removeClass("disabled");
                            $('#biglietti_data_aVISIBLE').removeAttr("disabled");
                            $('#biglietti_ora_a').removeAttr("disabled");
                            // fabio 3 start
                            $('#biglietti_ora_a_but').removeAttr("disabled");
                            // fabio 3 end
                            $('#label_ritorno_img').attr({for: 'biglietti_data_aVISIBLE'}); // fabio
//                            $('#biglietti_data_aVISIBLE').datepicker("option", "minDate", $('#biglietti_data_pVISIBLE').val());
//                            $("#biglietti_data_aVISIBLE").datepicker("setDate", $("#biglietti_data_pVISIBLE" ).datepicker("getDate"));
//                            $("#biglietti_data_aVISIBLE").val($("#biglietti_data_pVISIBLE").val());
//                            $("#biglietti_ora_a").val($("#biglietti_ora_p").val());
//                            $("#biglietti_ora_a_but").prop('value', $("#biglietti_ora_p").val()); // fabio 3
                            $('#label_ritorno').css("display", "none");
                            $('#biglietti_data_aVISIBLE').css("display", "inline-block");
                            // fabio 3 start
                            $('#biglietti_ora_a').css("display", "inline-block");
                            $('#biglietti_ora_a_but').css("display", "inline-block");
                            // fabio 3 end
                        } else {
                            // Andata e ritorno False
                            console.log("tcom18 - Sono nel ramo else");
                            $('#ritorno').addClass("disabled");
                            $('#biglietti_data_a').attr("disabled", "disabled");
                            $('#biglietti_ora_a').attr("disabled", "disabled");
                            // fabio 3 start
                            $('#biglietti_ora_a_but').attr("disabled", "disabled");
                            // fabio 3 end
                            $('#label_ritorno_img').attr({for: ''}); // fabio
                            $('#label_ritorno').css("display", "inline-block");
                            $('#biglietti_data_aVISIBLE').css("display", "none");
                            // fabio 3 start
                            $('#biglietti_ora_a').css("display", "none");
                            $('#biglietti_ora_a_but').css("display", "none");
                            // fabio 3 end
                        }
                    });

                    // $("#andata-ritorno").click(function(){
                    // 	if($("#andata-ritorno img.acceso").css('display')=="block"){
                    // 		console.log("Sono ACCESO");
                    // 		tcom18._roundTripInternal = "true";
                    // 		andataRitMobile = true;
                    // 	}else{
                    // 		console.log("Sono SPENTO");
                    // 		tcom18._roundTripInternal = "false";
                    // 		andataRitMobile = false;
                    // 	}
                    // 	if (tcom18._roundTripInternal=="true"){
                    // 		// Andata e ritorno True
                    // 		console.log("tcom18 - Sono nel ramo true");
                    // 		$("[name=returnDate]").datepicker("enable");
                    // 		$('#ritorno').removeClass("disabled");
                    // 		$('#biglietti_data_aVISIBLE').removeAttr("disabled");
                    // 		$('#biglietti_ora_a').removeAttr("disabled");
                    // 		// fabio 3 start
                    // 		$('#biglietti_ora_a_but').removeAttr("disabled");
                    // 		// fabio 3 end
                    // 		$('#label_ritorno_img').attr({for:'biglietti_data_aVISIBLE'}); // fabio
                    // 		$('#biglietti_data_aVISIBLE').datepicker("option", "minDate", $('#biglietti_data_pVISIBLE').val());
                    // 		$("#biglietti_data_aVISIBLE").datepicker("setDate", $("#biglietti_data_pVISIBLE" ).datepicker("getDate"));
                    // 		$("#biglietti_data_aVISIBLE").val($("#biglietti_data_pVISIBLE").val());
                    // 		$("#biglietti_ora_a").val($("#biglietti_ora_p").val());
                    // 		$("#biglietti_ora_a_but").prop('value', $("#biglietti_ora_p").val()); // fabio 3
                    // 		$('#label_ritorno').css("display", "none");
                    // 		$('#biglietti_data_aVISIBLE').css("display", "inline-block");
                    // 		// fabio 3 start
                    // 		//$('#biglietti_ora_a').css("display", "inline-block");
                    // 		$('#biglietti_ora_a_but').css("display", "inline-block");
                    // 		// fabio 3 end
                    // 	} else {
                    // 		// Andata e ritorno False
                    // 		console.log("tcom18 - Sono nel ramo else");
                    // 		$("[name=returnDate]").val("").datepicker("disable");
                    // 		$('#ritorno').addClass("disabled");
                    // 		$('#biglietti_data_a').attr("disabled","disabled");
                    // 		$('#biglietti_ora_a').attr("disabled","disabled");
                    // 		// fabio 3 start
                    // 		$('#biglietti_ora_a_but').attr("disabled","disabled");
                    // 		// fabio 3 end
                    // 		$('#label_ritorno_img').attr({for:''}); // fabio
                    // 		$('#label_ritorno').css("display", "inline-block");
                    // 		$('#biglietti_data_aVISIBLE').css("display", "none");
                    // 		// fabio 3 start
                    // 		//$('#biglietti_ora_a').css("display", "none");
                    // 		$('#biglietti_ora_a_but').css("display", "none");
                    // 		// fabio 3 end
                    // 	}
                    // });


                });

                $('#biglietti_data_aVISIBLE').on('mouseenter', function (e) {
                    $('#biglietti_data_aVISIBLE').blur();
                })

                $("#biglietti_data_aVISIBLE").datepicker({
                    // buttonImage: 	_cfg.calImg,
                    buttonImageOnly: true,
                    firstDay: _cfg.firstDayCalendar,
                    /*
                    monthNames: 		_labels.it.monthNames,
                    */
                    monthNames: _labels.it.monthNames,
                    monthNamesShort: _labels.it.monthNamesShort,
                    dayNamesMin: _labels.it.dayNamesMin,
                    dayNames: _labels.it.dayNames,
                    showOn: "focus",
                    buttonText: _labels.it.buttonCal,
                    showButtonPanel: true,
                    closeText: _labels.it.buttonCloseText,
                    dateFormat: "dd M yy",
                    //dateFormat: 		"dd-mm-yy",
                    showOtherMonths: false,
                    selectOtherMonths: false,
                    minDate: 0,
                    changeMonth: false,
                    numberOfMonths: 2,
                    //onClose: function(dateText, inst){ /* $(this).attr("disabled", false); */},
                    onClose: closeRitornoCalendar,
                    beforeShow: function (input, inst) {
                        // fabio 3 start
                        //$("#selHoursDep").slideUp();
                        //$("#selHoursRet").slideUp();
                        // fabio 3 end

                        if ($(window).width() > tcom18.mSize) {
                            $("#biglietti_data_aVISIBLE").datepicker("option", "numberOfMonths", 2);
                        } else {
                            $("#biglietti_data_aVISIBLE").datepicker("option", "numberOfMonths", 1);
                        }
                        /* $(this).attr("disabled", true); */
                        dayTripper("ritorno");
                        selectedInput = $(input);
                    },
                    //onSelect: function( selectedDate ) {
                    onSelect: function onSelectDatepickerDate(selectedDate, datepickerInstance) {
                        var now = formatTo15Min(new Date());
                        var currentTime = formatTo15Min(new Date()).toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        var scope = (datepickerInstance.input[0].id).substring(15, 16);
                        var orarioPartenza = DateTimePartenza.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        var orarioRitorno = DateTimeRitorno.toLocaleTimeString([], {
                            hour: '2-digit',
                            minute: '2-digit'
                        });

                        if (selectedDate !== datepickerInstance.lastVal) {
                            switch (scope) {
                                case 'a':
                                    DateTimeRitorno.setFullYear(datepickerInstance.selectedYear, datepickerInstance.selectedMonth, datepickerInstance.selectedDay);
                                    if (selectedDate != datepickerInstance.lastVal && selectedDate != $('#biglietti_data_p').val()) {
                                        if (Lang == 'fr') {
                                            resetTime(scope);
                                        } else {
                                            DateTimeRitorno.setHours(now.getHours());
                                            DateTimeRitorno.setMinutes(now.getMinutes());
                                            setTime('a');
                                        }
                                    }
                                    checkRitorno();
                                    break;
                                default:
                                    // update dateObj_P
                                    DateTimePartenza.setFullYear(datepickerInstance.selectedYear, datepickerInstance.selectedMonth, datepickerInstance.selectedDay);
                                    // update DOM
                                    setDate(scope);

                                    if (selectedDate != DataAttuale && Lang == 'fr') {
                                        resetTime(scope);
                                    }

                                    if ((selectedDate == DataAttuale) && (orarioPartenza < currentTime)) {
                                        DateTimePartenza.setHours(now.getHours());
                                        DateTimePartenza.setMinutes(now.getMinutes());
                                        setTime();
                                    }
                                    ;
                                    if (!isAR()) {
                                        setDate('a');
                                        checkRitorno(true);
                                    } else {
                                        checkRitorno();
                                    }
                                    break;
                            }
                            ;

                        }


                    }
                }).css("z-index", 10);



                try {
                    tcom18.fixWidgetsSmartPhone();
                } catch (e) {
                }
            }

            $("input,select,textarea,a").filter(".trigger").each(function () {
                if ($(this).hasClass("empty-on-click"))
                    $(this).click(function () {
                        $(this).val("");
                    });
                if ($(this).hasClass("read-only"))
                    $(this).attr("readonly", "readonly");

                if ($(this).hasClass("calendar")) {
                    if ($(this).attr('id') != "biglietti_data_p" && $(this).attr('id') != "biglietti_data_a") {
                        $(this).datepicker({
                            //buttonImage: 		_cfg.calImg,
                            // buttonImageOnly: 	false,
                            // showOn: 			"focus",
                            // buttonText: 		_labels.it.buttonCal,
                            firstDay: _cfg.firstDayCalendar,
                            /*
                            monthNames: 		_labels.it.monthNames,
                            */
                            monthNames: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
                            monthNamesShort: _labels.it.monthNamesShort,
                            dayNamesMin: _labels.it.dayNamesMin,
                            dayNames: _labels.it.dayNames,
                            // showOn: 			"focus",
                            buttonText: _labels.it.buttonCal,
                            showButtonPanel: true,
                            closeText: _labels.it.buttonCloseText,
                            dateFormat: "dd-mm-yy",
                            showOtherMonths: true,
                            selectOtherMonths: true,
                            changeMonth: false,
                            numberOfMonths: 1,
                            onClose: function (dateText, inst) { /* $(this).attr("disabled", false); */
                            },
                            beforeShow: function (input, inst) {
                                dayTripper("");
                                selectedInput = $(input);
                            },
                            onSelect: function (selectedDate) {
                                datePart = selectedDate;

                                if ($(this).attr('id') == "datepicker") {
                                    $('#codicePNR').focus();
                                } else if ($(this).attr('id') == "data_da_1") {
                                    $('#biglietti_from_1').focus();
                                } else if ($(this).attr('id') == "data_a_1") {
                                    $('#biglietti_to_1').focus();
                                } else if ($(this).attr('id') == "data_da_2") {
                                    $('#biglietti_from_2').focus();
                                } else if ($(this).attr('id') == "data_a_2") {
                                    $('#biglietti_to_2').focus();
                                } else if ($(this).attr('id') == "data_da_3") {
                                    $('#biglietti_from_3').focus();
                                } else if ($(this).attr('id') == "data_a_3") {
                                    $('#biglietti_to_3').focus();
                                } else if ($(this).attr('id') == "data_da_4") {
                                    $('#biglietti_from_4').focus();
                                } else if ($(this).attr('id') == "data_a_4") {
                                    $('#biglietti_to_4').focus();

                                } else if ($(this).attr('id') == "dataInizio") {
                                    $('#dataInizio').focus();
                                } else if ($(this).attr('id') == "dataFine") {
                                    $('#dataFine').focus();
                                }
                            }
                        }).css("z-index", 0);
                    }
                }
                if ($("[name=isRoundTrip]:checked").val() == "false") {
                    $("[name=returnDate]").val("").datepicker("disable");
                    $("[name=returnDate]").val($(""));

                }
            });
        },
        /* End: calendari */


        /* Start: parseDate */
        parseDate: function () {
            $("#dataInizio").val($("#dataInizio").val().replace(/-/g, "/"));
            $("#dataFine").val($("#dataFine").val().replace(/-/g, "/"));
        },
        /* End: parseDate */


        /* Start: addLastTrainSearchListBox */
        addLastTrainSearchListBox: function () {
            /*
            try {
                var pathSite = location.pathname;
                var isEnabled = ((pathSite.indexOf('/tcom-en') != 0) && (pathSite.indexOf('/tcom-de') != 0) && (pathSite.indexOf('/tcom-fr') != 0));
                if (isEnabled && (navigator.cookieEnabled)) {
                    setTimeout(function () {
                        $.getScript(_cfg.lastTrainsJS);
                    }, 1000);
                }
            } catch (e) {
            }
            */
        },
        /* End: addLastTrainSearchListBox */


        /* Start: suggestion */
        suggestion: function () {

            if ($("#biglietti_fromNew").length != 0 || $("#biglietti_toNew").length != 0 || $('#AbdepartureStation').length != 0 || $('#AbarrivalStation').length != 0
                || $('#departureStationCarnet').length != 0 || $('#arrivalStationCarnet').length != 0 || $('.suggestion').length != 0) {

                $.getJSON(_cfg.stations, function (data) {
                    evidence = new Array();
                    //console.log("evidence: "+evidence);
                    $.each(data, function (key, value) {
                        //console.log("- value: "+value);
                        $.each(value, function (key, value) {
                            //console.log("key: "+key);
                            //console.log("value: "+value);
                            tcom18.allTrain.push(key);
                            if (value.isF == 1) {
                                tcom18.frecce.push(key);
                            }
                            if (value.isE == 1) {
                                evidence.push(key);
                            }
                        });
                    });


                    $("#biglietti_fromNew, #biglietti_toNew, #AbdepartureStation, #AbarrivalStation, #departureStationCarnet, #arrivalStationCarnet, .suggestion").each(function (i, e) {

                        $(e).autocomplete({
                            autoFocus: true,
                            minLength: 2,
                            source: function (request, response) {
                                /* seleziono lista treni frecce/tutti */
                                repItems = ($('input[name=selectedTrainType]').val() == "frecce") ? tcom18.frecce : tcom18.allTrain;
                                console.log("repItems: " + repItems);
                                console.log("repItems.length: " + repItems.length);

                                /*
                                 * Prima prendo quelli che cominciano con la query
                                 * Poi aggiungo quelli che la contengono ma non all'inizio
                                 */
                                var res_starts = $.map(repItems, function (tag) {
                                    //console.log("res_starts "+res_starts);7
                                    //console.log("tag "+tag);
                                    if (tag.toUpperCase().indexOf(request.term.toUpperCase()) == 0) {
                                        //console.log("tag1: "+tag);
                                        return tag;
                                    }
                                });
                                var res_contains = $.map(repItems, function (tag) {
                                    //console.log("tag3: "+tag);
                                    if (tag.toUpperCase().indexOf(request.term.toUpperCase()) > 0) {
                                        //console.log("tag2: "+tag);
                                        return tag;
                                    }
                                });
                                console.log("res_starts: " + res_starts);
                                console.log("res_contains: " + res_contains);
                                var res = $.merge(res_starts, res_contains);
                                response(res);
                                console.log("res " + res);

                            },
                            create: function () {
                                $(this).data('ui-autocomplete')._renderItem = function (ul, item) {

                                    if ($.inArray(item.label, evidence) != -1) {

                                        //console.log("item "+item);
                                        console.log("ul " + ul);
                                        console.log("item.label " + item.label);
                                        return $('<li>').data('ui-autocomplete-item', item).append("<a class='evidence'>" + item.label + "</a>").appendTo(ul);
                                    } else {
                                        return $('<li>').data("ui-autocomplete-item", item).append("<a>" + item.label + "</a>").appendTo(ul);
                                    }
                                };
                            }
                        });
                    });

                });
            }
        },
        /* End: suggestion */


        /* Start: initFormCruscotto */
        initFormCruscotto: function () {
            try {
                tcom18.suggestion();
            } catch (e) {
            }
            tcom18._roundTripInternal == "false"
            //console.log("Sono nella initFormCruscotto");

            // reset numero passeggeri
            $("#biglietti_adulti").val("1");
            $("#biglietti_ragazzi").val("0");
            $("#biglietti_tot").val("1");

            $("#biglietti_ar").prop('checked', false);
            $("#checkMigliorPrezzo").prop('checked', false);
            $("#biglietti_ar_mobile").prop('checked', false);
            $("#checkMigliorPrezzoMobile").prop('checked', false);
            checkMigliorPrezzo();
            // let isToday = true;

            var thetime = new Date();
            nhours = thetime.getHours();

            // fabio 3 start
            // Arrotonda per eccesso i minuti in frazioni di 15 (campo Ora Partenza Arrivo)
            nMinutes = thetime.getMinutes();
            if ((nMinutes == 0)) nMinutes = '00';
            if ((nMinutes > 0) && (nMinutes < 16)) nMinutes = '15';
            if ((nMinutes > 15) && (nMinutes < 31)) nMinutes = '30';
            if ((nMinutes > 30) && (nMinutes < 46)) nMinutes = '45';
            if ((nMinutes > 45) && (nMinutes <= 59)) {
                nMinutes = '00';
                nhours = nhours + 1;
                console.log("nhours: " + nhours);
            }
            $("#biglietti_ora_p").val(nhours + ":" + nMinutes);
            $("#biglietti_ora_a").val(nhours + ":" + nMinutes);
            $("#biglietti_ora_p_but").val(nhours + ":" + nMinutes);
            $("#biglietti_ora_a_but").val(nhours + ":" + nMinutes);
            $("#biglietti_ora_p_but").prop('value', $("#biglietti_ora_p").val());
            $("#biglietti_ora_a_but").prop('value', $("#biglietti_ora_p").val());

            console.log("ORA: PARTENZA + Arrivo: " + $("#biglietti_ora_p").val() + " " + $("#biglietti_ora_a").val());
            console.log("ORA: PARTENZA + Arrivo:  " + $("#biglietti_ora_p_but").val() + " " + $("#biglietti_ora_a_but").val());
            // fabio 3 end

            var gg = thetime.getDate();
            var mm = thetime.getMonth()
            mm++;
            if (String(nhours).length == 1) nhours = '0' + nhours;
            if (String(gg).length == 1) gg = '0' + gg;
            if (String(mm).length == 1) mm = '0' + mm;

            // DataAttuale = gg+'-'+ mm +'-'+ thetime.getFullYear();
            AnnoAttuale = thetime.getFullYear();
            DataAttuale = gg + ' ' + _labels.it.monthNamesShort[thetime.getMonth()] + ' ' + AnnoAttuale;

            $("#annoP_SEL").val(AnnoAttuale);
            $("#annoA_SEL").val(AnnoAttuale);

            //$("#biglietti_ora_a").val(nhours); fabio 3
            $("#biglietti_data_pVISIBLE").val(DataAttuale);
            $("#biglietti_data_aVISIBLE").val(DataAttuale);

            $("#biglietti_data_p").val(DataAttuale);
            $("#biglietti_data_a").val(DataAttuale);
            // document.getElementById('label_ritorno').innerHTML = $("#biglietti_data_pVISIBLE").val();

            $("#biglietti_ora_a").attr("disabled", "disabled");
            // fabio 3 start
            $("#biglietti_ora_a_but").attr("disabled", "disabled");
            // fabio 3 end
            //if ($("[name=returnDate]").datepicker().val()!=null){
            //	$("#biglietti_ora_a").removeAttr("disabled");
            //}

            //console.log("DataAttuale: "+DataAttuale);
            //console.log("#biglietti_data_pVISIBLE: "+$("#biglietti_data_pVISIBLE").val());

            $("[name=isRoundTrip]").click(function () {
                tcom18._roundTripInternal = $("[name=isRoundTrip]:checked").val();
                if (tcom18._roundTripInternal == "true") {
                    $("[name=returnDate]").datepicker("enable");
                    //$("#biglietti_ora_aVISIBLE").removeAttr("disabled");
                    $("#biglietti_ora_a").removeAttr("disabled");
                    // fabio 3 start
                    $("#biglietti_ora_a_but").removeAttr("disabled");
                    // fabio 3 end
                    //console.log("initFormCruscotto - Ramoe then");
                    $("#biglietti_ar_circular").attr('aria-checked', 'true');
                } else {
                    $("[name=returnDate]").val("").datepicker("disable");
                    //$("#biglietti_ora_aVISIBLE").removeAttr("enable");
                    //$("#biglietti_ora_aVISIBLE").attr("disabled", "disabled");
                    $("#biglietti_ora_a").removeAttr("enable");
                    $("#biglietti_ora_a").attr("disabled", "disabled");
                    // fabio 3 start
                    $("#biglietti_ora_a_but").removeAttr("enable");
                    $("#biglietti_ora_a_but").attr("disabled", "disabled");
                    // fabio 3 end
                    $("#biglietti_data_aVISIBLE").val(DataAttuale);
                    $("#biglietti_data_a").val(DataAttuale);
                    //console.log("initFormCruscotto - Ramoe else");
                    $("#biglietti_ar_circular").attr('aria-checked', 'false');
                }
            });

            $(document).ready(function () {
                $("#andata-ritorno-mobile").click(function () {
                    if (tcom18._roundTripInternal == "true") {
                        console.log("tcom18._roundTripInternal - (ramo true): " + tcom18._roundTripInternal);
                        $("[name=returnDate]").datepicker("enable");
                        $("#biglietti_ora_a").removeAttr("disabled");
                        // fabio 3 start
                        $("#biglietti_ora_a_but").removeAttr("disabled");
                        // fabio 3 end
                    } else {
                        console.log("tcom18._roundTripInternal - (ramo false): " + tcom18._roundTripInternal);
                        $("[name=returnDate]").val("").datepicker("disable");
                        $("#biglietti_ora_a").removeAttr("enable");
                        $("#biglietti_ora_a").attr("disabled", "disabled");
                        // fabio 3 start
                        $("#biglietti_ora_a_but").removeAttr("enable");
                        $("#biglietti_ora_a_but").attr("disabled", "disabled");
                        // fabio 3 end
                        $("#biglietti_data_aVISIBLE").val(DataAttuale);
                        $("#biglietti_data_a").val(DataAttuale);
                    }
                });

                // $("#andata-ritorno").click(function(){
                // 	if (tcom18._roundTripInternal == "true") {
                // 		console.log("tcom18._roundTripInternal - (ramo true): "+tcom18._roundTripInternal);
                // 		$("[name=returnDate]").datepicker ("enable");
                // 		$("#biglietti_ora_a").removeAttr("disabled");
                // 		// fabio 3 start
                // 		$("#biglietti_ora_a_but").removeAttr("disabled");
                // 		// fabio 3 end
                // 	}else{
                // 		console.log("tcom18._roundTripInternal - (ramo false): "+tcom18._roundTripInternal);
                // 		$("[name=returnDate]").val("").datepicker ("disable");
                // 		$("#biglietti_ora_a").removeAttr("enable");
                // 		$("#biglietti_ora_a").attr("disabled", "disabled");
                // 		// fabio 3 start
                // 		$("#biglietti_ora_a_but").removeAttr("enable");
                // 		$("#biglietti_ora_a_but").attr("disabled", "disabled");
                // 		// fabio 3 end
                // 		$("#biglietti_data_aVISIBLE").val(DataAttuale);
                // 		$("#biglietti_data_a").val(DataAttuale);
                // 	}
                // });
            });

            // ultime stazioni ricercate impostate come default Da,A
            try {
                if (localStorage.getItem('from') && localStorage.getItem('to')) {
//                    $('#biglietti_fromNew').val(localStorage.getItem('from'));
//                    $('#biglietti_toNew').val(localStorage.getItem('to'));
                }
                localStorage.removeItem('from');
                localStorage.removeItem('to');
            } catch (e) {
            }
        },
        /* End: initFormCruscotto */


        /* Start: sendTrainSelectionsValues */
        sendTrainSelectionsValues: function (ebcitta_partenza, ebcitta_arrivo) {
            /* floodlight-stazioni su cruscotto */
            if (typeof formActivityID !== 'undefined') {
                var ebRand = Math.random() + '';
                ebRand = ebRand * 1000000;
                var tagSrcLnk = "HTTPS://bs.serving-sys.com/Serving/ActivityServer.bs?cn=as&amp;ActivityID=" + formActivityID + "&amp;rnd=" + ebRand + "&amp;citta_arrivo=" + ebcitta_arrivo + "&amp;citta_partenza=" + ebcitta_partenza;
                $("body").append("<script src='" + tagSrcLnk + "' type='text/javascript'> </script>");
            }
        },
        /* End: sendTrainSelectionsValues */


        /* Start: checkUrlForm */
        checkUrlForm: function (e) {
            if ($('input[name="url_mobile"]', e).length > 0 && $('input[name="url_desktop"]', e).length > 0) {
                //if($(window).width()<768){
                if ($(window).width() < 1024) {
                    $(e).attr('action', $('input[name="url_mobile"]', e).val());
                } else {
                    $(e).attr('action', $('input[name="url_desktop"]', e).val());
                }
            }
        },
        /* End: checkUrlForm */


        /* Start: checkForm */
        checkForm: function (e) {
            tcom18.checkUrlForm(e);

            var stat_from = $('#biglietti_fromNew');
            var stat_to = $('#biglietti_toNew');

            // Se campo vuoto
            if (stat_from.val() == '' && stat_to.val() == '') {
                alert(_labels.it.msg1);
                return false;
            } else if (stat_from.val() == '') {
                alert(_labels.it.msg2);
                return false;
            } else if (stat_to.val() == '') {
                alert(_labels.it.msg3);
                return false;
            }

            //Controllo se la data di partenza è inserita e se il formato è corretto
            var delim1 = '-';
            var delim2 = '-';
            var expr = new RegExp("^(\\d{2})[" + delim1 + "](\\d{2})[" + delim2 + "](\\d{4})$");

            //Controllo la data inserita e la trasformo in quella attesa dalle frecce gg-mm-aaaa
            var appo = $('#biglietti_data_pVISIBLE').val();
            //alert("Riga572 - biglietti_data_pVISIBLE: "+appo);
            //biglietti_data_pVISIBLE
            dataGMP = $('#biglietti_data_p').val();
            //alert("Riga575 - dataGMP: "+dataGMP);
            //dataGMP = $('#biglietti_data_pVISIBLE').val();
            //console.log("dataGMP: "+dataGMP);

            var checkData = expr.exec(dataGMP);
            //alert("checkData: "+checkData);

            if (checkData == null) {

                //alert("Sono null");

                //if(!expr.exec(dataGMP)) {

                var gg = dataGMP.substr(0, 2);

                var mese = dataGMP.substr(3, 3);

                //console.log(mese: "+ mese);

                var mm = ''

                for (var i = 0; i < _labels.it.monthNamesShort.length; i++) {
                    if (mese === _labels.it.monthNamesShort[i]) {
                        mm = (i + 1).toString();
                        break;
                    }
                }

                var yyyy = dataGMP.substr(7);

                if (yyyy == '') {
                    // var thetime=new Date();
                    yyyy = thetime.getFullYear();
                } else {
                    yyyy = dataGMP.substr(7);
                }

                if (String(gg).length == 1) gg = '0' + gg;
                if (String(mm).length == 1) mm = '0' + mm;

                biglietti_data_p = gg + '-' + mm + '-' + yyyy

            }

            //console.log("biglietti_data_p: "+biglietti_data_p);
            //alert("Riga 613 - biglietti_data_p: "+biglietti_data_p);

            if (biglietti_data_p == '') {
                alert(_labels.it.msg7);
                return false;
            } else {
                //console.log("expr.exec - biglietti_data_p: "+biglietti_data_p + " dataGMP: "+dataGMP);
                if (!expr.exec(biglietti_data_p)) {
                    alert(_labels.it.msg8);
                    return false;
                }
            }
            //}

            //Controllo che il campo data di ritorno sia compilato nel caso in cui ho fatto chek su andata e ritorno
            //Controllo la data inserita e la trasformo in quella attesa dalle frecce gg-mm-aaaa
            dataGMA = $('#biglietti_data_a').val();
            console.log("data ritorno=" + dataGMA);
            var checkData = expr.exec(dataGMA);

            if (checkData == null) {
                var ggA = dataGMA.substr(0, 2);
                var meseA = dataGMA.substr(3, 3);
                var mmA = ''
                for (var i = 0; i < _labels.it.monthNamesShort.length; i++) {
                    if (meseA === _labels.it.monthNamesShort[i]) {
                        mmA = (i + 1).toString();
                        break;
                    }
                }

                var yyyyA = dataGMA.substr(7);

                if (yyyyA == '') {
                    var thetime = new Date();
                    yyyyA = thetime.getFullYear();
                } else {
                    yyyyA = dataGMA.substr(7);
                }

                if (String(ggA).length == 1) ggA = '0' + ggA;
                if (String(mmA).length == 1) mmA = '0' + mmA;
                biglietti_data_a = ggA + '-' + mmA + '-' + yyyyA
            }

            if ($("[name=isRoundTrip]:checked").val() == "true") {
                if (biglietti_data_a == '') {
                    alert(_labels.it.msg9);
                    return false;
                } else {
                    if (!expr.exec(biglietti_data_a)) {
                        alert(_labels.it.msg10);
                        return false;
                    }
                }
            }
            if (tcom18._roundTripInternal == "true") {
                if (biglietti_data_a == '') {
                    alert(_labels.it.msg9);
                    return false;
                } else {
                    if (!expr.exec(biglietti_data_a)) {
                        alert(_labels.it.msg10);
                        return false;
                    }
                }
            }

            //Se andata e ritorno controllo che nello stesso giorno la data di ritorno sia maggiore di quella di partenza
            if ($("[name=isRoundTrip]:checked").val() == "true") {
                var partenza = $('#biglietti_data_p').val();
                var ritorno = $('#biglietti_data_a').val();
                var partenzaH = $('#biglietti_ora_p').val();
                var ritornoH = $('#biglietti_ora_a').val();

                if (partenza == ritorno && ritornoH - partenzaH <= 0) {
                    alert(_labels.it.msg18);
                    return false;
                }
            }
            if (tcom18._roundTripInternal == "true") {
                console.log("controllo data di ritorno sia maggiore di quella di partenza  - (ramo true): " + tcom18._roundTripInternal);
                var partenza = $('#biglietti_data_p').val();
                var ritorno = $('#biglietti_data_a').val();
                var partenzaH = $('#biglietti_ora_p').val();
                var ritornoH = $('#biglietti_ora_a').val();
                //alert("data partenza: "+partenza+" data arrivo: "+ritorno+" h partenza: "+partenzaH+" h arrivo: "+ritornoH);
                if (partenza == ritorno && ritornoH - partenzaH <= 0) {
                    alert(_labels.it.msg18);
                    return false;
                }
            }

            /*
            //controllo che data inserita per partenza non sia minore di data odierna (msg15)
            if($('#biglietti_data_p').length > 0){
                if($('#biglietti_data_p').val() != ''){
                    var datainserimento= $('#biglietti_data_p').val();
                    var dataritorno = $('#biglietti_data_a').val();
                    var oggi = new Date();
                    var giorno = oggi.getDate();
                    var mese = oggi.getMonth() + 1;
                    var anno = oggi.getFullYear();


                    //controllo formato del mese
                    if (mese < 10) {mese = "0" + mese;}
                    // controllo il formato del giorno
                    if (giorno < 10) {giorno = "0" + giorno;}

                    var datacompleta = anno.toString() +  mese.toString() + giorno.toString();

                    var giornoOggi = datainserimento.substring(0, 2);
                    var meseOggi = datainserimento.substring(3, 5);
                    var annoOggi = datainserimento.substring(6, 10);

                    var giornoRitorno = dataritorno.substring(0, 2);
                    var meseRitorno = dataritorno.substring(3, 5);
                    var annoRitorno = dataritorno.substring(6, 10);

                    var dataOdierna = annoOggi + meseOggi + giornoOggi ;
                    var dataRitorno = annoRitorno + meseRitorno + giornoRitorno;
                    var dataOdiernaES = giornoOggi +"/"+ meseOggi +"/"+  annoOggi;
                    var dataRitornoES = giornoRitorno +"/"+ meseRitorno +"/"+  annoRitorno;
                     //Controllo che la data sia corretta cioè il mese < 12 e il giorno giusto
                     var espressione = /^[0-9]{2}\/[0-9]{2}\/[0-9]{4}$/;

                      if (!espressione.test(dataOdiernaES))  {
                            alert(tcom18._label.msg13);
                            return false;
                      } else {

                        anno = parseInt(dataOdiernaES.substr(6),10);
                        mese = parseInt(dataOdiernaES.substr(3, 2),10);
                        giorno = parseInt(dataOdiernaES.substr(0, 2),10);
                        var data=new Date(anno, mese-1, giorno);

                        if (data.getFullYear()==anno &&
                              data.getMonth()+1==mese &&
                              data.getDate()==giorno){

                        } else {
                            alert(tcom18._label.msg13);
                            return false;
                        }
                      }

                    if ( $("[name=isRoundTrip]:checked").val () == "true" ){
                         if (!espressione.test(dataRitornoES))  {
                            alert(tcom18._label.msg13);
                            return false;
                         }else{
                            anno = parseInt(dataRitornoES.substr(6),10);
                            mese = parseInt(dataRitornoES.substr(3, 2),10);
                            giorno = parseInt(dataRitornoES.substr(0, 2),10);
                            var data=new Date(anno, mese-1, giorno);

                            if (data.getFullYear()==anno &&
                                  data.getMonth()+1==mese &&
                                  data.getDate()==giorno){

                            } else {
                                alert(tcom18._label.msg13);
                                return false;
                            }
                         }
                    }

                    if (tcom18._roundTripInternal == "true") {
                        console.log("tcom18._roundTripInternal - (ramo true): "+tcom18._roundTripInternal);
                        if (!espressione.test(dataRitornoES))  {
                            alert(tcom18._label.msg13);
                            return false;
                        }else{
                            anno = parseInt(dataRitornoES.substr(6),10);
                            mese = parseInt(dataRitornoES.substr(3, 2),10);
                            giorno = parseInt(dataRitornoES.substr(0, 2),10);
                            var data=new Date(anno, mese-1, giorno);
                            if (data.getFullYear()==anno &&
                                  data.getMonth()+1==mese &&
                                  data.getDate()==giorno){

                            } else {
                                alert(tcom18._label.msg13);
                                return false;
                            }
                        }
                    }


                    if (dataOdierna-datacompleta<0) {
                        alert(tcom18._label.msg13);
                        return false;
                    }
                    if ( $("[name=isRoundTrip]:checked").val () == "true" ){
                         if (dataRitorno-dataOdierna<0) {
                                alert(tcom18._label.msg15);
                                return false;
                        }
                    }

                    if (tcom18._roundTripInternal == "true") {
                        console.log("tcom18._roundTripInternal - (ramo true): "+tcom18._roundTripInternal);
                         if (dataRitorno-dataOdierna<0) {
                                alert(tcom18._label.msg15);
                                return false;
                        }
                    }

                }
            }*/

            //Controllo sui passeggeri
            var numAdulti = Number($('[name=noOfAdults]').val());
            var numRag = Number($('[name=noOfChildren]').val());
            var totNum = numAdulti + numRag;

            if (totNum > 7) {
                alert(_labels.it.msg6);
                return false;
            } else if (totNum == 0) {
                alert(_labels.it.msg12);
                return false;
            }
            /* eseguo replace input */
            newFrom = tcom18.replaceText(stat_from);
            newTo = tcom18.replaceText(stat_to);

            /* seleziono dove cercare le citta'  */
            if ($('input[name=selectedTrainType]').val() == "frecce") {
                listTrain = tcom18.frecce;
            } else {
                listTrain = tcom18.allTrain;
            }

            /* converto l'array in UPPERCASE */
            listTrain = $.map(listTrain, function (item, index) {
                //  return item.toUpperCase();
                /*Ho tolto la funzione di UPPERCASE* 06/03/2015/*/
                return item;
            });

            if ($.inArray(newFrom, listTrain) == -1 && $.inArray(newFrom, _cfg.frAllStaz) == -1) {
                //XXX fix 12-02-2015 msg specifico in base al flag frecce o tutti i treni
                if ($('input[name=selectedTrainType]').val() == "frecce") {
                    alert(_labels.it.msg16);
                } else {
                    alert(_labels.it.msg19);
                }
                return false;
            } else {
                stat_from.val(newFrom)
            }

            if ($.inArray(newTo, listTrain) == -1 && $.inArray(newTo, _cfg.frAllStaz) == -1) {
                //XXX fix 12-02-2015 msg specifico in base al flag frecce o tutti i treni
                if ($('input[name=selectedTrainType]').val() == "frecce") {
                    alert(_labels.it.msg17);
                } else {
                    alert(_labels.it.msg20);
                }
                return false;
            } else {
                stat_to.val(newTo);
            }

            //Controllo i campi cartaFreccia
            var actioForm = document.forms['formcruscotto'].action;
            var numeroCartaFreccia = "cartafreccia=" + $('#cartafreccia').val();
            var acrtionFormCARTA = actioForm + "&" + numeroCartaFreccia

            if ($('#NCartafreccia').val() == 'on') {
                if ($('#cartafreccia').val() == '') {
                    alert("Devi inserire il codice cartafreccia");
                    return false;
                } else if (!Number($('#cartafreccia').val())) {
                    alert("Il codice cartafreccia deve essere numerico");
                    return false;
                } else {
                    $("#formcruscotto").attr("action", acrtionFormCARTA);
                    return true;
                }
            }

            try {
                localStorage.setItem('from', $('#biglietti_fromNew').val());
                localStorage.setItem('to', $('#biglietti_toNew').val());
            } catch (e) {
            }

            try {
                tcom18.sendTrainSelectionsValues($('#biglietti_fromNew').val(), $('#biglietti_toNew').val());
                setSCVarsForm('biglietti');
            } catch (e) {
            }

            //alert("2 - biglietti_data_p: "+biglietti_data_p);

            $('#biglietti_data_p').val(biglietti_data_p);
            $('#biglietti_data_a').val(biglietti_data_a);

            return true;
        },
        /* End: checkForm */


        /* fix spallaDx su Footer */
        fixElemLeftOuterHeight: function () {
            var eLeftH = $(".elemLeft").outerHeight();
            var eRightH = $(".elemRight").outerHeight();
            if ((eLeftH != null) && (eRightH != null)) {
                if (eLeftH <= eRightH) {
                    $(".wrapBody").css("min-height", eRightH + 50);
                    // $(".elemLeft").css("height", eRightH+50);
                }
            }
        },


        /* Start: replaceText */
        replaceText: function (e) {
            var n = $(e).val();
            if ($.inArray(n, _cfg.notReplaceSAN) == -1) {
                if (n.split("", 4) == 'S,a,n, ') {
                    n = n.replace("San ", "S. ");
                }
                /* Controllo che dopo s. non ci si a gia' lo spazio*/
                if (n.split("", 3) != 'S,., ') {
                    if (n.split("", 2) == 'S,.') {
                        n = n.replace("S.", "S. ");
                    }
                    if (n.split("", 2) == 's,.') {
                        n = n.replace("S.", "S. ");
                    }
                }
            }
//            if ($.inArray(n, _cfg.notReplaceSAN) >= 0) {
//                if (n.split("", 4) == 'S,a,n, ') {
//                    n = n.replace("San ", "S.");
//                }
//                if (n.split("", 3) == 'S,., ') {
//                    n = n.replace("S. ", "S.");
//                }
//                if (n.split("", 3) == 's,., ') {
//                    n = n.replace("S. ", "S.");
//                }
//
//            }
            $.each(_cfg.repName, function (i, e) {
                if (i == n) {
                    n = e;
                }
            });
            return n;
        },
        /* End: replaceText */


        /* Start: addSmartBannerMobile */
        addSmartBannerMobile: function () {
            if ($('#smartBannerEnabled').length) {

                var isIOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream);
                var isAndroid = location.href.match(/#android$/) || navigator.userAgent.match(/Android/i) != null;
                if (isAndroid || isIOS) {
                    $.smartbanner({
                        androidAppId: 'com.lynxspa.prontotreno',
                        appleAppId: '331050847',
                        icon: '/etc.clientlibs/tcom/clientlibs/common/resources/sites/it/js/common/libs/smartbanner/TrenitaliaAppLogo.png',
                        force: isAndroid ? 'android' : 'ios',
                        title: _sb_labels.title,
                        author: _sb_labels.author_msg,
                        button: _sb_labels.button, /* 'Vai' */
                        price: _sb_labels.price, /* 'OTTIENI' */
                        inGooglePlay: _sb_labels.inGooglePlay,  /* 'Su Google Play' */
                        inAppStore: _sb_labels.inAppStore, /* 'Su App Store' */
                        daysHidden: 90,
                        daysReminder: 90
                    });
                    $('head').append('<style> .handler-menu { top: auto; } </style>'); /* fix hamburgher button */
                }
            }
        },
        /* End: addSmartBannerMobile */


        /* Start: fixDatePickerSmartPhone */
        /*
        fixWidgetsSmartPhone : function(){
            var isTouchDev=(('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
            /* solo x test su dispositivi NON touch */ /*isTouchDev=true; /* poi commentare! */
        /*
        if(isTouchDev && ($(window).width()<tcom18.mSize)){
            $.getScript(_cfg.fixWidgetsURL);
        }
    },
    */
        /* End: fixDatePickerSmartPhone */

        initAccordion: function () {
            $('ul#accordionGeneric a.heading').click(function (e) {
                e.preventDefault();
                $(this).next('div.boxAcc').slideToggle(700).promise().done(function () {
                    if ($(this).is(':visible')) {
                        $(this).parent().addClass('current');
                    } else {
                        $(this).parent().removeClass('current');
                    }
                });
            });

            // solo se presente lista segnalibri interni alla pagina...
            if ($('ul.listaIndice').length > 0 || $('.boxAcc').length > 0) {
                window.addEventListener('hashchange', function () {
                    tcom18.goToHashLocationInPage();
                });
                tcom18.goToHashLocationInPage();
            }

            $("<div class='cl'></div>").insertBefore("#accordionGeneric")
            $("#accordionGeneric div.boxAcc").append("<div class='cl'></div>");
            //$("div.boxAcc").append("<div class='cl'></div>");
        },

        goToHashLocationInPage: function () {
            setTimeout(function () {
                if (location.hash.length > 1) {
                    _elemToScroll = $('ul#accordionGeneric div.boxAcc:eq(' + (parseInt(location.hash.substring(1, location.hash.length)) - 1) + ')');
                    if (_elemToScroll.is(':hidden')) {
                        $('ul#accordionGeneric a.heading:eq(' + (parseInt(location.hash.substring(1, location.hash.length)) - 1) + ')').click().promise().done(function () {
                            $('html, body').animate({
                                scrollTop: parseInt($(this).offset().top - 20)
                            }, 500);
                        });
                    } else {
                        $('html, body').animate({
                            scrollTop: parseInt(_elemToScroll.offset().top)
                        }, 500);
                    }

                }
            }, 500);
        },

        fixBoxSocialPos: function () {
            /* fix boxSocial */
            $(document).ready(function () {
                $('.boxSocial.no-mobile').prependTo($('.boxSocial.no-mobile').parent()).promise().done(function () {
                    if ($('.boxSocial.no-mobile').parent().find('.boxSocial.no-mobile').length > 1) {
                        $('.boxSocial.no-mobile').parent().find('.boxSocial.no-mobile:last').remove();
                    }
                });
            });
        },

        fixBoxColHeight: function (boxColSelector) {
            try {
                var isNwChrome = $.browser.chrome && (parseInt($.browser.version) >= 52);
                if (isNwChrome) {
                    $(boxColSelector).each(function () {
                        var curBoxMaxH = 0;
                        $(this).find('div.box').each(function (i, curVal1) {
                            var curBoxH = $(curVal1).height();
                            if (curBoxH > curBoxMaxH) {
                                curBoxMaxH = curBoxH;
                            }
                        });
                        $(this).find('div.box').each(function (j, curVal2) {
                            if (j != 1) {
                                $(curVal2).css('display', 'inline-block');
                            } else {
                                $(curVal2).css('display', 'block');
                            }
                            $(curVal2).css('height', curBoxMaxH + 'px');
                        });
                    });
                }
            } catch (e) {
            } finally {
            }
        },

        /* Start: emotional [carousel] */
        emotional: {
            timer: 7000,
            effect: 'slide', /* slide|fade */
            interval: function () {
                myint = setInterval(function () {
                    tcom18.emotional.next();
                }, this.timer);
            },
            nItem: $('.emotional:eq(0) ul.slider li').length,
            init: function () {
                //alert("init emotional!");
                try { /* NO slider su Chrome vers. 44(solo Android) */
                    if (/android/i.test((navigator.userAgent || navigator.vendor || window.opera))) {
                        var chkUaVers = (navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./));
                        if (chkUaVers && (parseInt(chkUaVers[2], 10) == 44)) {
                            $("ul.slider, .emotional .mobPager, .emotional .pager").css('display', 'none');
                            $('head').append('<style>' + '@media screen and (max-width: 701px){ div.emotional div.cruscotto{ top: -5px !important; } }' + '</style>');
                            $('head').append('<style>' + '@media screen and (max-width: 701px){ div.emotional, div.emotional.right, div.emotional.left { height: 480px !important; } }' + '</style>');
                            $(".emotional").css('background-color', '#f8f8f8');
                            return;
                        }
                    }
                } catch (er) {
                }

                $('head').append('<style> ul.slider.fade{ opacity: 1; } </style>');

                // NASCONDE SELETTIVAMNETE ALCUNE SLIDE mod. 11-Ott-2016
                $('.emotional:eq(0) ul.slider li').each(function (i, e) {
                    if ($(e).is(':visible') == false) {
                        $(e).remove();
                    }
                });
                //console.log("=> nItem=["+tcom18.emotional.nItem+"] ");
                $('ul.slider').hide();
                /* setto larghezza UL */
                /* configura effetto transizione slide indicato da cms XXX */

                if ((typeof (emotionalHpTcomTransitionEffect) !== 'undefined') && (emotionalHpTcomTransitionEffect.length > 0)) {
                    tcom18.emotional.effect = emotionalHpTcomTransitionEffect;
                }
                if (tcom18.emotional.effect == 'fade') {
                    $('ul.slider').addClass('fade');
                    $('ul.slider').children('li').css({'opacity': 0, 'z-index': 1});
                    $('ul.slider').children('li:eq(0)').css({'opacity': 1, 'z-index': 2});
                }
                $('ul.slider').fadeIn(1000);

                this.resize();
                $('<div class="pager"><ul class="nav"></ul></div>').insertAfter('ul.slider');

                nWli = Math.floor(Number(100 / Number(tcom18.emotional.nItem)) * 1000) / 1000;

                /* imposto background immagini */
                $('li', '.emotional:eq(0) > .slider').each(function (i, e) {
                    $(e).width(nWli + '%');
                    /* nuovo SRC dell'immagine */
                    $('img', e)
                        .attr({
                            "data-mobile": $('img', e).attr('src'),
                            "src": _cfg.blank
                        });
                    var mySRC = ($(window).width() < tcom18.mSize) ? $('img', e).attr('data-mobile') : $('img', e).attr('usemap');

                    $('a', e).wrap('<div class="wrap-link"><div class="cont"></div></div>');
                    if (tcom18.emotional.effect == 'fade') {
                        if (!Modernizr.cssanimations) {
                            if (i == 0) {
                                $(e).find('.wrap-link:eq(0)').fadeIn();
                            } else {
                                $(e).find('.wrap-link:eq(0)').fadeOut();
                            }
                        }
                    }
                    $('img', e).fadeOut(0, function () {
                        /* nuovo background dell'immagine */
                        $('img', e).css('background-image', 'url(' + mySRC + ')').fadeIn(1000);
                    });


                    newLi = $('<li></li>').css('width', nWli + '%');
                    if (i == 0) {
                        newLi.addClass('active')
                    }
                    newLink = $('<a href="#promo_' + i + '">' + $('img', e).attr('alt') + '</a>')
                        .bind('click', function (ev) {
                            ev.preventDefault();
                            nPer = i * 100;

                            if (tcom18.emotional.effect == 'slide') {
                                /* * Check CSS3 transition support * */
                                if (!Modernizr.cssanimations) {
                                    $('ul.slider', '.emotional:eq(0)').animate({'left': '-' + nPer + '%'}, 500, 'cool');
                                } else {
                                    nWli = Math.floor(Number(100 / Number(tcom18.emotional.nItem)) * 1000) / 1000;
                                    newPos = i * nWli;
                                    $('ul.slider', '.emotional:eq(0)').css("transform", "translateX(-" + newPos + "%)");
                                }
                            }

                            if (tcom18.emotional.effect == 'fade') {
                                /* * Check CSS3 transition support * */
                                if (!Modernizr.cssanimations) {
                                    $('ul.slider', '.emotional:eq(0)').find('li').each(function (j, f) {
                                        if (j == i) {
                                            $(f).animate({'opacity': 1, 'z-index': 2});
                                            $(f).find('.wrap-link:eq(0)').fadeIn();
                                        } else {
                                            $(f).animate({'opacity': 0, 'z-index': 1});
                                            $(f).find('.wrap-link:eq(0)').fadeOut();
                                        }
                                    });
                                } else {
                                    $('ul.slider', '.emotional:eq(0)').find('li').each(function (j, f) {
                                        if (j == i) {
                                            $(f).css({'opacity': 1, 'z-index': 2});
                                        } else {
                                            $(f).css({'opacity': 0, 'z-index': 1});
                                        }
                                    });
                                }
                            }

                            $('.pager li').removeClass('active');
                            $(this).parent('li').addClass('active');
                        });
                    newLi.append(newLink);
                    $('.emotional:eq(0)').find('.pager:eq(0) > ul.nav').append(newLi);
                });
                this.resize();

                // SLIDER ATTIVO ANCHE SU MOBILE, mod. 11-Ott-2016
                //if($(window).width()>tcom18.mSize){
                $('ul.slider', '.emotional:eq(0)').hover(function () {
                    if (myint) clearInterval(myint);
                }, function () {
                    tcom18.emotional.interval();
                }); /* fix marzia Nov-2016 */

                $('ul.nav:eq(0)', '.pager:eq(0)').hover(function () {
                    if (myint) clearInterval(myint);
                }, function () {
                    tcom18.emotional.interval();
                });
                tcom18.emotional.interval();
                //}
                /* mod pager mobile Nov-2016 */
                if ($(window).width() <= tcom18.mSize) {
                    $(".slider.fade").after("<div class='mobPager'><div class='prev'></div><div class='next'></div></div>");
                    $(".pager").css("background-color", "#f8f8f8");
                    $(".pager ul.nav").css("visibility", "hidden");
                    $(".mobPager > .prev").bind("click", function () {
                        tcom18.emotional.prev();
                    });
                    $(".mobPager > .next").bind("click", function () {
                        tcom18.emotional.next();
                    });
                }
            },

            setImages: function () {
                $('img', '.emotional:eq(0) > .slider').each(function (i, e) {
                    var mySRC = ($(window).width() <= tcom18.mSize) ? $(e).attr('data-mobile') : $(e).attr('usemap');
                    $(e).css('background-image', 'url(' + mySRC + ')');
                });
            },

            next: function () {
                var nextLI = $('.pager:eq(0)').find('li.active:eq(0)').next('li');
                if (nextLI.length != 0) {
                    nextLI.children('a').click();
                } else {
                    $('.pager:eq(0)').find('li:eq(0)').children('a').click();
                }
            },

            prev: function () {
                var prevLI = $('.pager:eq(0)').find('li.active:eq(0)').prev('li')
                if (prevLI.length != 0) {
                    prevLI.children('a').click();
                } else {
                    $('.pager:eq(0) li:last-child').children('a').click(); //riparte da ultima slide
                }
            },

            resize: function () {
                wTot = 0;
                for (var i = 0; i < tcom18.emotional.nItem; i++) {
                    wTot += $('.emotional:eq(0)').width();
                }
                $('.emotional:eq(0) ul:eq(0)').width(wTot);
                if (!$('html').hasClass('no-mq')) {
                    /* non faccio reload img se non supporto MQ */
                    tcom18.emotional.setImages();
                }
            }
        },
        /* End: emotional [carousel] */


        /* Start: addPlaceHolder */
        addPlaceHolder: function () {
            var active = document.activeElement;
            $('input[type=text], input[type=search]').focus(function () {
                if ($(this).attr('title') != '' && $(this).val() == $(this).attr('title')) {
                    $(this).val('').removeClass('hasPlaceholder');
                }
            }).blur(function () {
                if ($(this).attr('title') != '' && ($(this).val() == '' || $(this).val() == $(this).attr('title'))) {
                    $(this).val($(this).attr('title')).addClass('hasPlaceholder');
                }
            });

            $(':password').focus(function () {
                if ($(this).attr('title') != '' && $(this).val() == $(this).attr('title')) {
                    $(this).val('').removeClass('hasPlaceholder');
                }
            }).blur(function () {
                if ($(this).attr('title') != '' && ($(this).val() == '' || $(this).val() == $(this).attr('title'))) {
                    $(this).val($(this).attr('title')).addClass('hasPlaceholder');
                }
            });

            $('input[type=text], input[type=search]').blur();
            $(':password').blur();
            $(active).focus();
            $('form:eq(0)').submit(function () {
                $('input.hasPlaceholder[type=text] , input.hasPlaceholder[type=search]').val('');
            });
        },
        /* End: addPlaceHolder */


        /* Start: fixInputTypeSearchFields */
        fixInputTypeSearchFields: function () {
            $('head').append('<style> input[type="search"]::-webkit-search-cancel-button{ -webkit-appearance: searchfield-cancel-button; } </style>');
            $("#biglietti_fromNew, #biglietti_toNew").prop("type", "search");
        },
        /* End: fixInputTypeSearchFields */

        /* Start: fixMouseOverMenuTablet */

        fixMouseOverMenuTablet: function () {
            try {
                var isTouchDev = (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
                if (isTouchDev && ($(window).width() > 700)) {
                    $('head').append('<style> #menu > ul ul.second-lvl { background: url() no-repeat #C41228; } </style>');
                    $('head').append('<style> #menu ul:hover ul { display: none; } </style>');
                    $('head').append('<style> #menu > ul ul.second-lvl { display: none; } </style>');

                    //$('head').append('<style> #menu ul.menuItemTablet{ color: #fff; background: url(etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/arrow-down-white.png) no-repeat; background-position: 88% 15px; padding-left:3px; border-right: none;} </style>');
                    $('head').append('<style> #menu ul.menuItemTablet > a{ color:#fff } </style>');
                    $('head').append('<style> .menu a.hoverMenuItem{ color:#fff;} </style>');

                    //$('head').append('<style> #menu ul.menuItemTablet.MoClickedTablet{ color: #3D3D3D; background: url(/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/arrow-down-grey.png) no-repeat #F5F5F5; background-position: 88% 15px; padding-right:1px; border-right: 1px solid #d6d6d6;} </style>');
                    //$('head').append('<style> #menu ul.menuItemTablet.MoClickedTablet > li > a{ color:#3D3D3D } </style>');

                    //$("#menu > ul > li").removeClass("rientroMenu");
                    $("#menu > ul").addClass("menuItemTablet");
                    $("#menu > ul > li").unbind("hover");

                    $("#menu > ul > li > a").click(function (event) {
                        event.preventDefault();
                        //alert("isVisible="+$(this).next("ul.second-lvl").is(":visible"));
                        $("#menu > ul.menuItemTablet").removeClass("MoClickedTablet");
                        if ($(this).next("ul.second-lvl").is(":visible")) {
                            $("#menu > ul ul.second-lvl").hide();
                        } else {
                            $("#menu > ul ul.second-lvl").hide();
                            $(this).next("ul.second-lvl").show();
                            //$(this).parent().parent().addClass("MoClickedTablet");
                        }
                        return false;
                    });

                    $("#menu > ul ul.second-lvl").each(function () {
                        //alert("==>" + $(this).parent().find("a.menuItemTablet").attr("href") + " --- " + $(this).parent().find("a.menuItemTablet").text());
                        var mouseOverControlSrc = "<div style='width: 100%;'>" +
                            "<a href='" + $(this).parent().find("a.menuItem").attr("href") + "' style='color: #ffffff; text-decoration: underline; margin-left: 10px; float: left; font-weight:bold; width: 95%; '>" + $(this).parent().find("a.menuItem").text() + "</a>" +
                            "<a href='#' onclick='$(\"#menu > ul ul.second-lvl\").hide(); $(\"#menu > ul.menuItemTablet\").removeClass(\"MoClickedTablet\"); return false' style='color: #ffffff; font-weight:bold; text-decoration: none;position:relative;left:20px;'> X </a>" +
                            "</div>";
                        $(this).prepend(mouseOverControlSrc);
                    });

                    //$(document).mouseup(function(e){
                    $(document).bind('touchstart mouseup', function (e) {
                        if (!$(e.target).is("#menu *")) {
                            $("#menu > ul ul.second-lvl").hide();
                            $("#menu > ul.menuItemTablet").removeClass("MoClickedTablet");
                        }
                    });

                }
            } catch (e) {
            }
        },

        /* End: fixMouseOverMenuTablet */

        /* Start: resize */
        resize: function () {
            // toDO
        },
        /* End: resize */

    };
    /* End: tcom18 */

    function formatTo15Min(date) {
        let min = Math.trunc(date.getMinutes() / 60) * 60;
        date.setMinutes(min);
        date.setSeconds(0);
        return date;
    }

    function formatTo2Char(value) {
        if (value > -1) {
            switch (String(value).length) {
                case 1:
                    return '0' + value;
                default:
                    return value;
            }
        }
    }
    //console.log("tcom18: "+tcom18);
    tcom18.init();
/**
 * Owl Carousel v2.2.1
 * Copyright 2013-2017 David Deutsch
 * Licensed under  ()
 */
/**
 * Owl carousel
 * @version 2.1.6
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;(function($, window, document, undefined) {

	/**
	 * Creates a carousel.
	 * @class The Owl Carousel.
	 * @public
	 * @param {HTMLElement|jQuery} element - The element to create the carousel for.
	 * @param {Object} [options] - The options
	 */
	function Owl(element, options) {

		/**
		 * Current settings for the carousel.
		 * @public
		 */
		this.settings = null;

		/**
		 * Current options set by the caller including defaults.
		 * @public
		 */
		this.options = $.extend({}, Owl.Defaults, options);

		/**
		 * Plugin element.
		 * @public
		 */
		this.$element = $(element);

		/**
		 * Proxied event handlers.
		 * @protected
		 */
		this._handlers = {};

		/**
		 * References to the running plugins of this carousel.
		 * @protected
		 */
		this._plugins = {};

		/**
		 * Currently suppressed events to prevent them from beeing retriggered.
		 * @protected
		 */
		this._supress = {};

		/**
		 * Absolute current position.
		 * @protected
		 */
		this._current = null;

		/**
		 * Animation speed in milliseconds.
		 * @protected
		 */
		this._speed = null;

		/**
		 * Coordinates of all items in pixel.
		 * @todo The name of this member is missleading.
		 * @protected
		 */
		this._coordinates = [];

		/**
		 * Current breakpoint.
		 * @todo Real media queries would be nice.
		 * @protected
		 */
		this._breakpoint = null;

		/**
		 * Current width of the plugin element.
		 */
		this._width = null;

		/**
		 * All real items.
		 * @protected
		 */
		this._items = [];

		/**
		 * All cloned items.
		 * @protected
		 */
		this._clones = [];

		/**
		 * Merge values of all items.
		 * @todo Maybe this could be part of a plugin.
		 * @protected
		 */
		this._mergers = [];

		/**
		 * Widths of all items.
		 */
		this._widths = [];

		/**
		 * Invalidated parts within the update process.
		 * @protected
		 */
		this._invalidated = {};

		/**
		 * Ordered list of workers for the update process.
		 * @protected
		 */
		this._pipe = [];

		/**
		 * Current state information for the drag operation.
		 * @todo #261
		 * @protected
		 */
		this._drag = {
			time: null,
			target: null,
			pointer: null,
			stage: {
				start: null,
				current: null
			},
			direction: null
		};

		/**
		 * Current state information and their tags.
		 * @type {Object}
		 * @protected
		 */
		this._states = {
			current: {},
			tags: {
				'initializing': [ 'busy' ],
				'animating': [ 'busy' ],
				'dragging': [ 'interacting' ]
			}
		};

		$.each([ 'onResize', 'onThrottledResize' ], $.proxy(function(i, handler) {
			this._handlers[handler] = $.proxy(this[handler], this);
		}, this));

		$.each(Owl.Plugins, $.proxy(function(key, plugin) {
			this._plugins[key.charAt(0).toLowerCase() + key.slice(1)]
				= new plugin(this);
		}, this));

		$.each(Owl.Workers, $.proxy(function(priority, worker) {
			this._pipe.push({
				'filter': worker.filter,
				'run': $.proxy(worker.run, this)
			});
		}, this));

		this.setup();
		this.initialize();
	}

	/**
	 * Default options for the carousel.
	 * @public
	 */
	Owl.Defaults = {
		items: 3,
		loop: false,
		center: false,
		rewind: false,

		mouseDrag: true,
		touchDrag: true,
		pullDrag: true,
		freeDrag: false,

		margin: 0,
		stagePadding: 0,

		merge: false,
		mergeFit: true,
		autoWidth: false,

		startPosition: 0,
		rtl: false,

		smartSpeed: 250,
		fluidSpeed: false,
		dragEndSpeed: false,

		responsive: {},
		responsiveRefreshRate: 200,
		responsiveBaseElement: window,

		fallbackEasing: 'swing',

		info: false,

		nestedItemSelector: false,
		itemElement: 'div',
		stageElement: 'div',

		refreshClass: 'owl-refresh',
		loadedClass: 'owl-loaded',
		loadingClass: 'owl-loading',
		rtlClass: 'owl-rtl',
		responsiveClass: 'owl-responsive',
		dragClass: 'owl-drag',
		itemClass: 'owl-item',
		stageClass: 'owl-stage',
		stageOuterClass: 'owl-stage-outer',
		grabClass: 'owl-grab'
	};

	/**
	 * Enumeration for width.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
	Owl.Width = {
		Default: 'default',
		Inner: 'inner',
		Outer: 'outer'
	};

	/**
	 * Enumeration for types.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
	Owl.Type = {
		Event: 'event',
		State: 'state'
	};

	/**
	 * Contains all registered plugins.
	 * @public
	 */
	Owl.Plugins = {};

	/**
	 * List of workers involved in the update process.
	 */
	Owl.Workers = [ {
		filter: [ 'width', 'settings' ],
		run: function() {
			this._width = this.$element.width();
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			cache.current = this._items && this._items[this.relative(this._current)];
		}
	}, {
		filter: [ 'items', 'settings' ],
		run: function() {
			this.$stage.children('.cloned').remove();
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var margin = this.settings.margin || '',
				grid = !this.settings.autoWidth,
				rtl = this.settings.rtl,
				css = {
					'width': 'auto',
					'margin-left': rtl ? margin : '',
					'margin-right': rtl ? '' : margin
				};

			!grid && this.$stage.children().css(css);

			cache.css = css;
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,
				merge = null,
				iterator = this._items.length,
				grid = !this.settings.autoWidth,
				widths = [];

			cache.items = {
				merge: false,
				width: width
			};

			while (iterator--) {
				merge = this._mergers[iterator];
				merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

				cache.items.merge = merge > 1 || cache.items.merge;

				widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
			}

			this._widths = widths;
		}
	}, {
		filter: [ 'items', 'settings' ],
		run: function() {
			var clones = [],
				items = this._items,
				settings = this.settings,
				// TODO: Should be computed from number of min width items in stage
				view = Math.max(settings.items * 2, 4),
				size = Math.ceil(items.length / 2) * 2,
				repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,
				append = '',
				prepend = '';

			repeat /= 2;

			while (repeat--) {
				// Switch to only using appended clones
				clones.push(this.normalize(clones.length / 2, true));
				append = append + items[clones[clones.length - 1]][0].outerHTML;
				clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
				prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
			}

			this._clones = clones;

			$(append).addClass('cloned').appendTo(this.$stage);
			$(prepend).addClass('cloned').prependTo(this.$stage);
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function() {
			var rtl = this.settings.rtl ? 1 : -1,
				size = this._clones.length + this._items.length,
				iterator = -1,
				previous = 0,
				current = 0,
				coordinates = [];

			while (++iterator < size) {
				previous = coordinates[iterator - 1] || 0;
				current = this._widths[this.relative(iterator)] + this.settings.margin;
				coordinates.push(previous + current * rtl);
			}

			this._coordinates = coordinates;
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function() {
			var padding = this.settings.stagePadding,
				coordinates = this._coordinates,
				css = {
					'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
					'padding-left': padding || '',
					'padding-right': padding || ''
				};

			this.$stage.css(css);
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			var iterator = this._coordinates.length,
				grid = !this.settings.autoWidth,
				items = this.$stage.children();

			if (grid && cache.items.merge) {
				while (iterator--) {
					cache.css.width = this._widths[this.relative(iterator)];
					items.eq(iterator).css(cache.css);
				}
			} else if (grid) {
				cache.css.width = cache.items.width;
				items.css(cache.css);
			}
		}
	}, {
		filter: [ 'items' ],
		run: function() {
			this._coordinates.length < 1 && this.$stage.removeAttr('style');
		}
	}, {
		filter: [ 'width', 'items', 'settings' ],
		run: function(cache) {
			cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
			cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
			this.reset(cache.current);
		}
	}, {
		filter: [ 'position' ],
		run: function() {
			this.animate(this.coordinates(this._current));
		}
	}, {
		filter: [ 'width', 'position', 'items', 'settings' ],
		run: function() {
			var rtl = this.settings.rtl ? 1 : -1,
				padding = this.settings.stagePadding * 2,
				begin = this.coordinates(this.current()) + padding,
				end = begin + this.width() * rtl,
				inner, outer, matches = [], i, n;

			for (i = 0, n = this._coordinates.length; i < n; i++) {
				inner = this._coordinates[i - 1] || 0;
				outer = Math.abs(this._coordinates[i]) + padding * rtl;

				if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end)))
					|| (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
					matches.push(i);
				}
			}

			this.$stage.children('.active').removeClass('active');
			this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

			if (this.settings.center) {
				this.$stage.children('.center').removeClass('center');
				this.$stage.children().eq(this.current()).addClass('center');
			}
		}
	} ];

	/**
	 * Initializes the carousel.
	 * @protected
	 */
	Owl.prototype.initialize = function() {
		this.enter('initializing');
		this.trigger('initialize');

		this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

		if (this.settings.autoWidth && !this.is('pre-loading')) {
			var imgs, nestedSelector, width;
			imgs = this.$element.find('img');
			nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
			width = this.$element.children(nestedSelector).width();

			if (imgs.length && width <= 0) {
				this.preloadAutoWidthImages(imgs);
			}
		}

		this.$element.addClass(this.options.loadingClass);

		// create stage
		this.$stage = $('<' + this.settings.stageElement + ' class="' + this.settings.stageClass + '"/>')
			.wrap('<div class="' + this.settings.stageOuterClass + '"/>');

		// append stage
		this.$element.append(this.$stage.parent());

		// append content
		this.replace(this.$element.children().not(this.$stage.parent()));

		// check visibility
		if (this.$element.is(':visible')) {
			// update view
			this.refresh();
		} else {
			// invalidate width
			this.invalidate('width');
		}

		this.$element
			.removeClass(this.options.loadingClass)
			.addClass(this.options.loadedClass);

		// register event handlers
		this.registerEventHandlers();

		this.leave('initializing');
		this.trigger('initialized');
	};

	/**
	 * Setups the current settings.
	 * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
	 * @todo Support for media queries by using `matchMedia` would be nice.
	 * @public
	 */
	Owl.prototype.setup = function() {
		var viewport = this.viewport(),
			overwrites = this.options.responsive,
			match = -1,
			settings = null;

		if (!overwrites) {
			settings = $.extend({}, this.options);
		} else {
			$.each(overwrites, function(breakpoint) {
				if (breakpoint <= viewport && breakpoint > match) {
					match = Number(breakpoint);
				}
			});

			settings = $.extend({}, this.options, overwrites[match]);
			if (typeof settings.stagePadding === 'function') {
				settings.stagePadding = settings.stagePadding();
			}
			delete settings.responsive;

			// responsive class
			if (settings.responsiveClass) {
				this.$element.attr('class',
					this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s', 'g'), '$1' + match)
				);
			}
		}

		this.trigger('change', { property: { name: 'settings', value: settings } });
		this._breakpoint = match;
		this.settings = settings;
		this.invalidate('settings');
		this.trigger('changed', { property: { name: 'settings', value: this.settings } });
	};

	/**
	 * Updates option logic if necessery.
	 * @protected
	 */
	Owl.prototype.optionsLogic = function() {
		if (this.settings.autoWidth) {
			this.settings.stagePadding = false;
			this.settings.merge = false;
		}
	};

	/**
	 * Prepares an item before add.
	 * @todo Rename event parameter `content` to `item`.
	 * @protected
	 * @returns {jQuery|HTMLElement} - The item container.
	 */
	Owl.prototype.prepare = function(item) {
		var event = this.trigger('prepare', { content: item });

		if (!event.data) {
			event.data = $('<' + this.settings.itemElement + '/>')
				.addClass(this.options.itemClass).append(item)
		}

		this.trigger('prepared', { content: event.data });

		return event.data;
	};

	/**
	 * Updates the view.
	 * @public
	 */
	Owl.prototype.update = function() {
		var i = 0,
			n = this._pipe.length,
			filter = $.proxy(function(p) { return this[p] }, this._invalidated),
			cache = {};

		while (i < n) {
			if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
				this._pipe[i].run(cache);
			}
			i++;
		}

		this._invalidated = {};

		!this.is('valid') && this.enter('valid');
	};

	/**
	 * Gets the width of the view.
	 * @public
	 * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
	 * @returns {Number} - The width of the view in pixel.
	 */
	Owl.prototype.width = function(dimension) {
		dimension = dimension || Owl.Width.Default;
		switch (dimension) {
			case Owl.Width.Inner:
			case Owl.Width.Outer:
				return this._width;
			default:
				return this._width - this.settings.stagePadding * 2 + this.settings.margin;
		}
	};

	/**
	 * Refreshes the carousel primarily for adaptive purposes.
	 * @public
	 */
	Owl.prototype.refresh = function() {
		this.enter('refreshing');
		this.trigger('refresh');

		this.setup();

		this.optionsLogic();

		this.$element.addClass(this.options.refreshClass);

		this.update();

		this.$element.removeClass(this.options.refreshClass);

		this.leave('refreshing');
		this.trigger('refreshed');
	};

	/**
	 * Checks window `resize` event.
	 * @protected
	 */
	Owl.prototype.onThrottledResize = function() {
		window.clearTimeout(this.resizeTimer);
		this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
	};

	/**
	 * Checks window `resize` event.
	 * @protected
	 */
	Owl.prototype.onResize = function() {
		if (!this._items.length) {
			return false;
		}

		if (this._width === this.$element.width()) {
			return false;
		}

		if (!this.$element.is(':visible')) {
			return false;
		}

		this.enter('resizing');

		if (this.trigger('resize').isDefaultPrevented()) {
			this.leave('resizing');
			return false;
		}

		this.invalidate('width');

		this.refresh();

		this.leave('resizing');
		this.trigger('resized');
	};

	/**
	 * Registers event handlers.
	 * @todo Check `msPointerEnabled`
	 * @todo #261
	 * @protected
	 */
	Owl.prototype.registerEventHandlers = function() {
		if ($.support.transition) {
			this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
		}

		if (this.settings.responsive !== false) {
			this.on(window, 'resize', this._handlers.onThrottledResize);
		}

		if (this.settings.mouseDrag) {
			this.$element.addClass(this.options.dragClass);
			this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
			this.$stage.on('dragstart.owl.core selectstart.owl.core', function() { return false });
		}

		if (this.settings.touchDrag){
			this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
			this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
		}
	};

	/**
	 * Handles `touchstart` and `mousedown` events.
	 * @todo Horizontal swipe threshold as option
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragStart = function(event) {
		var stage = null;

		if (event.which === 3) {
			return;
		}

		if ($.support.transform) {
			stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
			stage = {
				x: stage[stage.length === 16 ? 12 : 4],
				y: stage[stage.length === 16 ? 13 : 5]
			};
		} else {
			stage = this.$stage.position();
			stage = {
				x: this.settings.rtl ?
					stage.left + this.$stage.width() - this.width() + this.settings.margin :
					stage.left,
				y: stage.top
			};
		}

		if (this.is('animating')) {
			$.support.transform ? this.animate(stage.x) : this.$stage.stop()
			this.invalidate('position');
		}

		this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

		this.speed(0);

		this._drag.time = new Date().getTime();
		this._drag.target = $(event.target);
		this._drag.stage.start = stage;
		this._drag.stage.current = stage;
		this._drag.pointer = this.pointer(event);

		$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

		$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
			var delta = this.difference(this._drag.pointer, this.pointer(event));

			$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

			if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
				return;
			}

			event.preventDefault();

			this.enter('dragging');
			this.trigger('drag');
		}, this));
	};

	/**
	 * Handles the `touchmove` and `mousemove` events.
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragMove = function(event) {
		var minimum = null,
			maximum = null,
			pull = null,
			delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this.difference(this._drag.stage.start, delta);

		if (!this.is('dragging')) {
			return;
		}

		event.preventDefault();

		if (this.settings.loop) {
			minimum = this.coordinates(this.minimum());
			maximum = this.coordinates(this.maximum() + 1) - minimum;
			stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
		} else {
			minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
			maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
			pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
			stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
		}

		this._drag.stage.current = stage;

		this.animate(stage.x);
	};

	/**
	 * Handles the `touchend` and `mouseup` events.
	 * @todo #261
	 * @todo Threshold for click event
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onDragEnd = function(event) {
		var delta = this.difference(this._drag.pointer, this.pointer(event)),
			stage = this._drag.stage.current,
			direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

		$(document).off('.owl.core');

		this.$element.removeClass(this.options.grabClass);

		if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
			this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
			this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
			this.invalidate('position');
			this.update();

			this._drag.direction = direction;

			if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
				this._drag.target.one('click.owl.core', function() { return false; });
			}
		}

		if (!this.is('dragging')) {
			return;
		}

		this.leave('dragging');
		this.trigger('dragged');
	};

	/**
	 * Gets absolute position of the closest item for a coordinate.
	 * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
	 * @protected
	 * @param {Number} coordinate - The coordinate in pixel.
	 * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
	 * @return {Number} - The absolute position of the closest item.
	 */
	Owl.prototype.closest = function(coordinate, direction) {
		var position = -1,
			pull = 30,
			width = this.width(),
			coordinates = this.coordinates();

		if (!this.settings.freeDrag) {
			// check closest item
			$.each(coordinates, $.proxy(function(index, value) {
				// on a left pull, check on current index
				if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
					position = index;
				// on a right pull, check on previous index
				// to do so, subtract width from value and set position = index + 1
				} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
					position = index + 1;
				} else if (this.op(coordinate, '<', value)
					&& this.op(coordinate, '>', coordinates[index + 1] || value - width)) {
					position = direction === 'left' ? index + 1 : index;
				}
				return position === -1;
			}, this));
		}

		if (!this.settings.loop) {
			// non loop boundries
			if (this.op(coordinate, '>', coordinates[this.minimum()])) {
				position = coordinate = this.minimum();
			} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
				position = coordinate = this.maximum();
			}
		}

		return position;
	};

	/**
	 * Animates the stage.
	 * @todo #270
	 * @public
	 * @param {Number} coordinate - The coordinate in pixels.
	 */
	Owl.prototype.animate = function(coordinate) {
		var animate = this.speed() > 0;

		this.is('animating') && this.onTransitionEnd();

		if (animate) {
			this.enter('animating');
			this.trigger('translate');
		}

		if ($.support.transform3d && $.support.transition) {
			this.$stage.css({
				transform: 'translate3d(' + coordinate + 'px,0px,0px)',
				transition: (this.speed() / 1000) + 's'
			});
		} else if (animate) {
			this.$stage.animate({
				left: coordinate + 'px'
			}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
		} else {
			this.$stage.css({
				left: coordinate + 'px'
			});
		}
	};

	/**
	 * Checks whether the carousel is in a specific state or not.
	 * @param {String} state - The state to check.
	 * @returns {Boolean} - The flag which indicates if the carousel is busy.
	 */
	Owl.prototype.is = function(state) {
		return this._states.current[state] && this._states.current[state] > 0;
	};

	/**
	 * Sets the absolute position of the current item.
	 * @public
	 * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
	 * @returns {Number} - The absolute position of the current item.
	 */
	Owl.prototype.current = function(position) {
		if (position === undefined) {
			return this._current;
		}

		if (this._items.length === 0) {
			return undefined;
		}

		position = this.normalize(position);

		if (this._current !== position) {
			var event = this.trigger('change', { property: { name: 'position', value: position } });

			if (event.data !== undefined) {
				position = this.normalize(event.data);
			}

			this._current = position;

			this.invalidate('position');

			this.trigger('changed', { property: { name: 'position', value: this._current } });
		}

		return this._current;
	};

	/**
	 * Invalidates the given part of the update routine.
	 * @param {String} [part] - The part to invalidate.
	 * @returns {Array.<String>} - The invalidated parts.
	 */
	Owl.prototype.invalidate = function(part) {
		if ($.type(part) === 'string') {
			this._invalidated[part] = true;
			this.is('valid') && this.leave('valid');
		}
		return $.map(this._invalidated, function(v, i) { return i });
	};

	/**
	 * Resets the absolute position of the current item.
	 * @public
	 * @param {Number} position - The absolute position of the new item.
	 */
	Owl.prototype.reset = function(position) {
		position = this.normalize(position);

		if (position === undefined) {
			return;
		}

		this._speed = 0;
		this._current = position;

		this.suppress([ 'translate', 'translated' ]);

		this.animate(this.coordinates(position));

		this.release([ 'translate', 'translated' ]);
	};

	/**
	 * Normalizes an absolute or a relative position of an item.
	 * @public
	 * @param {Number} position - The absolute or relative position to normalize.
	 * @param {Boolean} [relative=false] - Whether the given position is relative or not.
	 * @returns {Number} - The normalized position.
	 */
	Owl.prototype.normalize = function(position, relative) {
		var n = this._items.length,
			m = relative ? 0 : this._clones.length;

		if (!this.isNumeric(position) || n < 1) {
			position = undefined;
		} else if (position < 0 || position >= n + m) {
			position = ((position - m / 2) % n + n) % n + m / 2;
		}

		return position;
	};

	/**
	 * Converts an absolute position of an item into a relative one.
	 * @public
	 * @param {Number} position - The absolute position to convert.
	 * @returns {Number} - The converted position.
	 */
	Owl.prototype.relative = function(position) {
		position -= this._clones.length / 2;
		return this.normalize(position, true);
	};

	/**
	 * Gets the maximum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
	Owl.prototype.maximum = function(relative) {
		var settings = this.settings,
			maximum = this._coordinates.length,
			iterator,
			reciprocalItemsWidth,
			elementWidth;

		if (settings.loop) {
			maximum = this._clones.length / 2 + this._items.length - 1;
		} else if (settings.autoWidth || settings.merge) {
			iterator = this._items.length;
			reciprocalItemsWidth = this._items[--iterator].width();
			elementWidth = this.$element.width();
			while (iterator--) {
				reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
				if (reciprocalItemsWidth > elementWidth) {
					break;
				}
			}
			maximum = iterator + 1;
		} else if (settings.center) {
			maximum = this._items.length - 1;
		} else {
			maximum = this._items.length - settings.items;
		}

		if (relative) {
			maximum -= this._clones.length / 2;
		}

		return Math.max(maximum, 0);
	};

	/**
	 * Gets the minimum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
	Owl.prototype.minimum = function(relative) {
		return relative ? 0 : this._clones.length / 2;
	};

	/**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
	Owl.prototype.items = function(position) {
		if (position === undefined) {
			return this._items.slice();
		}

		position = this.normalize(position, true);
		return this._items[position];
	};

	/**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
	Owl.prototype.mergers = function(position) {
		if (position === undefined) {
			return this._mergers.slice();
		}

		position = this.normalize(position, true);
		return this._mergers[position];
	};

	/**
	 * Gets the absolute positions of clones for an item.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
	 */
	Owl.prototype.clones = function(position) {
		var odd = this._clones.length / 2,
			even = odd + this._items.length,
			map = function(index) { return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2 };

		if (position === undefined) {
			return $.map(this._clones, function(v, i) { return map(i) });
		}

		return $.map(this._clones, function(v, i) { return v === position ? map(i) : null });
	};

	/**
	 * Sets the current animation speed.
	 * @public
	 * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
	 * @returns {Number} - The current animation speed in milliseconds.
	 */
	Owl.prototype.speed = function(speed) {
		if (speed !== undefined) {
			this._speed = speed;
		}

		return this._speed;
	};

	/**
	 * Gets the coordinate of an item.
	 * @todo The name of this method is missleanding.
	 * @public
	 * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
	 * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
	 */
	Owl.prototype.coordinates = function(position) {
		var multiplier = 1,
			newPosition = position - 1,
			coordinate;

		if (position === undefined) {
			return $.map(this._coordinates, $.proxy(function(coordinate, index) {
				return this.coordinates(index);
			}, this));
		}

		if (this.settings.center) {
			if (this.settings.rtl) {
				multiplier = -1;
				newPosition = position + 1;
			}

			coordinate = this._coordinates[position];
			coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
		} else {
			coordinate = this._coordinates[newPosition] || 0;
		}

		coordinate = Math.ceil(coordinate);

		return coordinate;
	};

	/**
	 * Calculates the speed for a translation.
	 * @protected
	 * @param {Number} from - The absolute position of the start item.
	 * @param {Number} to - The absolute position of the target item.
	 * @param {Number} [factor=undefined] - The time factor in milliseconds.
	 * @returns {Number} - The time in milliseconds for the translation.
	 */
	Owl.prototype.duration = function(from, to, factor) {
		if (factor === 0) {
			return 0;
		}

		return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
	};

	/**
	 * Slides to the specified item.
	 * @public
	 * @param {Number} position - The position of the item.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.to = function(position, speed) {
		var current = this.current(),
			revert = null,
			distance = position - this.relative(current),
			direction = (distance > 0) - (distance < 0),
			items = this._items.length,
			minimum = this.minimum(),
			maximum = this.maximum();

		if (this.settings.loop) {
			if (!this.settings.rewind && Math.abs(distance) > items / 2) {
				distance += direction * -1 * items;
			}

			position = current + distance;
			revert = ((position - minimum) % items + items) % items + minimum;

			if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
				current = revert - distance;
				position = revert;
				this.reset(current);
			}
		} else if (this.settings.rewind) {
			maximum += 1;
			position = (position % maximum + maximum) % maximum;
		} else {
			position = Math.max(minimum, Math.min(maximum, position));
		}

		this.speed(this.duration(current, position, speed));
		this.current(position);

		if (this.$element.is(':visible')) {
			this.update();
		}
	};

	/**
	 * Slides to the next item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.next = function(speed) {
		speed = speed || false;
		this.to(this.relative(this.current()) + 1, speed);
	};

	/**
	 * Slides to the previous item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
	Owl.prototype.prev = function(speed) {
		speed = speed || false;
		this.to(this.relative(this.current()) - 1, speed);
	};

	/**
	 * Handles the end of an animation.
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
	Owl.prototype.onTransitionEnd = function(event) {

		// if css2 animation then event object is undefined
		if (event !== undefined) {
			event.stopPropagation();

			// Catch only owl-stage transitionEnd event
			if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
				return false;
			}
		}

		this.leave('animating');
		this.trigger('translated');
	};

	/**
	 * Gets viewport width.
	 * @protected
	 * @return {Number} - The width in pixel.
	 */
	Owl.prototype.viewport = function() {
		var width;
		if (this.options.responsiveBaseElement !== window) {
			width = $(this.options.responsiveBaseElement).width();
		} else if (window.innerWidth) {
			width = window.innerWidth;
		} else if (document.documentElement && document.documentElement.clientWidth) {
			width = document.documentElement.clientWidth;
		} else {
			console.warn('Can not detect viewport width.');
		}
		return width;
	};

	/**
	 * Replaces the current content.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The new content.
	 */
	Owl.prototype.replace = function(content) {
		this.$stage.empty();
		this._items = [];

		if (content) {
			content = (content instanceof jQuery) ? content : $(content);
		}

		if (this.settings.nestedItemSelector) {
			content = content.find('.' + this.settings.nestedItemSelector);
		}

		content.filter(function() {
			return this.nodeType === 1;
		}).each($.proxy(function(index, item) {
			item = this.prepare(item);
			this.$stage.append(item);
			this._items.push(item);
			this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		}, this));

		this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

		this.invalidate('items');
	};

	/**
	 * Adds an item.
	 * @todo Use `item` instead of `content` for the event arguments.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The item content to add.
	 * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
	 */
	Owl.prototype.add = function(content, position) {
		var current = this.relative(this._current);

		position = position === undefined ? this._items.length : this.normalize(position, true);
		content = content instanceof jQuery ? content : $(content);

		this.trigger('add', { content: content, position: position });

		content = this.prepare(content);

		if (this._items.length === 0 || position === this._items.length) {
			this._items.length === 0 && this.$stage.append(content);
			this._items.length !== 0 && this._items[position - 1].after(content);
			this._items.push(content);
			this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		} else {
			this._items[position].before(content);
			this._items.splice(position, 0, content);
			this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
		}

		this._items[current] && this.reset(this._items[current].index());

		this.invalidate('items');

		this.trigger('added', { content: content, position: position });
	};

	/**
	 * Removes an item by its position.
	 * @todo Use `item` instead of `content` for the event arguments.
	 * @public
	 * @param {Number} position - The relative position of the item to remove.
	 */
	Owl.prototype.remove = function(position) {
		position = this.normalize(position, true);

		if (position === undefined) {
			return;
		}

		this.trigger('remove', { content: this._items[position], position: position });

		this._items[position].remove();
		this._items.splice(position, 1);
		this._mergers.splice(position, 1);

		this.invalidate('items');

		this.trigger('removed', { content: null, position: position });
	};

	/**
	 * Preloads images with auto width.
	 * @todo Replace by a more generic approach
	 * @protected
	 */
	Owl.prototype.preloadAutoWidthImages = function(images) {
		images.each($.proxy(function(i, element) {
			this.enter('pre-loading');
			element = $(element);
			$(new Image()).one('load', $.proxy(function(e) {
				element.attr('src', e.target.src);
				element.css('opacity', 1);
				this.leave('pre-loading');
				!this.is('pre-loading') && !this.is('initializing') && this.refresh();
			}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
		}, this));
	};

	/**
	 * Destroys the carousel.
	 * @public
	 */
	Owl.prototype.destroy = function() {

		this.$element.off('.owl.core');
		this.$stage.off('.owl.core');
		$(document).off('.owl.core');

		if (this.settings.responsive !== false) {
			window.clearTimeout(this.resizeTimer);
			this.off(window, 'resize', this._handlers.onThrottledResize);
		}

		for (var i in this._plugins) {
			this._plugins[i].destroy();
		}

		this.$stage.children('.cloned').remove();

		this.$stage.unwrap();
		this.$stage.children().contents().unwrap();
		this.$stage.children().unwrap();

		this.$element
			.removeClass(this.options.refreshClass)
			.removeClass(this.options.loadingClass)
			.removeClass(this.options.loadedClass)
			.removeClass(this.options.rtlClass)
			.removeClass(this.options.dragClass)
			.removeClass(this.options.grabClass)
			.attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s', 'g'), ''))
			.removeData('owl.carousel');
	};

	/**
	 * Operators to calculate right-to-left and left-to-right.
	 * @protected
	 * @param {Number} [a] - The left side operand.
	 * @param {String} [o] - The operator.
	 * @param {Number} [b] - The right side operand.
	 */
	Owl.prototype.op = function(a, o, b) {
		var rtl = this.settings.rtl;
		switch (o) {
			case '<':
				return rtl ? a > b : a < b;
			case '>':
				return rtl ? a < b : a > b;
			case '>=':
				return rtl ? a <= b : a >= b;
			case '<=':
				return rtl ? a >= b : a <= b;
			default:
				break;
		}
	};

	/**
	 * Attaches to an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The event handler to attach.
	 * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
	 */
	Owl.prototype.on = function(element, event, listener, capture) {
		if (element.addEventListener) {
			element.addEventListener(event, listener, capture);
		} else if (element.attachEvent) {
			element.attachEvent('on' + event, listener);
		}
	};

	/**
	 * Detaches from an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The attached event handler to detach.
	 * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
	 */
	Owl.prototype.off = function(element, event, listener, capture) {
		if (element.removeEventListener) {
			element.removeEventListener(event, listener, capture);
		} else if (element.detachEvent) {
			element.detachEvent('on' + event, listener);
		}
	};

	/**
	 * Triggers a public event.
	 * @todo Remove `status`, `relatedTarget` should be used instead.
	 * @protected
	 * @param {String} name - The event name.
	 * @param {*} [data=null] - The event data.
	 * @param {String} [namespace=carousel] - The event namespace.
	 * @param {String} [state] - The state which is associated with the event.
	 * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
	 * @returns {Event} - The event arguments.
	 */
	Owl.prototype.trigger = function(name, data, namespace, state, enter) {
		var status = {
			item: { count: this._items.length, index: this.current() }
		}, handler = $.camelCase(
			$.grep([ 'on', name, namespace ], function(v) { return v })
				.join('-').toLowerCase()
		), event = $.Event(
			[ name, 'owl', namespace || 'carousel' ].join('.').toLowerCase(),
			$.extend({ relatedTarget: this }, status, data)
		);

		if (!this._supress[name]) {
			$.each(this._plugins, function(name, plugin) {
				if (plugin.onTrigger) {
					plugin.onTrigger(event);
				}
			});

			this.register({ type: Owl.Type.Event, name: name });
			this.$element.trigger(event);

			if (this.settings && typeof this.settings[handler] === 'function') {
				this.settings[handler].call(this, event);
			}
		}

		return event;
	};

	/**
	 * Enters a state.
	 * @param name - The state name.
	 */
	Owl.prototype.enter = function(name) {
		$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
			if (this._states.current[name] === undefined) {
				this._states.current[name] = 0;
			}

			this._states.current[name]++;
		}, this));
	};

	/**
	 * Leaves a state.
	 * @param name - The state name.
	 */
	Owl.prototype.leave = function(name) {
		$.each([ name ].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
			this._states.current[name]--;
		}, this));
	};

	/**
	 * Registers an event or state.
	 * @public
	 * @param {Object} object - The event or state to register.
	 */
	Owl.prototype.register = function(object) {
		if (object.type === Owl.Type.Event) {
			if (!$.event.special[object.name]) {
				$.event.special[object.name] = {};
			}

			if (!$.event.special[object.name].owl) {
				var _default = $.event.special[object.name]._default;
				$.event.special[object.name]._default = function(e) {
					if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
						return _default.apply(this, arguments);
					}
					return e.namespace && e.namespace.indexOf('owl') > -1;
				};
				$.event.special[object.name].owl = true;
			}
		} else if (object.type === Owl.Type.State) {
			if (!this._states.tags[object.name]) {
				this._states.tags[object.name] = object.tags;
			} else {
				this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
			}

			this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
				return $.inArray(tag, this._states.tags[object.name]) === i;
			}, this));
		}
	};

	/**
	 * Suppresses events.
	 * @protected
	 * @param {Array.<String>} events - The events to suppress.
	 */
	Owl.prototype.suppress = function(events) {
		$.each(events, $.proxy(function(index, event) {
			this._supress[event] = true;
		}, this));
	};

	/**
	 * Releases suppressed events.
	 * @protected
	 * @param {Array.<String>} events - The events to release.
	 */
	Owl.prototype.release = function(events) {
		$.each(events, $.proxy(function(index, event) {
			delete this._supress[event];
		}, this));
	};

	/**
	 * Gets unified pointer coordinates from event.
	 * @todo #261
	 * @protected
	 * @param {Event} - The `mousedown` or `touchstart` event.
	 * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
	 */
	Owl.prototype.pointer = function(event) {
		var result = { x: null, y: null };

		event = event.originalEvent || event || window.event;

		event = event.touches && event.touches.length ?
			event.touches[0] : event.changedTouches && event.changedTouches.length ?
				event.changedTouches[0] : event;

		if (event.pageX) {
			result.x = event.pageX;
			result.y = event.pageY;
		} else {
			result.x = event.clientX;
			result.y = event.clientY;
		}

		return result;
	};

	/**
	 * Determines if the input is a Number or something that can be coerced to a Number
	 * @protected
	 * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
	 * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
	 */
	Owl.prototype.isNumeric = function(number) {
		return !isNaN(parseFloat(number));
	};

	/**
	 * Gets the difference of two vectors.
	 * @todo #261
	 * @protected
	 * @param {Object} - The first vector.
	 * @param {Object} - The second vector.
	 * @returns {Object} - The difference.
	 */
	Owl.prototype.difference = function(first, second) {
		return {
			x: first.x - second.x,
			y: first.y - second.y
		};
	};

	/**
	 * The jQuery Plugin for the Owl Carousel
	 * @todo Navigation plugin `next` and `prev`
	 * @public
	 */
	$.fn.owlCarousel = function(option) {
		var args = Array.prototype.slice.call(arguments, 1);

		return this.each(function() {
			var $this = $(this),
				data = $this.data('owl.carousel');

			if (!data) {
				data = new Owl(this, typeof option == 'object' && option);
				$this.data('owl.carousel', data);

				$.each([
					'next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'
				], function(i, event) {
					data.register({ type: Owl.Type.Event, name: event });
					data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
						if (e.namespace && e.relatedTarget !== this) {
							this.suppress([ event ]);
							data[event].apply(this, [].slice.call(arguments, 1));
							this.release([ event ]);
						}
					}, data));
				});
			}

			if (typeof option == 'string' && option.charAt(0) !== '_') {
				data[option].apply(data, args);
			}
		});
	};

	/**
	 * The constructor for the jQuery Plugin
	 * @public
	 */
	$.fn.owlCarousel.Constructor = Owl;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoRefresh Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the auto refresh plugin.
	 * @class The Auto Refresh Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var AutoRefresh = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Refresh interval.
		 * @protected
		 * @type {number}
		 */
		this._interval = null;

		/**
		 * Whether the element is currently visible or not.
		 * @protected
		 * @type {Boolean}
		 */
		this._visible = null;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoRefresh) {
					this.watch();
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	AutoRefresh.Defaults = {
		autoRefresh: true,
		autoRefreshInterval: 500
	};

	/**
	 * Watches the element.
	 */
	AutoRefresh.prototype.watch = function() {
		if (this._interval) {
			return;
		}

		this._visible = this._core.$element.is(':visible');
		this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
	};

	/**
	 * Refreshes the element.
	 */
	AutoRefresh.prototype.refresh = function() {
		if (this._core.$element.is(':visible') === this._visible) {
			return;
		}

		this._visible = !this._visible;

		this._core.$element.toggleClass('owl-hidden', !this._visible);

		this._visible && (this._core.invalidate('width') && this._core.refresh());
	};

	/**
	 * Destroys the plugin.
	 */
	AutoRefresh.prototype.destroy = function() {
		var handler, property;

		window.clearInterval(this._interval);

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

})(window.Zepto || window.jQuery, window, document);

/**
 * Lazy Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the lazy plugin.
	 * @class The Lazy Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Lazy = function(carousel) {

		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Already loaded items.
		 * @protected
		 * @type {Array.<jQuery>}
		 */
		this._loaded = [];

		/**
		 * Event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {
				if (!e.namespace) {
					return;
				}

				if (!this._core.settings || !this._core.settings.lazyLoad) {
					return;
				}

				if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
					var settings = this._core.settings,
						n = (settings.center && Math.ceil(settings.items / 2) || settings.items),
						i = ((settings.center && n * -1) || 0),
						position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,
						clones = this._core.clones().length,
						load = $.proxy(function(i, v) { this.load(v) }, this);

					while (i++ < n) {
						this.load(clones / 2 + this._core.relative(position));
						clones && $.each(this._core.clones(this._core.relative(position)), load);
						position++;
					}
				}
			}, this)
		};

		// set the default options
		this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

		// register event handler
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	Lazy.Defaults = {
		lazyLoad: false
	};

	/**
	 * Loads all resources of an item at the specified position.
	 * @param {Number} position - The absolute position of the item.
	 * @protected
	 */
	Lazy.prototype.load = function(position) {
		var $item = this._core.$stage.children().eq(position),
			$elements = $item && $item.find('.owl-lazy');

		if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
			return;
		}

		$elements.each($.proxy(function(index, element) {
			var $element = $(element), image,
				url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');

			this._core.trigger('load', { element: $element, url: url }, 'lazy');

			if ($element.is('img')) {
				$element.one('load.owl.lazy', $.proxy(function() {
					$element.css('opacity', 1);
					this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
				}, this)).attr('src', url);
			} else {
				image = new Image();
				image.onload = $.proxy(function() {
					$element.css({
						'background-image': 'url("' + url + '")',
						'opacity': '1'
					});
					this._core.trigger('loaded', { element: $element, url: url }, 'lazy');
				}, this);
				image.src = url;
			}
		}, this));

		this._loaded.push($item.get(0));
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Lazy.prototype.destroy = function() {
		var handler, property;

		for (handler in this.handlers) {
			this._core.$element.off(handler, this.handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

})(window.Zepto || window.jQuery, window, document);

/**
 * AutoHeight Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the auto height plugin.
	 * @class The Auto Height Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var AutoHeight = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight) {
					this.update();
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight && e.property.name == 'position'){
					this.update();
				}
			}, this),
			'loaded.owl.lazy': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoHeight
					&& e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
					this.update();
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	AutoHeight.Defaults = {
		autoHeight: false,
		autoHeightClass: 'owl-height'
	};

	/**
	 * Updates the view.
	 */
	AutoHeight.prototype.update = function() {
		var start = this._core._current,
			end = start + this._core.settings.items,
			visible = this._core.$stage.children().toArray().slice(start, end),
			heights = [],
			maxheight = 0;

		$.each(visible, function(index, item) {
			heights.push($(item).height());
		});

		maxheight = Math.max.apply(null, heights);

		this._core.$stage.parent()
			.height(maxheight)
			.addClass(this._core.settings.autoHeightClass);
	};

	AutoHeight.prototype.destroy = function() {
		var handler, property;

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

})(window.Zepto || window.jQuery, window, document);

/**
 * Video Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the video plugin.
	 * @class The Video Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Video = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Cache all video URLs.
		 * @protected
		 * @type {Object}
		 */
		this._videos = {};

		/**
		 * Current playing item.
		 * @protected
		 * @type {jQuery}
		 */
		this._playing = null;

		/**
		 * All event handlers.
		 * @todo The cloned content removale is too late
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					this._core.register({ type: 'state', name: 'playing', tags: [ 'interacting' ] });
				}
			}, this),
			'resize.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
					e.preventDefault();
				}
			}, this),
			'refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.is('resizing')) {
					this._core.$stage.find('.cloned .owl-video-frame').remove();
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'position' && this._playing) {
					this.stop();
				}
			}, this),
			'prepared.owl.carousel': $.proxy(function(e) {
				if (!e.namespace) {
					return;
				}

				var $element = $(e.content).find('.owl-video');

				if ($element.length) {
					$element.css('display', 'none');
					this.fetch($element, $(e.content));
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Video.Defaults, this._core.options);

		// register event handlers
		this._core.$element.on(this._handlers);

		this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
			this.play(e);
		}, this));
	};

	/**
	 * Default options.
	 * @public
	 */
	Video.Defaults = {
		video: false,
		videoHeight: false,
		videoWidth: false
	};

	/**
	 * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {jQuery} item - The item containing the video.
	 */
	Video.prototype.fetch = function(target, item) {
			var type = (function() {
					if (target.attr('data-vimeo-id')) {
						return 'vimeo';
					} else if (target.attr('data-vzaar-id')) {
						return 'vzaar'
					} else {
						return 'youtube';
					}
				})(),
				id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),
				width = target.attr('data-width') || this._core.settings.videoWidth,
				height = target.attr('data-height') || this._core.settings.videoHeight,
				url = target.attr('href');

		if (url) {

			/*
					Parses the id's out of the following urls (and probably more):
					https://www.youtube.com/watch?v=:id
					https://youtu.be/:id
					https://vimeo.com/:id
					https://vimeo.com/channels/:channel/:id
					https://vimeo.com/groups/:group/videos/:id
					https://app.vzaar.com/videos/:id

					Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
			*/

			id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

			if (id[3].indexOf('youtu') > -1) {
				type = 'youtube';
			} else if (id[3].indexOf('vimeo') > -1) {
				type = 'vimeo';
			} else if (id[3].indexOf('vzaar') > -1) {
				type = 'vzaar';
			} else {
				throw new Error('Video URL not supported.');
			}
			id = id[6];
		} else {
			throw new Error('Missing video URL.');
		}

		this._videos[url] = {
			type: type,
			id: id,
			width: width,
			height: height
		};

		item.attr('data-video', url);

		this.thumbnail(target, this._videos[url]);
	};

	/**
	 * Creates video thumbnail.
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {Object} info - The video info object.
	 * @see `fetch`
	 */
	Video.prototype.thumbnail = function(target, video) {
		var tnLink,
			icon,
			path,
			dimensions = video.width && video.height ? 'style="width:' + video.width + 'px;height:' + video.height + 'px;"' : '',
			customTn = target.find('img'),
			srcType = 'src',
			lazyClass = '',
			settings = this._core.settings,
			create = function(path) {
				icon = '<div class="owl-video-play-icon"></div>';

				if (settings.lazyLoad) {
					tnLink = '<div class="owl-video-tn ' + lazyClass + '" ' + srcType + '="' + path + '"></div>';
				} else {
					tnLink = '<div class="owl-video-tn" style="opacity:1;background-image:url(' + path + ')"></div>';
				}
				target.after(tnLink);
				target.after(icon);
			};

		// wrap video content into owl-video-wrapper div
		target.wrap('<div class="owl-video-wrapper"' + dimensions + '></div>');

		if (this._core.settings.lazyLoad) {
			srcType = 'data-src';
			lazyClass = 'owl-lazy';
		}

		// custom thumbnail
		if (customTn.length) {
			create(customTn.attr(srcType));
			customTn.remove();
			return false;
		}

		if (video.type === 'youtube') {
			path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
			create(path);
		} else if (video.type === 'vimeo') {
			$.ajax({
				type: 'GET',
				url: '//vimeo.com/api/v2/video/' + video.id + '.json',
				jsonp: 'callback',
				dataType: 'jsonp',
				success: function(data) {
					path = data[0].thumbnail_large;
					create(path);
				}
			});
		} else if (video.type === 'vzaar') {
			$.ajax({
				type: 'GET',
				url: '//vzaar.com/api/videos/' + video.id + '.json',
				jsonp: 'callback',
				dataType: 'jsonp',
				success: function(data) {
					path = data.framegrab_url;
					create(path);
				}
			});
		}
	};

	/**
	 * Stops the current video.
	 * @public
	 */
	Video.prototype.stop = function() {
		this._core.trigger('stop', null, 'video');
		this._playing.find('.owl-video-frame').remove();
		this._playing.removeClass('owl-video-playing');
		this._playing = null;
		this._core.leave('playing');
		this._core.trigger('stopped', null, 'video');
	};

	/**
	 * Starts the current video.
	 * @public
	 * @param {Event} event - The event arguments.
	 */
	Video.prototype.play = function(event) {
		var target = $(event.target),
			item = target.closest('.' + this._core.settings.itemClass),
			video = this._videos[item.attr('data-video')],
			width = video.width || '100%',
			height = video.height || this._core.$stage.height(),
			html;

		if (this._playing) {
			return;
		}

		this._core.enter('playing');
		this._core.trigger('play', null, 'video');

		item = this._core.items(this._core.relative(item.index()));

		this._core.reset(item.index());

		if (video.type === 'youtube') {
			html = '<iframe width="' + width + '" height="' + height + '" src="//www.youtube.com/embed/' +
				video.id + '?autoplay=1&rel=0&v=' + video.id + '" frameborder="0" allowfullscreen></iframe>';
		} else if (video.type === 'vimeo') {
			html = '<iframe src="//player.vimeo.com/video/' + video.id +
				'?autoplay=1" width="' + width + '" height="' + height +
				'" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
		} else if (video.type === 'vzaar') {
			html = '<iframe frameborder="0"' + 'height="' + height + '"' + 'width="' + width +
				'" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' +
				'src="//view.vzaar.com/' + video.id + '/player?autoplay=true"></iframe>';
		}

		$('<div class="owl-video-frame">' + html + '</div>').insertAfter(item.find('.owl-video'));

		this._playing = item.addClass('owl-video-playing');
	};

	/**
	 * Checks whether an video is currently in full screen mode or not.
	 * @todo Bad style because looks like a readonly method but changes members.
	 * @protected
	 * @returns {Boolean}
	 */
	Video.prototype.isInFullScreen = function() {
		var element = document.fullscreenElement || document.mozFullScreenElement ||
				document.webkitFullscreenElement;

		return element && $(element).parent().hasClass('owl-video-frame');
	};

	/**
	 * Destroys the plugin.
	 */
	Video.prototype.destroy = function() {
		var handler, property;

		this._core.$element.off('click.owl.video');

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Video = Video;

})(window.Zepto || window.jQuery, window, document);

/**
 * Animate Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the animate plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
	var Animate = function(scope) {
		this.core = scope;
		this.core.options = $.extend({}, Animate.Defaults, this.core.options);
		this.swapping = true;
		this.previous = undefined;
		this.next = undefined;

		this.handlers = {
			'change.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name == 'position') {
					this.previous = this.core.current();
					this.next = e.property.value;
				}
			}, this),
			'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					this.swapping = e.type == 'translated';
				}
			}, this),
			'translate.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
					this.swap();
				}
			}, this)
		};

		this.core.$element.on(this.handlers);
	};

	/**
	 * Default options.
	 * @public
	 */
	Animate.Defaults = {
		animateOut: false,
		animateIn: false
	};

	/**
	 * Toggles the animation classes whenever an translations starts.
	 * @protected
	 * @returns {Boolean|undefined}
	 */
	Animate.prototype.swap = function() {

		if (this.core.settings.items !== 1) {
			return;
		}

		if (!$.support.animation || !$.support.transition) {
			return;
		}

		this.core.speed(0);

		var left,
			clear = $.proxy(this.clear, this),
			previous = this.core.$stage.children().eq(this.previous),
			next = this.core.$stage.children().eq(this.next),
			incoming = this.core.settings.animateIn,
			outgoing = this.core.settings.animateOut;

		if (this.core.current() === this.previous) {
			return;
		}

		if (outgoing) {
			left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
			previous.one($.support.animation.end, clear)
				.css( { 'left': left + 'px' } )
				.addClass('animated owl-animated-out')
				.addClass(outgoing);
		}

		if (incoming) {
			next.one($.support.animation.end, clear)
				.addClass('animated owl-animated-in')
				.addClass(incoming);
		}
	};

	Animate.prototype.clear = function(e) {
		$(e.target).css( { 'left': '' } )
			.removeClass('animated owl-animated-out owl-animated-in')
			.removeClass(this.core.settings.animateIn)
			.removeClass(this.core.settings.animateOut);
		this.core.onTransitionEnd();
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Animate.prototype.destroy = function() {
		var handler, property;

		for (handler in this.handlers) {
			this.core.$element.off(handler, this.handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

})(window.Zepto || window.jQuery, window, document);

/**
 * Autoplay Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	/**
	 * Creates the autoplay plugin.
	 * @class The Autoplay Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
	var Autoplay = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * The autoplay timeout.
		 * @type {Timeout}
		 */
		this._timeout = null;

		/**
		 * Indicates whenever the autoplay is paused.
		 * @type {Boolean}
		 */
		this._paused = false;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'settings') {
					if (this._core.settings.autoplay) {
						this.play();
					} else {
						this.stop();
					}
				} else if (e.namespace && e.property.name === 'position') {

					if (this._core.settings.autoplay) {
						this._setAutoPlayInterval();
					}
				}
			}, this),
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.autoplay) {
					this.play();
				}
			}, this),
			'play.owl.autoplay': $.proxy(function(e, t, s) {
				if (e.namespace) {
					this.play(t, s);
				}
			}, this),
			'stop.owl.autoplay': $.proxy(function(e) {
				if (e.namespace) {
					this.stop();
				}
			}, this),
			'mouseover.owl.autoplay': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.pause();
				}
			}, this),
			'mouseleave.owl.autoplay': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.play();
				}
			}, this),
			'touchstart.owl.core': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
					this.pause();
				}
			}, this),
			'touchend.owl.core': $.proxy(function() {
				if (this._core.settings.autoplayHoverPause) {
					this.play();
				}
			}, this)
		};

		// register event handlers
		this._core.$element.on(this._handlers);

		// set default options
		this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
	};

	/**
	 * Default options.
	 * @public
	 */
	Autoplay.Defaults = {
		autoplay: false,
		autoplayTimeout: 5000,
		autoplayHoverPause: false,
		autoplaySpeed: false
	};

	/**
	 * Starts the autoplay.
	 * @public
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 */
	Autoplay.prototype.play = function(timeout, speed) {
		this._paused = false;

		if (this._core.is('rotating')) {
			return;
		}

		this._core.enter('rotating');

		this._setAutoPlayInterval();
	};

	/**
	 * Gets a new timeout
	 * @private
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 * @return {Timeout}
	 */
	Autoplay.prototype._getNextTimeout = function(timeout, speed) {
		if ( this._timeout ) {
			window.clearTimeout(this._timeout);
		}
		return window.setTimeout($.proxy(function() {
			if (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {
				return;
			}
			this._core.next(speed || this._core.settings.autoplaySpeed);
		}, this), timeout || this._core.settings.autoplayTimeout);
	};

	/**
	 * Sets autoplay in motion.
	 * @private
	 */
	Autoplay.prototype._setAutoPlayInterval = function() {
		this._timeout = this._getNextTimeout();
	};

	/**
	 * Stops the autoplay.
	 * @public
	 */
	Autoplay.prototype.stop = function() {
		if (!this._core.is('rotating')) {
			return;
		}

		window.clearTimeout(this._timeout);
		this._core.leave('rotating');
	};

	/**
	 * Stops the autoplay.
	 * @public
	 */
	Autoplay.prototype.pause = function() {
		if (!this._core.is('rotating')) {
			return;
		}

		this._paused = true;
	};

	/**
	 * Destroys the plugin.
	 */
	Autoplay.prototype.destroy = function() {
		var handler, property;

		this.stop();

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

})(window.Zepto || window.jQuery, window, document);

/**
 * Navigation Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
	'use strict';

	/**
	 * Creates the navigation plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} carousel - The Owl Carousel.
	 */
	var Navigation = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Indicates whether the plugin is initialized or not.
		 * @protected
		 * @type {Boolean}
		 */
		this._initialized = false;

		/**
		 * The current paging indexes.
		 * @protected
		 * @type {Array}
		 */
		this._pages = [];

		/**
		 * All DOM elements of the user interface.
		 * @protected
		 * @type {Object}
		 */
		this._controls = {};

		/**
		 * Markup for an indicator.
		 * @protected
		 * @type {Array.<String>}
		 */
		this._templates = [];

		/**
		 * The carousel element.
		 * @type {jQuery}
		 */
		this.$element = this._core.$element;

		/**
		 * Overridden methods of the carousel.
		 * @protected
		 * @type {Object}
		 */
		this._overrides = {
			next: this._core.next,
			prev: this._core.prev,
			to: this._core.to
		};

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'prepared.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.push('<div class="' + this._core.settings.dotClass + '">' +
						$(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
				}
			}, this),
			'added.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.splice(e.position, 0, this._templates.pop());
				}
			}, this),
			'remove.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.dotsData) {
					this._templates.splice(e.position, 1);
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name == 'position') {
					this.draw();
				}
			}, this),
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && !this._initialized) {
					this._core.trigger('initialize', null, 'navigation');
					this.initialize();
					this.update();
					this.draw();
					this._initialized = true;
					this._core.trigger('initialized', null, 'navigation');
				}
			}, this),
			'refreshed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._initialized) {
					this._core.trigger('refresh', null, 'navigation');
					this.update();
					this.draw();
					this._core.trigger('refreshed', null, 'navigation');
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

		// register event handlers
		this.$element.on(this._handlers);
	};

	/**
	 * Default options.
	 * @public
	 * @todo Rename `slideBy` to `navBy`
	 */
	Navigation.Defaults = {
		nav: false,
		navText: [ 'prev', 'next' ],
		navSpeed: false,
		navElement: 'div',
		navContainer: false,
		navContainerClass: 'owl-nav',
		navClass: [ 'owl-prev', 'owl-next' ],
		slideBy: 1,
		dotClass: 'owl-dot',
		dotsClass: 'owl-dots',
		dots: true,
		dotsEach: false,
		dotsData: false,
		dotsSpeed: false,
		dotsContainer: false
	};

	/**
	 * Initializes the layout of the plugin and extends the carousel.
	 * @protected
	 */
	Navigation.prototype.initialize = function() {
		var override,
			settings = this._core.settings;

		// create DOM structure for relative navigation
		this._controls.$relative = (settings.navContainer ? $(settings.navContainer)
			: $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

		this._controls.$previous = $('<' + settings.navElement + '>')
			.addClass(settings.navClass[0])
			.html(settings.navText[0])
			.prependTo(this._controls.$relative)
			.on('click', $.proxy(function(e) {
				this.prev(settings.navSpeed);
			}, this));
		this._controls.$next = $('<' + settings.navElement + '>')
			.addClass(settings.navClass[1])
			.html(settings.navText[1])
			.appendTo(this._controls.$relative)
			.on('click', $.proxy(function(e) {
				this.next(settings.navSpeed);
			}, this));

		// create DOM structure for absolute navigation
		if (!settings.dotsData) {
			this._templates = [ $('<div>')
				.addClass(settings.dotClass)
				.append($('<span>'))
				.prop('outerHTML') ];
		}

		this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer)
			: $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

		this._controls.$absolute.on('click', 'div', $.proxy(function(e) {
			var index = $(e.target).parent().is(this._controls.$absolute)
				? $(e.target).index() : $(e.target).parent().index();

			e.preventDefault();

			this.to(index, settings.dotsSpeed);
		}, this));

		// override public methods of the carousel
		for (override in this._overrides) {
			this._core[override] = $.proxy(this[override], this);
		}
	};

	/**
	 * Destroys the plugin.
	 * @protected
	 */
	Navigation.prototype.destroy = function() {
		var handler, control, property, override;

		for (handler in this._handlers) {
			this.$element.off(handler, this._handlers[handler]);
		}
		for (control in this._controls) {
			this._controls[control].remove();
		}
		for (override in this.overides) {
			this._core[override] = this._overrides[override];
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	/**
	 * Updates the internal state.
	 * @protected
	 */
	Navigation.prototype.update = function() {
		var i, j, k,
			lower = this._core.clones().length / 2,
			upper = lower + this._core.items().length,
			maximum = this._core.maximum(true),
			settings = this._core.settings,
			size = settings.center || settings.autoWidth || settings.dotsData
				? 1 : settings.dotsEach || settings.items;

		if (settings.slideBy !== 'page') {
			settings.slideBy = Math.min(settings.slideBy, settings.items);
		}

		if (settings.dots || settings.slideBy == 'page') {
			this._pages = [];

			for (i = lower, j = 0, k = 0; i < upper; i++) {
				if (j >= size || j === 0) {
					this._pages.push({
						start: Math.min(maximum, i - lower),
						end: i - lower + size - 1
					});
					if (Math.min(maximum, i - lower) === maximum) {
						break;
					}
					j = 0, ++k;
				}
				j += this._core.mergers(this._core.relative(i));
			}
		}
	};

	/**
	 * Draws the user interface.
	 * @todo The option `dotsData` wont work.
	 * @protected
	 */
	Navigation.prototype.draw = function() {
		var difference,
			settings = this._core.settings,
			disabled = this._core.items().length <= settings.items,
			index = this._core.relative(this._core.current()),
			loop = settings.loop || settings.rewind;

		this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

		if (settings.nav) {
			this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
			this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
		}

		this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

		if (settings.dots) {
			difference = this._pages.length - this._controls.$absolute.children().length;

			if (settings.dotsData && difference !== 0) {
				this._controls.$absolute.html(this._templates.join(''));
			} else if (difference > 0) {
				this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
			} else if (difference < 0) {
				this._controls.$absolute.children().slice(difference).remove();
			}

			this._controls.$absolute.find('.active').removeClass('active');
			this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
		}
	};

	/**
	 * Extends event data.
	 * @protected
	 * @param {Event} event - The event object which gets thrown.
	 */
	Navigation.prototype.onTrigger = function(event) {
		var settings = this._core.settings;

		event.page = {
			index: $.inArray(this.current(), this._pages),
			count: this._pages.length,
			size: settings && (settings.center || settings.autoWidth || settings.dotsData
				? 1 : settings.dotsEach || settings.items)
		};
	};

	/**
	 * Gets the current page position of the carousel.
	 * @protected
	 * @returns {Number}
	 */
	Navigation.prototype.current = function() {
		var current = this._core.relative(this._core.current());
		return $.grep(this._pages, $.proxy(function(page, index) {
			return page.start <= current && page.end >= current;
		}, this)).pop();
	};

	/**
	 * Gets the current succesor/predecessor position.
	 * @protected
	 * @returns {Number}
	 */
	Navigation.prototype.getPosition = function(successor) {
		var position, length,
			settings = this._core.settings;

		if (settings.slideBy == 'page') {
			position = $.inArray(this.current(), this._pages);
			length = this._pages.length;
			successor ? ++position : --position;
			position = this._pages[((position % length) + length) % length].start;
		} else {
			position = this._core.relative(this._core.current());
			length = this._core.items().length;
			successor ? position += settings.slideBy : position -= settings.slideBy;
		}

		return position;
	};

	/**
	 * Slides to the next item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
	Navigation.prototype.next = function(speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
	};

	/**
	 * Slides to the previous item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
	Navigation.prototype.prev = function(speed) {
		$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
	};

	/**
	 * Slides to the specified item or page.
	 * @public
	 * @param {Number} position - The position of the item or page.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
	 */
	Navigation.prototype.to = function(position, speed, standard) {
		var length;

		if (!standard && this._pages.length) {
			length = this._pages.length;
			$.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
		} else {
			$.proxy(this._overrides.to, this._core)(position, speed);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

})(window.Zepto || window.jQuery, window, document);

/**
 * Hash Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
	'use strict';

	/**
	 * Creates the hash plugin.
	 * @class The Hash Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
	var Hash = function(carousel) {
		/**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
		this._core = carousel;

		/**
		 * Hash index for the items.
		 * @protected
		 * @type {Object}
		 */
		this._hashes = {};

		/**
		 * The carousel element.
		 * @type {jQuery}
		 */
		this.$element = this._core.$element;

		/**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
		this._handlers = {
			'initialized.owl.carousel': $.proxy(function(e) {
				if (e.namespace && this._core.settings.startPosition === 'URLHash') {
					$(window).trigger('hashchange.owl.navigation');
				}
			}, this),
			'prepared.owl.carousel': $.proxy(function(e) {
				if (e.namespace) {
					var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

					if (!hash) {
						return;
					}

					this._hashes[hash] = e.content;
				}
			}, this),
			'changed.owl.carousel': $.proxy(function(e) {
				if (e.namespace && e.property.name === 'position') {
					var current = this._core.items(this._core.relative(this._core.current())),
						hash = $.map(this._hashes, function(item, hash) {
							return item === current ? hash : null;
						}).join();

					if (!hash || window.location.hash.slice(1) === hash) {
						return;
					}

					window.location.hash = hash;
				}
			}, this)
		};

		// set default options
		this._core.options = $.extend({}, Hash.Defaults, this._core.options);

		// register the event handlers
		this.$element.on(this._handlers);

		// register event listener for hash navigation
		$(window).on('hashchange.owl.navigation', $.proxy(function(e) {
			var hash = window.location.hash.substring(1),
				items = this._core.$stage.children(),
				position = this._hashes[hash] && items.index(this._hashes[hash]);

			if (position === undefined || position === this._core.current()) {
				return;
			}

			this._core.to(this._core.relative(position), false, true);
		}, this));
	};

	/**
	 * Default options.
	 * @public
	 */
	Hash.Defaults = {
		URLhashListener: false
	};

	/**
	 * Destroys the plugin.
	 * @public
	 */
	Hash.prototype.destroy = function() {
		var handler, property;

		$(window).off('hashchange.owl.navigation');

		for (handler in this._handlers) {
			this._core.$element.off(handler, this._handlers[handler]);
		}
		for (property in Object.getOwnPropertyNames(this)) {
			typeof this[property] != 'function' && (this[property] = null);
		}
	};

	$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

})(window.Zepto || window.jQuery, window, document);

/**
 * Support Plugin
 *
 * @version 2.1.0
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

	var style = $('<support>').get(0).style,
		prefixes = 'Webkit Moz O ms'.split(' '),
		events = {
			transition: {
				end: {
					WebkitTransition: 'webkitTransitionEnd',
					MozTransition: 'transitionend',
					OTransition: 'oTransitionEnd',
					transition: 'transitionend'
				}
			},
			animation: {
				end: {
					WebkitAnimation: 'webkitAnimationEnd',
					MozAnimation: 'animationend',
					OAnimation: 'oAnimationEnd',
					animation: 'animationend'
				}
			}
		},
		tests = {
			csstransforms: function() {
				return !!test('transform');
			},
			csstransforms3d: function() {
				return !!test('perspective');
			},
			csstransitions: function() {
				return !!test('transition');
			},
			cssanimations: function() {
				return !!test('animation');
			}
		};

	function test(property, prefixed) {
		var result = false,
			upper = property.charAt(0).toUpperCase() + property.slice(1);

		$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
			if (style[property] !== undefined) {
				result = prefixed ? property : true;
				return false;
			}
		});

		return result;
	}

	function prefixed(property) {
		return test(property, true);
	}

	if (tests.csstransitions()) {
		/* jshint -W053 */
		$.support.transition = new String(prefixed('transition'))
		$.support.transition.end = events.transition.end[ $.support.transition ];
	}

	if (tests.cssanimations()) {
		/* jshint -W053 */
		$.support.animation = new String(prefixed('animation'))
		$.support.animation.end = events.animation.end[ $.support.animation ];
	}

	if (tests.csstransforms()) {
		/* jshint -W053 */
		$.support.transform = new String(prefixed('transform'));
		$.support.transform3d = tests.csstransforms3d();
	}

})(window.Zepto || window.jQuery, window, document);

var tcomHpCarouselTransitionEffects = {animateIn:'', animateOut:''}; 
// https://github.com/topojson/topojson-client v3.1.0 Copyright 2019 Mike Bostock
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
        (global = global || self, factory(global.topojson = global.topojson || {}));
}(this, function(exports) {
    'use strict';

    function identity(x) {
        return x;
    }

    function transform(transform) {
        if (transform == null) return identity;
        var x0,
            y0,
            kx = transform.scale[0],
            ky = transform.scale[1],
            dx = transform.translate[0],
            dy = transform.translate[1];
        return function(input, i) {
            if (!i) x0 = y0 = 0;
            var j = 2,
                n = input.length,
                output = new Array(n);
            output[0] = (x0 += input[0]) * kx + dx;
            output[1] = (y0 += input[1]) * ky + dy;
            while (j < n) output[j] = input[j], ++j;
            return output;
        };
    }

    function bbox(topology) {
        var t = transform(topology.transform),
            key,
            x0 = Infinity,
            y0 = x0,
            x1 = -x0,
            y1 = -x0;

        function bboxPoint(p) {
            p = t(p);
            if (p[0] < x0) x0 = p[0];
            if (p[0] > x1) x1 = p[0];
            if (p[1] < y0) y0 = p[1];
            if (p[1] > y1) y1 = p[1];
        }

        function bboxGeometry(o) {
            switch (o.type) {
                case "GeometryCollection":
                    o.geometries.forEach(bboxGeometry);
                    break;
                case "Point":
                    bboxPoint(o.coordinates);
                    break;
                case "MultiPoint":
                    o.coordinates.forEach(bboxPoint);
                    break;
            }
        }

        topology.arcs.forEach(function(arc) {
            var i = -1,
                n = arc.length,
                p;
            while (++i < n) {
                p = t(arc[i], i);
                if (p[0] < x0) x0 = p[0];
                if (p[0] > x1) x1 = p[0];
                if (p[1] < y0) y0 = p[1];
                if (p[1] > y1) y1 = p[1];
            }
        });

        for (key in topology.objects) {
            bboxGeometry(topology.objects[key]);
        }

        return [x0, y0, x1, y1];
    }

    function reverse(array, n) {
        var t, j = array.length,
            i = j - n;
        while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
    }

    function feature(topology, o) {
        if (typeof o === "string") o = topology.objects[o];
        return o.type === "GeometryCollection" ?
            { type: "FeatureCollection", features: o.geometries.map(function(o) { return feature$1(topology, o); }) } :
            feature$1(topology, o);
    }

    function feature$1(topology, o) {
        var id = o.id,
            bbox = o.bbox,
            properties = o.properties == null ? {} : o.properties,
            geometry = object(topology, o);
        return id == null && bbox == null ? { type: "Feature", properties: properties, geometry: geometry } :
            bbox == null ? { type: "Feature", id: id, properties: properties, geometry: geometry } :
            { type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry };
    }

    function object(topology, o) {
        var transformPoint = transform(topology.transform),
            arcs = topology.arcs;

        function arc(i, points) {
            if (points.length) points.pop();
            for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
                points.push(transformPoint(a[k], k));
            }
            if (i < 0) reverse(points, n);
        }

        function point(p) {
            return transformPoint(p);
        }

        function line(arcs) {
            var points = [];
            for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
            if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
            return points;
        }

        function ring(arcs) {
            var points = line(arcs);
            while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
            return points;
        }

        function polygon(arcs) {
            return arcs.map(ring);
        }

        function geometry(o) {
            var type = o.type,
                coordinates;
            switch (type) {
                case "GeometryCollection":
                    return { type: type, geometries: o.geometries.map(geometry) };
                case "Point":
                    coordinates = point(o.coordinates);
                    break;
                case "MultiPoint":
                    coordinates = o.coordinates.map(point);
                    break;
                case "LineString":
                    coordinates = line(o.arcs);
                    break;
                case "MultiLineString":
                    coordinates = o.arcs.map(line);
                    break;
                case "Polygon":
                    coordinates = polygon(o.arcs);
                    break;
                case "MultiPolygon":
                    coordinates = o.arcs.map(polygon);
                    break;
                default:
                    return null;
            }
            return { type: type, coordinates: coordinates };
        }

        return geometry(o);
    }

    function stitch(topology, arcs) {
        var stitchedArcs = {},
            fragmentByStart = {},
            fragmentByEnd = {},
            fragments = [],
            emptyIndex = -1;

        // Stitch empty arcs first, since they may be subsumed by other arcs.
        arcs.forEach(function(i, j) {
            var arc = topology.arcs[i < 0 ? ~i : i],
                t;
            if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
                t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
            }
        });

        arcs.forEach(function(i) {
            var e = ends(i),
                start = e[0],
                end = e[1],
                f, g;

            if (f = fragmentByEnd[start]) {
                delete fragmentByEnd[f.end];
                f.push(i);
                f.end = end;
                if (g = fragmentByStart[end]) {
                    delete fragmentByStart[g.start];
                    var fg = g === f ? f : f.concat(g);
                    fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
                } else {
                    fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
                }
            } else if (f = fragmentByStart[end]) {
                delete fragmentByStart[f.start];
                f.unshift(i);
                f.start = start;
                if (g = fragmentByEnd[start]) {
                    delete fragmentByEnd[g.end];
                    var gf = g === f ? f : g.concat(f);
                    fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
                } else {
                    fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
                }
            } else {
                f = [i];
                fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
            }
        });

        function ends(i) {
            var arc = topology.arcs[i < 0 ? ~i : i],
                p0 = arc[0],
                p1;
            if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
            else p1 = arc[arc.length - 1];
            return i < 0 ? [p1, p0] : [p0, p1];
        }

        function flush(fragmentByEnd, fragmentByStart) {
            for (var k in fragmentByEnd) {
                var f = fragmentByEnd[k];
                delete fragmentByStart[f.start];
                delete f.start;
                delete f.end;
                f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
                fragments.push(f);
            }
        }

        flush(fragmentByEnd, fragmentByStart);
        flush(fragmentByStart, fragmentByEnd);
        arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

        return fragments;
    }

    function mesh(topology) {
        return object(topology, meshArcs.apply(this, arguments));
    }

    function meshArcs(topology, object, filter) {
        var arcs, i, n;
        if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
        else
            for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
        return { type: "MultiLineString", arcs: stitch(topology, arcs) };
    }

    function extractArcs(topology, object, filter) {
        var arcs = [],
            geomsByArc = [],
            geom;

        function extract0(i) {
            var j = i < 0 ? ~i : i;
            (geomsByArc[j] || (geomsByArc[j] = [])).push({ i: i, g: geom });
        }

        function extract1(arcs) {
            arcs.forEach(extract0);
        }

        function extract2(arcs) {
            arcs.forEach(extract1);
        }

        function extract3(arcs) {
            arcs.forEach(extract2);
        }

        function geometry(o) {
            switch (geom = o, o.type) {
                case "GeometryCollection":
                    o.geometries.forEach(geometry);
                    break;
                case "LineString":
                    extract1(o.arcs);
                    break;
                case "MultiLineString":
                case "Polygon":
                    extract2(o.arcs);
                    break;
                case "MultiPolygon":
                    extract3(o.arcs);
                    break;
            }
        }

        geometry(object);

        geomsByArc.forEach(filter == null ?
            function(geoms) { arcs.push(geoms[0].i); } :
            function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

        return arcs;
    }

    function planarRingArea(ring) {
        var i = -1,
            n = ring.length,
            a, b = ring[n - 1],
            area = 0;
        while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
        return Math.abs(area); // Note: doubled area!
    }

    function merge(topology) {
        return object(topology, mergeArcs.apply(this, arguments));
    }

    function mergeArcs(topology, objects) {
        var polygonsByArc = {},
            polygons = [],
            groups = [];

        objects.forEach(geometry);

        function geometry(o) {
            switch (o.type) {
                case "GeometryCollection":
                    o.geometries.forEach(geometry);
                    break;
                case "Polygon":
                    extract(o.arcs);
                    break;
                case "MultiPolygon":
                    o.arcs.forEach(extract);
                    break;
            }
        }

        function extract(polygon) {
            polygon.forEach(function(ring) {
                ring.forEach(function(arc) {
                    (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
                });
            });
            polygons.push(polygon);
        }

        function area(ring) {
            return planarRingArea(object(topology, { type: "Polygon", arcs: [ring] }).coordinates[0]);
        }

        polygons.forEach(function(polygon) {
            if (!polygon._) {
                var group = [],
                    neighbors = [polygon];
                polygon._ = 1;
                groups.push(group);
                while (polygon = neighbors.pop()) {
                    group.push(polygon);
                    polygon.forEach(function(ring) {
                        ring.forEach(function(arc) {
                            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
                                if (!polygon._) {
                                    polygon._ = 1;
                                    neighbors.push(polygon);
                                }
                            });
                        });
                    });
                }
            }
        });

        polygons.forEach(function(polygon) {
            delete polygon._;
        });

        return {
            type: "MultiPolygon",
            arcs: groups.map(function(polygons) {
                var arcs = [],
                    n;

                // Extract the exterior (unique) arcs.
                polygons.forEach(function(polygon) {
                    polygon.forEach(function(ring) {
                        ring.forEach(function(arc) {
                            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                                arcs.push(arc);
                            }
                        });
                    });
                });

                // Stitch the arcs into one or more rings.
                arcs = stitch(topology, arcs);

                // If more than one ring is returned,
                // at most one of these rings can be the exterior;
                // choose the one with the greatest absolute area.
                if ((n = arcs.length) > 1) {
                    for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
                        if ((ki = area(arcs[i])) > k) {
                            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
                        }
                    }
                }

                return arcs;
            }).filter(function(arcs) {
                return arcs.length > 0;
            })
        };
    }

    function bisect(a, x) {
        var lo = 0,
            hi = a.length;
        while (lo < hi) {
            var mid = lo + hi >>> 1;
            if (a[mid] < x) lo = mid + 1;
            else hi = mid;
        }
        return lo;
    }

    function neighbors(objects) {
        var indexesByArc = {}, // arc index -> array of object indexes
            neighbors = objects.map(function() { return []; });

        function line(arcs, i) {
            arcs.forEach(function(a) {
                if (a < 0) a = ~a;
                var o = indexesByArc[a];
                if (o) o.push(i);
                else indexesByArc[a] = [i];
            });
        }

        function polygon(arcs, i) {
            arcs.forEach(function(arc) { line(arc, i); });
        }

        function geometry(o, i) {
            if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
            else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
        }

        var geometryType = {
            LineString: line,
            MultiLineString: polygon,
            Polygon: polygon,
            MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
        };

        objects.forEach(geometry);

        for (var i in indexesByArc) {
            for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
                for (var k = j + 1; k < m; ++k) {
                    var ij = indexes[j],
                        ik = indexes[k],
                        n;
                    if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
                    if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
                }
            }
        }

        return neighbors;
    }

    function untransform(transform) {
        if (transform == null) return identity;
        var x0,
            y0,
            kx = transform.scale[0],
            ky = transform.scale[1],
            dx = transform.translate[0],
            dy = transform.translate[1];
        return function(input, i) {
            if (!i) x0 = y0 = 0;
            var j = 2,
                n = input.length,
                output = new Array(n),
                x1 = Math.round((input[0] - dx) / kx),
                y1 = Math.round((input[1] - dy) / ky);
            output[0] = x1 - x0, x0 = x1;
            output[1] = y1 - y0, y0 = y1;
            while (j < n) output[j] = input[j], ++j;
            return output;
        };
    }

    function quantize(topology, transform) {
        if (topology.transform) throw new Error("already quantized");

        if (!transform || !transform.scale) {
            if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be ≥2");
            box = topology.bbox || bbox(topology);
            var x0 = box[0],
                y0 = box[1],
                x1 = box[2],
                y1 = box[3],
                n;
            transform = { scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0] };
        } else {
            box = topology.bbox;
        }

        var t = untransform(transform),
            box, key, inputs = topology.objects,
            outputs = {};

        function quantizePoint(point) {
            return t(point);
        }

        function quantizeGeometry(input) {
            var output;
            switch (input.type) {
                case "GeometryCollection":
                    output = { type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry) };
                    break;
                case "Point":
                    output = { type: "Point", coordinates: quantizePoint(input.coordinates) };
                    break;
                case "MultiPoint":
                    output = { type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint) };
                    break;
                default:
                    return input;
            }
            if (input.id != null) output.id = input.id;
            if (input.bbox != null) output.bbox = input.bbox;
            if (input.properties != null) output.properties = input.properties;
            return output;
        }

        function quantizeArc(input) {
            var i = 0,
                j = 1,
                n = input.length,
                p, output = new Array(n); // pessimistic
            output[0] = t(input[0], 0);
            while (++i < n)
                if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
            if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
            output.length = j;
            return output;
        }

        for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

        return {
            type: "Topology",
            bbox: box,
            transform: transform,
            objects: outputs,
            arcs: topology.arcs.map(quantizeArc)
        };
    }

    exports.bbox = bbox;
    exports.feature = feature;
    exports.merge = merge;
    exports.mergeArcs = mergeArcs;
    exports.mesh = mesh;
    exports.meshArcs = meshArcs;
    exports.neighbors = neighbors;
    exports.quantize = quantize;
    exports.transform = transform;
    exports.untransform = untransform;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
// https://d3js.org/d3-array/ v2.7.1 Copyright 2020 Mike Bostock
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        typeof define === 'function' && define.amd ? define(['exports'], factory) :
        (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.d3 = global.d3 || {}));
}(this, (function(exports) {
    'use strict';

    function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector(f) {
        let delta = f;
        let compare = f;

        if (f.length === 1) {
            delta = (d, x) => f(d) - x;
            compare = ascendingComparator(f);
        }

        function left(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
                const mid = (lo + hi) >>> 1;
                if (compare(a[mid], x) < 0) lo = mid + 1;
                else hi = mid;
            }
            return lo;
        }

        function right(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            while (lo < hi) {
                const mid = (lo + hi) >>> 1;
                if (compare(a[mid], x) > 0) hi = mid;
                else lo = mid + 1;
            }
            return lo;
        }

        function center(a, x, lo, hi) {
            if (lo == null) lo = 0;
            if (hi == null) hi = a.length;
            const i = left(a, x, lo, hi - 1);
            return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
        }

        return { left, center, right };
    }

    function ascendingComparator(f) {
        return (d, x) => ascending(f(d), x);
    }

    function number(x) {
        return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
        if (valueof === undefined) {
            for (let value of values) {
                if (value != null && (value = +value) >= value) {
                    yield value;
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                    yield value;
                }
            }
        }
    }

    const ascendingBisect = bisector(ascending);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number).center;

    function count(values, valueof) {
        let count = 0;
        if (valueof === undefined) {
            for (let value of values) {
                if (value != null && (value = +value) >= value) {
                    ++count;
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                    ++count;
                }
            }
        }
        return count;
    }

    function length(array) {
        return array.length | 0;
    }

    function empty(length) {
        return !(length > 0);
    }

    function arrayify(values) {
        return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
        return values => reduce(...values);
    }

    function cross(...values) {
        const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
        values = values.map(arrayify);
        const lengths = values.map(length);
        const j = values.length - 1;
        const index = new Array(j + 1).fill(0);
        const product = [];
        if (j < 0 || lengths.some(empty)) return product;
        while (true) {
            product.push(index.map((j, i) => values[i][j]));
            let i = j;
            while (++index[i] === lengths[i]) {
                if (i === 0) return reduce ? product.map(reduce) : product;
                index[i--] = 0;
            }
        }
    }

    function cumsum(values, valueof) {
        var sum = 0,
            index = 0;
        return Float64Array.from(values, valueof === undefined ?
            v => (sum += +v || 0) :
            v => (sum += +valueof(v, index++, values) || 0));
    }

    function descending(a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function variance(values, valueof) {
        let count = 0;
        let delta;
        let mean = 0;
        let sum = 0;
        if (valueof === undefined) {
            for (let value of values) {
                if (value != null && (value = +value) >= value) {
                    delta = value - mean;
                    mean += delta / ++count;
                    sum += delta * (value - mean);
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                    delta = value - mean;
                    mean += delta / ++count;
                    sum += delta * (value - mean);
                }
            }
        }
        if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
        const v = variance(values, valueof);
        return v ? Math.sqrt(v) : v;
    }

    function extent(values, valueof) {
        let min;
        let max;
        if (valueof === undefined) {
            for (const value of values) {
                if (value != null) {
                    if (min === undefined) {
                        if (value >= value) min = max = value;
                    } else {
                        if (min > value) min = value;
                        if (max < value) max = value;
                    }
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null) {
                    if (min === undefined) {
                        if (value >= value) min = max = value;
                    } else {
                        if (min > value) min = value;
                        if (max < value) max = value;
                    }
                }
            }
        }
        return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
        constructor() {
            this._partials = new Float64Array(32);
            this._n = 0;
        }
        add(x) {
            const p = this._partials;
            let i = 0;
            for (let j = 0; j < this._n && j < 32; j++) {
                const y = p[j],
                    hi = x + y,
                    lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
                if (lo) p[i++] = lo;
                x = hi;
            }
            p[i] = x;
            this._n = i + 1;
            return this;
        }
        valueOf() {
            const p = this._partials;
            let n = this._n,
                x, y, lo, hi = 0;
            if (n > 0) {
                hi = p[--n];
                while (n > 0) {
                    x = hi;
                    y = p[--n];
                    hi = x + y;
                    lo = y - (hi - x);
                    if (lo) break;
                }
                if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
                    y = lo * 2;
                    x = hi + y;
                    if (y == x - hi) hi = x;
                }
            }
            return hi;
        }
    }

    function fsum(values, valueof) {
        const adder = new Adder();
        if (valueof === undefined) {
            for (let value of values) {
                if (value = +value) {
                    adder.add(value);
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if (value = +valueof(value, ++index, values)) {
                    adder.add(value);
                }
            }
        }
        return +adder;
    }

    function identity(x) {
        return x;
    }

    function group(values, ...keys) {
        return nest(values, identity, identity, keys);
    }

    function groups(values, ...keys) {
        return nest(values, Array.from, identity, keys);
    }

    function rollup(values, reduce, ...keys) {
        return nest(values, identity, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
        return nest(values, Array.from, reduce, keys);
    }

    function index(values, ...keys) {
        return nest(values, identity, unique, keys);
    }

    function indexes(values, ...keys) {
        return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
        if (values.length !== 1) throw new Error("duplicate key");
        return values[0];
    }

    function nest(values, map, reduce, keys) {
        return (function regroup(values, i) {
            if (i >= keys.length) return reduce(values);
            const groups = new Map();
            const keyof = keys[i++];
            let index = -1;
            for (const value of values) {
                const key = keyof(value, ++index, values);
                const group = groups.get(key);
                if (group) group.push(value);
                else groups.set(key, [value]);
            }
            for (const [key, values] of groups) {
                groups.set(key, regroup(values, i));
            }
            return map(groups);
        })(values, 0);
    }

    var array = Array.prototype;

    var slice = array.slice;

    function constant(x) {
        return function() {
            return x;
        };
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
        var reverse,
            i = -1,
            n,
            ticks,
            step;

        stop = +stop, start = +start, count = +count;
        if (start === stop && count > 0) return [start];
        if (reverse = stop < start) n = start, start = stop, stop = n;
        if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

        if (step > 0) {
            start = Math.ceil(start / step);
            stop = Math.floor(stop / step);
            ticks = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n) ticks[i] = (start + i) * step;
        } else {
            step = -step;
            start = Math.ceil(start * step);
            stop = Math.floor(stop * step);
            ticks = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n) ticks[i] = (start + i) / step;
        }

        if (reverse) ticks.reverse();

        return ticks;
    }

    function tickIncrement(start, stop, count) {
        var step = (stop - start) / Math.max(0, count),
            power = Math.floor(Math.log(step) / Math.LN10),
            error = step / Math.pow(10, power);
        return power >= 0 ?
            (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) :
            -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count),
            step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
            error = step0 / step1;
        if (error >= e10) step1 *= 10;
        else if (error >= e5) step1 *= 5;
        else if (error >= e2) step1 *= 2;
        return stop < start ? -step1 : step1;
    }

    function sturges(values) {
        return Math.ceil(Math.log(count(values)) / Math.LN2) + 1;
    }

    function bin() {
        var value = identity,
            domain = extent,
            threshold = sturges;

        function histogram(data) {
            if (!Array.isArray(data)) data = Array.from(data);

            var i,
                n = data.length,
                x,
                values = new Array(n);

            for (i = 0; i < n; ++i) {
                values[i] = value(data[i], i, data);
            }

            var xz = domain(values),
                x0 = xz[0],
                x1 = xz[1],
                tz = threshold(values, x0, x1);

            // Convert number of thresholds into uniform thresholds.
            if (!Array.isArray(tz)) {
                tz = ticks(x0, x1, tz);
                if (tz[tz.length - 1] === x1) tz.pop(); // exclusive
            }

            // Remove any thresholds outside the domain.
            var m = tz.length;
            while (tz[0] <= x0) tz.shift(), --m;
            while (tz[m - 1] > x1) tz.pop(), --m;

            var bins = new Array(m + 1),
                bin;

            // Initialize bins.
            for (i = 0; i <= m; ++i) {
                bin = bins[i] = [];
                bin.x0 = i > 0 ? tz[i - 1] : x0;
                bin.x1 = i < m ? tz[i] : x1;
            }

            // Assign data to bins by value, ignoring any outside the domain.
            for (i = 0; i < n; ++i) {
                x = values[i];
                if (x0 <= x && x <= x1) {
                    bins[bisectRight(tz, x, 0, m)].push(data[i]);
                }
            }

            return bins;
        }

        histogram.value = function(_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
        };

        histogram.domain = function(_) {
            return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
        };

        histogram.thresholds = function(_) {
            return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
        };

        return histogram;
    }

    function max(values, valueof) {
        let max;
        if (valueof === undefined) {
            for (const value of values) {
                if (value != null &&
                    (max < value || (max === undefined && value >= value))) {
                    max = value;
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null &&
                    (max < value || (max === undefined && value >= value))) {
                    max = value;
                }
            }
        }
        return max;
    }

    function min(values, valueof) {
        let min;
        if (valueof === undefined) {
            for (const value of values) {
                if (value != null &&
                    (min > value || (min === undefined && value >= value))) {
                    min = value;
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null &&
                    (min > value || (min === undefined && value >= value))) {
                    min = value;
                }
            }
        }
        return min;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare = ascending) {
        while (right > left) {
            if (right - left > 600) {
                const n = right - left + 1;
                const m = k - left + 1;
                const z = Math.log(n);
                const s = 0.5 * Math.exp(2 * z / 3);
                const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
                const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
                const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
                quickselect(array, k, newLeft, newRight, compare);
            }

            const t = array[k];
            let i = left;
            let j = right;

            swap(array, left, k);
            if (compare(array[right], t) > 0) swap(array, left, right);

            while (i < j) {
                swap(array, i, j), ++i, --j;
                while (compare(array[i], t) < 0) ++i;
                while (compare(array[j], t) > 0) --j;
            }

            if (compare(array[left], t) === 0) swap(array, left, j);
            else ++j, swap(array, j, right);

            if (j <= k) left = j + 1;
            if (k <= j) right = j - 1;
        }
        return array;
    }

    function swap(array, i, j) {
        const t = array[i];
        array[i] = array[j];
        array[j] = t;
    }

    function quantile(values, p, valueof) {
        values = Float64Array.from(numbers(values, valueof));
        if (!(n = values.length)) return;
        if ((p = +p) <= 0 || n < 2) return min(values);
        if (p >= 1) return max(values);
        var n,
            i = (n - 1) * p,
            i0 = Math.floor(i),
            value0 = max(quickselect(values, i0).subarray(0, i0 + 1)),
            value1 = min(values.subarray(i0 + 1));
        return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number) {
        if (!(n = values.length)) return;
        if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
        if (p >= 1) return +valueof(values[n - 1], n - 1, values);
        var n,
            i = (n - 1) * p,
            i0 = Math.floor(i),
            value0 = +valueof(values[i0], i0, values),
            value1 = +valueof(values[i0 + 1], i0 + 1, values);
        return value0 + (value1 - value0) * (i - i0);
    }

    function freedmanDiaconis(values, min, max) {
        return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(count(values), -1 / 3)));
    }

    function scott(values, min, max) {
        return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(count(values), -1 / 3)));
    }

    function maxIndex(values, valueof) {
        let max;
        let maxIndex = -1;
        let index = -1;
        if (valueof === undefined) {
            for (const value of values) {
                ++index;
                if (value != null &&
                    (max < value || (max === undefined && value >= value))) {
                    max = value, maxIndex = index;
                }
            }
        } else {
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null &&
                    (max < value || (max === undefined && value >= value))) {
                    max = value, maxIndex = index;
                }
            }
        }
        return maxIndex;
    }

    function mean(values, valueof) {
        let count = 0;
        let sum = 0;
        if (valueof === undefined) {
            for (let value of values) {
                if (value != null && (value = +value) >= value) {
                    ++count, sum += value;
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
                    ++count, sum += value;
                }
            }
        }
        if (count) return sum / count;
    }

    function median(values, valueof) {
        return quantile(values, 0.5, valueof);
    }

    function* flatten(arrays) {
        for (const array of arrays) {
            yield* array;
        }
    }

    function merge(arrays) {
        return Array.from(flatten(arrays));
    }

    function minIndex(values, valueof) {
        let min;
        let minIndex = -1;
        let index = -1;
        if (valueof === undefined) {
            for (const value of values) {
                ++index;
                if (value != null &&
                    (min > value || (min === undefined && value >= value))) {
                    min = value, minIndex = index;
                }
            }
        } else {
            for (let value of values) {
                if ((value = valueof(value, ++index, values)) != null &&
                    (min > value || (min === undefined && value >= value))) {
                    min = value, minIndex = index;
                }
            }
        }
        return minIndex;
    }

    function pairs(values, pairof = pair) {
        const pairs = [];
        let previous;
        let first = false;
        for (const value of values) {
            if (first) pairs.push(pairof(previous, value));
            previous = value;
            first = true;
        }
        return pairs;
    }

    function pair(a, b) {
        return [a, b];
    }

    function permute(source, keys) {
        return Array.from(keys, key => source[key]);
    }

    function range(start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

        var i = -1,
            n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
            range = new Array(n);

        while (++i < n) {
            range[i] = start + i * step;
        }

        return range;
    }

    function least(values, compare = ascending) {
        let min;
        let defined = false;
        if (compare.length === 1) {
            let minValue;
            for (const element of values) {
                const value = compare(element);
                if (defined ?
                    ascending(value, minValue) < 0 :
                    ascending(value, value) === 0) {
                    min = element;
                    minValue = value;
                    defined = true;
                }
            }
        } else {
            for (const value of values) {
                if (defined ?
                    compare(value, min) < 0 :
                    compare(value, value) === 0) {
                    min = value;
                    defined = true;
                }
            }
        }
        return min;
    }

    function leastIndex(values, compare = ascending) {
        if (compare.length === 1) return minIndex(values, compare);
        let minValue;
        let min = -1;
        let index = -1;
        for (const value of values) {
            ++index;
            if (min < 0 ?
                compare(value, value) === 0 :
                compare(value, minValue) < 0) {
                minValue = value;
                min = index;
            }
        }
        return min;
    }

    function greatest(values, compare = ascending) {
        let max;
        let defined = false;
        if (compare.length === 1) {
            let maxValue;
            for (const element of values) {
                const value = compare(element);
                if (defined ?
                    ascending(value, maxValue) > 0 :
                    ascending(value, value) === 0) {
                    max = element;
                    maxValue = value;
                    defined = true;
                }
            }
        } else {
            for (const value of values) {
                if (defined ?
                    compare(value, max) > 0 :
                    compare(value, value) === 0) {
                    max = value;
                    defined = true;
                }
            }
        }
        return max;
    }

    function greatestIndex(values, compare = ascending) {
        if (compare.length === 1) return maxIndex(values, compare);
        let maxValue;
        let max = -1;
        let index = -1;
        for (const value of values) {
            ++index;
            if (max < 0 ?
                compare(value, value) === 0 :
                compare(value, maxValue) > 0) {
                maxValue = value;
                max = index;
            }
        }
        return max;
    }

    function scan(values, compare) {
        const index = leastIndex(values, compare);
        return index < 0 ? undefined : index;
    }

    var shuffle = shuffler(Math.random);

    function shuffler(random) {
        return function shuffle(array, i0 = 0, i1 = array.length) {
            let m = i1 - (i0 = +i0);
            while (m) {
                const i = random() * m-- | 0,
                    t = array[m + i0];
                array[m + i0] = array[i + i0];
                array[i + i0] = t;
            }
            return array;
        };
    }

    function sum(values, valueof) {
        let sum = 0;
        if (valueof === undefined) {
            for (let value of values) {
                if (value = +value) {
                    sum += value;
                }
            }
        } else {
            let index = -1;
            for (let value of values) {
                if (value = +valueof(value, ++index, values)) {
                    sum += value;
                }
            }
        }
        return sum;
    }

    function transpose(matrix) {
        if (!(n = matrix.length)) return [];
        for (var i = -1, m = min(matrix, length$1), transpose = new Array(m); ++i < m;) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
                row[j] = matrix[j][i];
            }
        }
        return transpose;
    }

    function length$1(d) {
        return d.length;
    }

    function zip() {
        return transpose(arguments);
    }

    exports.Adder = Adder;
    exports.ascending = ascending;
    exports.bin = bin;
    exports.bisect = bisectRight;
    exports.bisectCenter = bisectCenter;
    exports.bisectLeft = bisectLeft;
    exports.bisectRight = bisectRight;
    exports.bisector = bisector;
    exports.count = count;
    exports.cross = cross;
    exports.cumsum = cumsum;
    exports.descending = descending;
    exports.deviation = deviation;
    exports.extent = extent;
    exports.fsum = fsum;
    exports.greatest = greatest;
    exports.greatestIndex = greatestIndex;
    exports.group = group;
    exports.groups = groups;
    exports.histogram = bin;
    exports.index = index;
    exports.indexes = indexes;
    exports.least = least;
    exports.leastIndex = leastIndex;
    exports.max = max;
    exports.maxIndex = maxIndex;
    exports.mean = mean;
    exports.median = median;
    exports.merge = merge;
    exports.min = min;
    exports.minIndex = minIndex;
    exports.pairs = pairs;
    exports.permute = permute;
    exports.quantile = quantile;
    exports.quantileSorted = quantileSorted;
    exports.quickselect = quickselect;
    exports.range = range;
    exports.rollup = rollup;
    exports.rollups = rollups;
    exports.scan = scan;
    exports.shuffle = shuffle;
    exports.shuffler = shuffler;
    exports.sum = sum;
    exports.thresholdFreedmanDiaconis = freedmanDiaconis;
    exports.thresholdScott = scott;
    exports.thresholdSturges = sturges;
    exports.tickIncrement = tickIncrement;
    exports.tickStep = tickStep;
    exports.ticks = ticks;
    exports.transpose = transpose;
    exports.variance = variance;
    exports.zip = zip;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
// https://d3js.org/d3-geo/ v2.0.1 Copyright 2020 Mike Bostock
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
        typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
        (global = global || self, factory(global.d3 = global.d3 || {}, global.d3));
}(this, function(exports, d3Array) {
    'use strict';

    var epsilon = 1e-6;
    var epsilon2 = 1e-12;
    var pi = Math.PI;
    var halfPi = pi / 2;
    var quarterPi = pi / 4;
    var tau = pi * 2;

    var degrees = 180 / pi;
    var radians = pi / 180;

    var abs = Math.abs;
    var atan = Math.atan;
    var atan2 = Math.atan2;
    var cos = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log = Math.log;
    var pow = Math.pow;
    var sin = Math.sin;
    var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt = Math.sqrt;
    var tan = Math.tan;

    function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
        return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
    }

    function haversin(x) {
        return (x = sin(x / 2)) * x;
    }

    function noop() {}

    function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
            streamGeometryType[geometry.type](geometry, stream);
        }
    }

    var streamObjectType = {
        Feature: function(object, stream) {
            streamGeometry(object.geometry, stream);
        },
        FeatureCollection: function(object, stream) {
            var features = object.features,
                i = -1,
                n = features.length;
            while (++i < n) streamGeometry(features[i].geometry, stream);
        }
    };

    var streamGeometryType = {
        Sphere: function(object, stream) {
            stream.sphere();
        },
        Point: function(object, stream) {
            object = object.coordinates;
            stream.point(object[0], object[1], object[2]);
        },
        MultiPoint: function(object, stream) {
            var coordinates = object.coordinates,
                i = -1,
                n = coordinates.length;
            while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
        },
        LineString: function(object, stream) {
            streamLine(object.coordinates, stream, 0);
        },
        MultiLineString: function(object, stream) {
            var coordinates = object.coordinates,
                i = -1,
                n = coordinates.length;
            while (++i < n) streamLine(coordinates[i], stream, 0);
        },
        Polygon: function(object, stream) {
            streamPolygon(object.coordinates, stream);
        },
        MultiPolygon: function(object, stream) {
            var coordinates = object.coordinates,
                i = -1,
                n = coordinates.length;
            while (++i < n) streamPolygon(coordinates[i], stream);
        },
        GeometryCollection: function(object, stream) {
            var geometries = object.geometries,
                i = -1,
                n = geometries.length;
            while (++i < n) streamGeometry(geometries[i], stream);
        }
    };

    function streamLine(coordinates, stream, closed) {
        var i = -1,
            n = coordinates.length - closed,
            coordinate;
        stream.lineStart();
        while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
        var i = -1,
            n = coordinates.length;
        stream.polygonStart();
        while (++i < n) streamLine(coordinates[i], stream, 1);
        stream.polygonEnd();
    }

    function geoStream(object, stream) {
        if (object && streamObjectType.hasOwnProperty(object.type)) {
            streamObjectType[object.type](object, stream);
        } else {
            streamGeometry(object, stream);
        }
    }

    var areaRingSum = new d3Array.Adder();

    // hello?

    var areaSum = new d3Array.Adder(),
        lambda00,
        phi00,
        lambda0,
        cosPhi0,
        sinPhi0;

    var areaStream = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
            areaRingSum = new d3Array.Adder();
            areaStream.lineStart = areaRingStart;
            areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function() {
            var areaRing = +areaRingSum;
            areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
            this.lineStart = this.lineEnd = this.point = noop;
        },
        sphere: function() {
            areaSum.add(tau);
        }
    };

    function areaRingStart() {
        areaStream.point = areaPointFirst;
    }

    function areaRingEnd() {
        areaPoint(lambda00, phi00);
    }

    function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint;
        lambda00 = lambda, phi00 = phi;
        lambda *= radians, phi *= radians;
        lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
    }

    function areaPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        phi = phi / 2 + quarterPi; // half the angular distance from south pole

        // Spherical excess E for a spherical triangle with vertices: south pole,
        // previous point, current point.  Uses a formula derived from Cagnoli’s
        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
        var dLambda = lambda - lambda0,
            sdLambda = dLambda >= 0 ? 1 : -1,
            adLambda = sdLambda * dLambda,
            cosPhi = cos(phi),
            sinPhi = sin(phi),
            k = sinPhi0 * sinPhi,
            u = cosPhi0 * cosPhi + k * cos(adLambda),
            v = k * sdLambda * sin(adLambda);
        areaRingSum.add(atan2(v, u));

        // Advance the previous points.
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
    }

    function area(object) {
        areaSum = new d3Array.Adder();
        geoStream(object, areaStream);
        return areaSum * 2;
    }

    function spherical(cartesian) {
        return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
    }

    function cartesian(spherical) {
        var lambda = spherical[0],
            phi = spherical[1],
            cosPhi = cos(phi);
        return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
    }

    function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
        var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function() {
            boundsStream.point = boundsRingPoint;
            boundsStream.lineStart = boundsRingStart;
            boundsStream.lineEnd = boundsRingEnd;
            deltaSum = new d3Array.Adder();
            areaStream.polygonStart();
        },
        polygonEnd: function() {
            areaStream.polygonEnd();
            boundsStream.point = boundsPoint;
            boundsStream.lineStart = boundsLineStart;
            boundsStream.lineEnd = boundsLineEnd;
            if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
            else if (deltaSum > epsilon) phi1 = 90;
            else if (deltaSum < -epsilon) phi0 = -90;
            range[0] = lambda0$1, range[1] = lambda1;
        },
        sphere: function() {
            lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        }
    };

    function boundsPoint(lambda, phi) {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
        var p = cartesian([lambda * radians, phi * radians]);
        if (p0) {
            var normal = cartesianCross(p0, p),
                equatorial = [normal[1], -normal[0], 0],
                inflection = cartesianCross(equatorial, normal);
            cartesianNormalizeInPlace(inflection);
            inflection = spherical(inflection);
            var delta = lambda - lambda2,
                sign = delta > 0 ? 1 : -1,
                lambdai = inflection[0] * degrees * sign,
                phii,
                antimeridian = abs(delta) > 180;
            if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
                phii = inflection[1] * degrees;
                if (phii > phi1) phi1 = phii;
            } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
                phii = -inflection[1] * degrees;
                if (phii < phi0) phi0 = phii;
            } else {
                if (phi < phi0) phi0 = phi;
                if (phi > phi1) phi1 = phi;
            }
            if (antimeridian) {
                if (lambda < lambda2) {
                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
                } else {
                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
                }
            } else {
                if (lambda1 >= lambda0$1) {
                    if (lambda < lambda0$1) lambda0$1 = lambda;
                    if (lambda > lambda1) lambda1 = lambda;
                } else {
                    if (lambda > lambda2) {
                        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
                    } else {
                        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
                    }
                }
            }
        } else {
            ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
        }
        if (phi < phi0) phi0 = phi;
        if (phi > phi1) phi1 = phi;
        p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
        boundsStream.point = linePoint;
    }

    function boundsLineEnd() {
        range[0] = lambda0$1, range[1] = lambda1;
        boundsStream.point = boundsPoint;
        p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
        if (p0) {
            var delta = lambda - lambda2;
            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
        } else {
            lambda00$1 = lambda, phi00$1 = phi;
        }
        areaStream.point(lambda, phi);
        linePoint(lambda, phi);
    }

    function boundsRingStart() {
        areaStream.lineStart();
    }

    function boundsRingEnd() {
        boundsRingPoint(lambda00$1, phi00$1);
        areaStream.lineEnd();
        if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
        range[0] = lambda0$1, range[1] = lambda1;
        p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
        return a[0] - b[0];
    }

    function rangeContains(range, x) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
        var i, n, a, b, merged, deltaMax, delta;

        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
        ranges = [];
        geoStream(feature, boundsStream);

        // First, sort ranges by their minimum longitudes.
        if (n = ranges.length) {
            ranges.sort(rangeCompare);

            // Then, merge any ranges that overlap.
            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
                b = ranges[i];
                if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                    if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
                    if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
                } else {
                    merged.push(a = b);
                }
            }

            // Finally, find the largest gap between the merged ranges.
            // The final bounding box will be the inverse of this gap.
            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
                b = merged[i];
                if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
            }
        }

        ranges = range = null;

        return lambda0$1 === Infinity || phi0 === Infinity ?
            [
                [NaN, NaN],
                [NaN, NaN]
            ] :
            [
                [lambda0$1, phi0],
                [lambda1, phi1]
            ];
    }

    var W0, W1,
        X0, Y0, Z0,
        X1, Y1, Z1,
        X2, Y2, Z2,
        lambda00$2, phi00$2, // first point
        x0, y0, z0; // previous point

    var centroidStream = {
        sphere: noop,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function() {
            centroidStream.lineStart = centroidRingStart;
            centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function() {
            centroidStream.lineStart = centroidLineStart;
            centroidStream.lineEnd = centroidLineEnd;
        }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
    }

    function centroidPointCartesian(x, y, z) {
        ++W0;
        X0 += (x - X0) / W0;
        Y0 += (y - Y0) / W0;
        Z0 += (z - Z0) / W0;
    }

    function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda);
        y0 = cosPhi * sin(lambda);
        z0 = sin(phi);
        centroidStream.point = centroidLinePoint;
        centroidPointCartesian(x0, y0, z0);
    }

    function centroidLinePoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi),
            x = cosPhi * cos(lambda),
            y = cosPhi * sin(lambda),
            z = sin(phi),
            w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
    }

    function centroidLineEnd() {
        centroidStream.point = centroidPoint;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst;
    }

    function centroidRingEnd() {
        centroidRingPoint(lambda00$2, phi00$2);
        centroidStream.point = centroidPoint;
    }

    function centroidRingPointFirst(lambda, phi) {
        lambda00$2 = lambda, phi00$2 = phi;
        lambda *= radians, phi *= radians;
        centroidStream.point = centroidRingPoint;
        var cosPhi = cos(phi);
        x0 = cosPhi * cos(lambda);
        y0 = cosPhi * sin(lambda);
        z0 = sin(phi);
        centroidPointCartesian(x0, y0, z0);
    }

    function centroidRingPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos(phi),
            x = cosPhi * cos(lambda),
            y = cosPhi * sin(lambda),
            z = sin(phi),
            cx = y0 * z - z0 * y,
            cy = z0 * x - x0 * z,
            cz = x0 * y - y0 * x,
            m = hypot(cx, cy, cz),
            w = asin(m), // line weight = angle
            v = m && -w / m; // area weight multiplier
        X2.add(v * cx);
        Y2.add(v * cy);
        Z2.add(v * cz);
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
    }

    function centroid(object) {
        W0 = W1 =
            X0 = Y0 = Z0 =
            X1 = Y1 = Z1 = 0;
        X2 = new d3Array.Adder();
        Y2 = new d3Array.Adder();
        Z2 = new d3Array.Adder();
        geoStream(object, centroidStream);

        var x = +X2,
            y = +Y2,
            z = +Z2,
            m = hypot(x, y, z);

        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
        if (m < epsilon2) {
            x = X1, y = Y1, z = Z1;
            // If the feature has zero length, fall back to arithmetic mean of point vectors.
            if (W1 < epsilon) x = X0, y = Y0, z = Z0;
            m = hypot(x, y, z);
            // If the feature still has an undefined ccentroid, then return.
            if (m < epsilon2) return [NaN, NaN];
        }

        return [atan2(y, x) * degrees, asin(z / m) * degrees];
    }

    function constant(x) {
        return function() {
            return x;
        };
    }

    function compose(a, b) {

        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }

        if (a.invert && b.invert) compose.invert = function(x, y) {
            return x = b.invert(x, y), x && a.invert(x[0], x[1]);
        };

        return compose;
    }

    function rotationIdentity(lambda, phi) {
        return [abs(lambda) > pi ? lambda + Math.round(-lambda / tau) * tau : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) :
                rotationLambda(deltaLambda)) :
            (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) :
                rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
        return function(lambda, phi) {
            return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
        };
    }

    function rotationLambda(deltaLambda) {
        var rotation = forwardRotationLambda(deltaLambda);
        rotation.invert = forwardRotationLambda(-deltaLambda);
        return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = cos(deltaPhi),
            sinDeltaPhi = sin(deltaPhi),
            cosDeltaGamma = cos(deltaGamma),
            sinDeltaGamma = sin(deltaGamma);

        function rotation(lambda, phi) {
            var cosPhi = cos(phi),
                x = cos(lambda) * cosPhi,
                y = sin(lambda) * cosPhi,
                z = sin(phi),
                k = z * cosDeltaPhi + x * sinDeltaPhi;
            return [
                atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
                asin(k * cosDeltaGamma + y * sinDeltaGamma)
            ];
        }

        rotation.invert = function(lambda, phi) {
            var cosPhi = cos(phi),
                x = cos(lambda) * cosPhi,
                y = sin(lambda) * cosPhi,
                z = sin(phi),
                k = z * cosDeltaGamma - y * sinDeltaGamma;
            return [
                atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
                asin(k * cosDeltaPhi - x * sinDeltaPhi)
            ];
        };

        return rotation;
    }

    function rotation(rotate) {
        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
        }

        forward.invert = function(coordinates) {
            coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
            return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
        };

        return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta) return;
        var cosRadius = cos(radius),
            sinRadius = sin(radius),
            step = direction * delta;
        if (t0 == null) {
            t0 = radius + direction * tau;
            t1 = radius - step / 2;
        } else {
            t0 = circleRadius(cosRadius, t0);
            t1 = circleRadius(cosRadius, t1);
            if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
        }
        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
            point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
            stream.point(point[0], point[1]);
        }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
        point = cartesian(point), point[0] -= cosRadius;
        cartesianNormalizeInPlace(point);
        var radius = acos(-point[1]);
        return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
    }

    function circle() {
        var center = constant([0, 0]),
            radius = constant(90),
            precision = constant(6),
            ring,
            rotate,
            stream = { point: point };

        function point(x, y) {
            ring.push(x = rotate(x, y));
            x[0] *= degrees, x[1] *= degrees;
        }

        function circle() {
            var c = center.apply(this, arguments),
                r = radius.apply(this, arguments) * radians,
                p = precision.apply(this, arguments) * radians;
            ring = [];
            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
            circleStream(stream, r, p, 1);
            c = { type: "Polygon", coordinates: [ring] };
            ring = rotate = null;
            return c;
        }

        circle.center = function(_) {
            return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
        };

        circle.radius = function(_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
        };

        circle.precision = function(_) {
            return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
        };

        return circle;
    }

    function clipBuffer() {
        var lines = [],
            line;
        return {
            point: function(x, y, m) {
                line.push([x, y, m]);
            },
            lineStart: function() {
                lines.push(line = []);
            },
            lineEnd: noop,
            rejoin: function() {
                if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
            },
            result: function() {
                var result = lines;
                lines = [];
                line = null;
                return result;
            }
        };
    }

    function pointEqual(a, b) {
        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
    }

    function Intersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other; // another intersection
        this.e = entry; // is an entry?
        this.v = false; // visited
        this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
        var subject = [],
            clip = [],
            i,
            n;

        segments.forEach(function(segment) {
            if ((n = segment.length - 1) <= 0) return;
            var n, p0 = segment[0],
                p1 = segment[n],
                x;

            if (pointEqual(p0, p1)) {
                if (!p0[2] && !p1[2]) {
                    stream.lineStart();
                    for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
                    stream.lineEnd();
                    return;
                }
                // handle degenerate cases by moving the point
                p1[0] += 2 * epsilon;
            }

            subject.push(x = new Intersection(p0, segment, null, true));
            clip.push(x.o = new Intersection(p0, null, x, false));
            subject.push(x = new Intersection(p1, segment, null, false));
            clip.push(x.o = new Intersection(p1, null, x, true));
        });

        if (!subject.length) return;

        clip.sort(compareIntersection);
        link(subject);
        link(clip);

        for (i = 0, n = clip.length; i < n; ++i) {
            clip[i].e = startInside = !startInside;
        }

        var start = subject[0],
            points,
            point;

        while (1) {
            // Find first unvisited intersection.
            var current = start,
                isSubject = true;
            while (current.v)
                if ((current = current.n) === start) return;
            points = current.z;
            stream.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, stream);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, stream);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            stream.lineEnd();
        }
    }

    function link(array) {
        if (!(n = array.length)) return;
        var n,
            i = 0,
            a = array[0],
            b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }

    function longitude(point) {
        if (abs(point[0]) <= pi)
            return point[0];
        else
            return sign(point[0]) * ((abs(point[0]) + pi) % tau - pi);
    }

    function polygonContains(polygon, point) {
        var lambda = longitude(point),
            phi = point[1],
            sinPhi = sin(phi),
            normal = [sin(lambda), -cos(lambda), 0],
            angle = 0,
            winding = 0;

        var sum = new d3Array.Adder();

        if (sinPhi === 1) phi = halfPi + epsilon;
        else if (sinPhi === -1) phi = -halfPi - epsilon;

        for (var i = 0, n = polygon.length; i < n; ++i) {
            if (!(m = (ring = polygon[i]).length)) continue;
            var ring,
                m,
                point0 = ring[m - 1],
                lambda0 = longitude(point0),
                phi0 = point0[1] / 2 + quarterPi,
                sinPhi0 = sin(phi0),
                cosPhi0 = cos(phi0);

            for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
                var point1 = ring[j],
                    lambda1 = longitude(point1),
                    phi1 = point1[1] / 2 + quarterPi,
                    sinPhi1 = sin(phi1),
                    cosPhi1 = cos(phi1),
                    delta = lambda1 - lambda0,
                    sign = delta >= 0 ? 1 : -1,
                    absDelta = sign * delta,
                    antimeridian = absDelta > pi,
                    k = sinPhi0 * sinPhi1;

                sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
                angle += antimeridian ? delta + sign * tau : delta;

                // Are the longitudes either side of the point’s meridian (lambda),
                // and are the latitudes smaller than the parallel (phi)?
                if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
                    var arc = cartesianCross(cartesian(point0), cartesian(point1));
                    cartesianNormalizeInPlace(arc);
                    var intersection = cartesianCross(normal, arc);
                    cartesianNormalizeInPlace(intersection);
                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ delta >= 0 ? 1 : -1;
                    }
                }
            }
        }

        // First, determine whether the South pole is inside or outside:
        //
        // It is inside if:
        // * the polygon winds around it in a clockwise direction.
        // * the polygon does not (cumulatively) wind around it, but has a negative
        //   (counter-clockwise) area.
        //
        // Second, count the (signed) number of times a segment crosses a lambda
        // from the point to the South pole.  If it is zero, then the point is the
        // same side as the South pole.

        return (angle < -epsilon || angle < epsilon && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
        return function(sink) {
            var line = clipLine(sink),
                ringBuffer = clipBuffer(),
                ringSink = clipLine(ringBuffer),
                polygonStarted = false,
                polygon,
                segments,
                ring;

            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function() {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3Array.merge(segments);
                    var startInside = polygonContains(polygon, start);
                    if (segments.length) {
                        if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                        clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
                    } else if (startInside) {
                        if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                        sink.lineStart();
                        interpolate(null, null, 1, sink);
                        sink.lineEnd();
                    }
                    if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function() {
                    sink.polygonStart();
                    sink.lineStart();
                    interpolate(null, null, 1, sink);
                    sink.lineEnd();
                    sink.polygonEnd();
                }
            };

            function point(lambda, phi) {
                if (pointVisible(lambda, phi)) sink.point(lambda, phi);
            }

            function pointLine(lambda, phi) {
                line.point(lambda, phi);
            }

            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }

            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }

            function pointRing(lambda, phi) {
                ring.push([lambda, phi]);
                ringSink.point(lambda, phi);
            }

            function ringStart() {
                ringSink.lineStart();
                ring = [];
            }

            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringSink.lineEnd();

                var clean = ringSink.clean(),
                    ringSegments = ringBuffer.result(),
                    i, n = ringSegments.length,
                    m,
                    segment,
                    point;

                ring.pop();
                polygon.push(ring);
                ring = null;

                if (!n) return;

                // No intersections.
                if (clean & 1) {
                    segment = ringSegments[0];
                    if ((m = segment.length - 1) > 0) {
                        if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
                        sink.lineStart();
                        for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
                        sink.lineEnd();
                    }
                    return;
                }

                // Rejoin connected segments.
                // TODO reuse ringBuffer.rejoin()?
                if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

                segments.push(ringSegments.filter(validSegment));
            }

            return clip;
        };
    }

    function validSegment(segment) {
        return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) -
            ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
    }

    var clipAntimeridian = clip(
        function() { return true; },
        clipAntimeridianLine,
        clipAntimeridianInterpolate,
        [-pi, -halfPi]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
        var lambda0 = NaN,
            phi0 = NaN,
            sign0 = NaN,
            clean; // no intersections

        return {
            lineStart: function() {
                stream.lineStart();
                clean = 1;
            },
            point: function(lambda1, phi1) {
                var sign1 = lambda1 > 0 ? pi : -pi,
                    delta = abs(lambda1 - lambda0);
                if (abs(delta - pi) < epsilon) { // line crosses a pole
                    stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
                    stream.point(sign0, phi0);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi0);
                    stream.point(lambda1, phi0);
                    clean = 0;
                } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
                    if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
                    if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
                    phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
                    stream.point(sign0, phi0);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi0);
                    clean = 0;
                }
                stream.point(lambda0 = lambda1, phi0 = phi1);
                sign0 = sign1;
            },
            lineEnd: function() {
                stream.lineEnd();
                lambda0 = phi0 = NaN;
            },
            clean: function() {
                return 2 - clean; // if intersections, rejoin first and last segments
            }
        };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosPhi0,
            cosPhi1,
            sinLambda0Lambda1 = sin(lambda0 - lambda1);
        return abs(sinLambda0Lambda1) > epsilon ?
            atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) -
                    sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) /
                (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) :
            (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi;
        if (from == null) {
            phi = direction * halfPi;
            stream.point(-pi, phi);
            stream.point(0, phi);
            stream.point(pi, phi);
            stream.point(pi, 0);
            stream.point(pi, -phi);
            stream.point(0, -phi);
            stream.point(-pi, -phi);
            stream.point(-pi, 0);
            stream.point(-pi, phi);
        } else if (abs(from[0] - to[0]) > epsilon) {
            var lambda = from[0] < to[0] ? pi : -pi;
            phi = direction * lambda / 2;
            stream.point(-lambda, phi);
            stream.point(0, phi);
            stream.point(lambda, phi);
        } else {
            stream.point(to[0], to[1]);
        }
    }

    function clipCircle(radius) {
        var cr = cos(radius),
            delta = 6 * radians,
            smallRadius = cr > 0,
            notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

        function interpolate(from, to, direction, stream) {
            circleStream(stream, radius, delta, direction, from, to);
        }

        function visible(lambda, phi) {
            return cos(lambda) * cos(phi) > cr;
        }

        // Takes a line and cuts into visible segments. Return values used for polygon
        // clipping: 0 - there were intersections or the line was empty; 1 - no
        // intersections 2 - there were intersections, and the first and last segments
        // should be rejoined.
        function clipLine(stream) {
            var point0, // previous point
                c0, // code for previous point
                v0, // visibility of previous point
                v00, // visibility of first point
                clean; // no intersections
            return {
                lineStart: function() {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function(lambda, phi) {
                    var point1 = [lambda, phi],
                        point2,
                        v = visible(lambda, phi),
                        c = smallRadius ?
                        v ? 0 : code(lambda, phi) :
                        v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
                    if (!point0 && (v00 = v0 = v)) stream.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                            point1[2] = 1;
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            // outside going in
                            stream.lineStart();
                            point2 = intersect(point1, point0);
                            stream.point(point2[0], point2[1]);
                        } else {
                            // inside going out
                            point2 = intersect(point0, point1);
                            stream.point(point2[0], point2[1], 2);
                            stream.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        // If the codes for two points are different, or are both zero,
                        // and there this segment intersects with the small circle.
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                stream.lineStart();
                                stream.point(t[0][0], t[0][1]);
                                stream.point(t[1][0], t[1][1]);
                                stream.lineEnd();
                            } else {
                                stream.point(t[1][0], t[1][1]);
                                stream.lineEnd();
                                stream.lineStart();
                                stream.point(t[0][0], t[0][1], 3);
                            }
                        }
                    }
                    if (v && (!point0 || !pointEqual(point0, point1))) {
                        stream.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function() {
                    if (v0) stream.lineEnd();
                    point0 = null;
                },
                // Rejoin first and last segments if there were intersections and the first
                // and last points were visible.
                clean: function() {
                    return clean | ((v00 && v0) << 1);
                }
            };
        }

        // Intersects the great circle between a and b with the clip circle.
        function intersect(a, b, two) {
            var pa = cartesian(a),
                pb = cartesian(b);

            // We have two planes, n1.p = d1 and n2.p = d2.
            // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
            var n1 = [1, 0, 0], // normal
                n2 = cartesianCross(pa, pb),
                n2n2 = cartesianDot(n2, n2),
                n1n2 = n2[0], // cartesianDot(n1, n2),
                determinant = n2n2 - n1n2 * n1n2;

            // Two polar points.
            if (!determinant) return !two && a;

            var c1 = cr * n2n2 / determinant,
                c2 = -cr * n1n2 / determinant,
                n1xn2 = cartesianCross(n1, n2),
                A = cartesianScale(n1, c1),
                B = cartesianScale(n2, c2);
            cartesianAddInPlace(A, B);

            // Solve |p(t)|^2 = 1.
            var u = n1xn2,
                w = cartesianDot(A, u),
                uu = cartesianDot(u, u),
                t2 = w * w - uu * (cartesianDot(A, A) - 1);

            if (t2 < 0) return;

            var t = sqrt(t2),
                q = cartesianScale(u, (-w - t) / uu);
            cartesianAddInPlace(q, A);
            q = spherical(q);

            if (!two) return q;

            // Two intersection points.
            var lambda0 = a[0],
                lambda1 = b[0],
                phi0 = a[1],
                phi1 = b[1],
                z;

            if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

            var delta = lambda1 - lambda0,
                polar = abs(delta - pi) < epsilon,
                meridian = polar || delta < epsilon;

            if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

            // Check that the first point is between a and b.
            if (meridian ?
                polar ?
                phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) :
                phi0 <= q[1] && q[1] <= phi1 :
                delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
                var q1 = cartesianScale(u, (-w + t) / uu);
                cartesianAddInPlace(q1, A);
                return [q, spherical(q1)];
            }
        }

        // Generates a 4-bit vector representing the location of a point relative to
        // the small circle's bounding box.
        function code(lambda, phi) {
            var r = smallRadius ? radius : pi - radius,
                code = 0;
            if (lambda < -r) code |= 1; // left
            else if (lambda > r) code |= 2; // right
            if (phi < -r) code |= 4; // below
            else if (phi > r) code |= 8; // above
            return code;
        }

        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
        var ax = a[0],
            ay = a[1],
            bx = b[0],
            by = b[1],
            t0 = 0,
            t1 = 1,
            dx = bx - ax,
            dy = by - ay,
            r;

        r = x0 - ax;
        if (!dx && r > 0) return;
        r /= dx;
        if (dx < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
        } else if (dx > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
        }

        r = x1 - ax;
        if (!dx && r < 0) return;
        r /= dx;
        if (dx < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
        } else if (dx > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
        }

        r = y0 - ay;
        if (!dy && r > 0) return;
        r /= dy;
        if (dy < 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
        } else if (dy > 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
        }

        r = y1 - ay;
        if (!dy && r < 0) return;
        r /= dy;
        if (dy < 0) {
            if (r > t1) return;
            if (r > t0) t0 = r;
        } else if (dy > 0) {
            if (r < t0) return;
            if (r < t1) t1 = r;
        }

        if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
        if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
        return true;
    }

    var clipMax = 1e9,
        clipMin = -clipMax;

    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

        function visible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
        }

        function interpolate(from, to, direction, stream) {
            var a = 0,
                a1 = 0;
            if (from == null ||
                (a = corner(from, direction)) !== (a1 = corner(to, direction)) ||
                comparePoint(from, to) < 0 ^ direction > 0) {
                do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                while ((a = (a + direction + 4) % 4) !== a1);
            } else {
                stream.point(to[0], to[1]);
            }
        }

        function corner(p, direction) {
            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 :
                abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 :
                abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 :
                direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
        }

        function compareIntersection(a, b) {
            return comparePoint(a.x, b.x);
        }

        function comparePoint(a, b) {
            var ca = corner(a, 1),
                cb = corner(b, 1);
            return ca !== cb ? ca - cb :
                ca === 0 ? b[1] - a[1] :
                ca === 1 ? a[0] - b[0] :
                ca === 2 ? a[1] - b[1] :
                b[0] - a[0];
        }

        return function(stream) {
            var activeStream = stream,
                bufferStream = clipBuffer(),
                segments,
                polygon,
                ring,
                x__, y__, v__, // first point
                x_, y_, v_, // previous point
                first,
                clean;

            var clipStream = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: polygonStart,
                polygonEnd: polygonEnd
            };

            function point(x, y) {
                if (visible(x, y)) activeStream.point(x, y);
            }

            function polygonInside() {
                var winding = 0;

                for (var i = 0, n = polygon.length; i < n; ++i) {
                    for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
                        a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
                        if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; } else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
                    }
                }

                return winding;
            }

            // Buffer geometry within a polygon and then clip it en masse.
            function polygonStart() {
                activeStream = bufferStream, segments = [], polygon = [], clean = true;
            }

            function polygonEnd() {
                var startInside = polygonInside(),
                    cleanInside = clean && startInside,
                    visible = (segments = d3Array.merge(segments)).length;
                if (cleanInside || visible) {
                    stream.polygonStart();
                    if (cleanInside) {
                        stream.lineStart();
                        interpolate(null, null, 1, stream);
                        stream.lineEnd();
                    }
                    if (visible) {
                        clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
                    }
                    stream.polygonEnd();
                }
                activeStream = stream, segments = polygon = ring = null;
            }

            function lineStart() {
                clipStream.point = linePoint;
                if (polygon) polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }

            // TODO rather than special-case polygons, simply handle them separately.
            // Ideally, coincident intersection points should be jittered to avoid
            // clipping issues.
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_) bufferStream.rejoin();
                    segments.push(bufferStream.result());
                }
                clipStream.point = point;
                if (v_) activeStream.lineEnd();
            }

            function linePoint(x, y) {
                var v = visible(x, y);
                if (polygon) ring.push([x, y]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        activeStream.lineStart();
                        activeStream.point(x, y);
                    }
                } else {
                    if (v && v_) activeStream.point(x, y);
                    else {
                        var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                            b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                        if (clipLine(a, b, x0, y0, x1, y1)) {
                            if (!v_) {
                                activeStream.lineStart();
                                activeStream.point(a[0], a[1]);
                            }
                            activeStream.point(b[0], b[1]);
                            if (!v) activeStream.lineEnd();
                            clean = false;
                        } else if (v) {
                            activeStream.lineStart();
                            activeStream.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }

            return clipStream;
        };
    }

    function extent() {
        var x0 = 0,
            y0 = 0,
            x1 = 960,
            y1 = 500,
            cache,
            cacheStream,
            clip;

        return clip = {
            stream: function(stream) {
                return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
            },
            extent: function(_) {
                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [
                    [x0, y0],
                    [x1, y1]
                ];
            }
        };
    }

    var lengthSum,
        lambda0$2,
        sinPhi0$1,
        cosPhi0$1;

    var lengthStream = {
        sphere: noop,
        point: noop,
        lineStart: lengthLineStart,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop
    };

    function lengthLineStart() {
        lengthStream.point = lengthPointFirst;
        lengthStream.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = noop;
    }

    function lengthPointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
        lengthStream.point = lengthPoint;
    }

    function lengthPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var sinPhi = sin(phi),
            cosPhi = cos(phi),
            delta = abs(lambda - lambda0$2),
            cosDelta = cos(delta),
            sinDelta = sin(delta),
            x = cosPhi * sinDelta,
            y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
            z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
        lengthSum.add(atan2(sqrt(x * x + y * y), z));
        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
    }

    function length(object) {
        lengthSum = new d3Array.Adder();
        geoStream(object, lengthStream);
        return +lengthSum;
    }

    var coordinates = [null, null],
        object = { type: "LineString", coordinates: coordinates };

    function distance(a, b) {
        coordinates[0] = a;
        coordinates[1] = b;
        return length(object);
    }

    var containsObjectType = {
        Feature: function(object, point) {
            return containsGeometry(object.geometry, point);
        },
        FeatureCollection: function(object, point) {
            var features = object.features,
                i = -1,
                n = features.length;
            while (++i < n)
                if (containsGeometry(features[i].geometry, point)) return true;
            return false;
        }
    };

    var containsGeometryType = {
        Sphere: function() {
            return true;
        },
        Point: function(object, point) {
            return containsPoint(object.coordinates, point);
        },
        MultiPoint: function(object, point) {
            var coordinates = object.coordinates,
                i = -1,
                n = coordinates.length;
            while (++i < n)
                if (containsPoint(coordinates[i], point)) return true;
            return false;
        },
        LineString: function(object, point) {
            return containsLine(object.coordinates, point);
        },
        MultiLineString: function(object, point) {
            var coordinates = object.coordinates,
                i = -1,
                n = coordinates.length;
            while (++i < n)
                if (containsLine(coordinates[i], point)) return true;
            return false;
        },
        Polygon: function(object, point) {
            return containsPolygon(object.coordinates, point);
        },
        MultiPolygon: function(object, point) {
            var coordinates = object.coordinates,
                i = -1,
                n = coordinates.length;
            while (++i < n)
                if (containsPolygon(coordinates[i], point)) return true;
            return false;
        },
        GeometryCollection: function(object, point) {
            var geometries = object.geometries,
                i = -1,
                n = geometries.length;
            while (++i < n)
                if (containsGeometry(geometries[i], point)) return true;
            return false;
        }
    };

    function containsGeometry(geometry, point) {
        return geometry && containsGeometryType.hasOwnProperty(geometry.type) ?
            containsGeometryType[geometry.type](geometry, point) :
            false;
    }

    function containsPoint(coordinates, point) {
        return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
        var ao, bo, ab;
        for (var i = 0, n = coordinates.length; i < n; i++) {
            bo = distance(coordinates[i], point);
            if (bo === 0) return true;
            if (i > 0) {
                ab = distance(coordinates[i], coordinates[i - 1]);
                if (
                    ab > 0 &&
                    ao <= ab &&
                    bo <= ab &&
                    (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
                )
                    return true;
            }
            ao = bo;
        }
        return false;
    }

    function containsPolygon(coordinates, point) {
        return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
        return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
        return [point[0] * radians, point[1] * radians];
    }

    function contains(object, point) {
        return (object && containsObjectType.hasOwnProperty(object.type) ?
            containsObjectType[object.type] :
            containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
        var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
        return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
        var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
        return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
        var x1, x0, X1, X0,
            y1, y0, Y1, Y0,
            dx = 10,
            dy = dx,
            DX = 90,
            DY = 360,
            x, y, X, Y,
            precision = 2.5;

        function graticule() {
            return { type: "MultiLineString", coordinates: lines() };
        }

        function lines() {
            return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
                .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
                .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
                .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
        }

        graticule.lines = function() {
            return lines().map(function(coordinates) { return { type: "LineString", coordinates: coordinates }; });
        };

        graticule.outline = function() {
            return {
                type: "Polygon",
                coordinates: [
                    X(X0).concat(
                        Y(Y1).slice(1),
                        X(X1).reverse().slice(1),
                        Y(Y0).reverse().slice(1))
                ]
            };
        };

        graticule.extent = function(_) {
            if (!arguments.length) return graticule.extentMinor();
            return graticule.extentMajor(_).extentMinor(_);
        };

        graticule.extentMajor = function(_) {
            if (!arguments.length) return [
                [X0, Y0],
                [X1, Y1]
            ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1) _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };

        graticule.extentMinor = function(_) {
            if (!arguments.length) return [
                [x0, y0],
                [x1, y1]
            ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1) _ = x0, x0 = x1, x1 = _;
            if (y0 > y1) _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };

        graticule.step = function(_) {
            if (!arguments.length) return graticule.stepMinor();
            return graticule.stepMajor(_).stepMinor(_);
        };

        graticule.stepMajor = function(_) {
            if (!arguments.length) return [DX, DY];
            DX = +_[0], DY = +_[1];
            return graticule;
        };

        graticule.stepMinor = function(_) {
            if (!arguments.length) return [dx, dy];
            dx = +_[0], dy = +_[1];
            return graticule;
        };

        graticule.precision = function(_) {
            if (!arguments.length) return precision;
            precision = +_;
            x = graticuleX(y0, y1, 90);
            y = graticuleY(x0, x1, precision);
            X = graticuleX(Y0, Y1, 90);
            Y = graticuleY(X0, X1, precision);
            return graticule;
        };

        return graticule
            .extentMajor([
                [-180, -90 + epsilon],
                [180, 90 - epsilon]
            ])
            .extentMinor([
                [-180, -80 - epsilon],
                [180, 80 + epsilon]
            ]);
    }

    function graticule10() {
        return graticule()();
    }

    function interpolate(a, b) {
        var x0 = a[0] * radians,
            y0 = a[1] * radians,
            x1 = b[0] * radians,
            y1 = b[1] * radians,
            cy0 = cos(y0),
            sy0 = sin(y0),
            cy1 = cos(y1),
            sy1 = sin(y1),
            kx0 = cy0 * cos(x0),
            ky0 = cy0 * sin(x0),
            kx1 = cy1 * cos(x1),
            ky1 = cy1 * sin(x1),
            d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
            k = sin(d);

        var interpolate = d ? function(t) {
            var B = sin(t *= d) / k,
                A = sin(d - t) / k,
                x = A * kx0 + B * kx1,
                y = A * ky0 + B * ky1,
                z = A * sy0 + B * sy1;
            return [
                atan2(y, x) * degrees,
                atan2(z, sqrt(x * x + y * y)) * degrees
            ];
        } : function() {
            return [x0 * degrees, y0 * degrees];
        };

        interpolate.distance = d;

        return interpolate;
    }

    var identity = x => x;

    var areaSum$1 = new d3Array.Adder(),
        areaRingSum$1 = new d3Array.Adder(),
        x00,
        y00,
        x0$1,
        y0$1;

    var areaStream$1 = {
        point: noop,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: function() {
            areaStream$1.lineStart = areaRingStart$1;
            areaStream$1.lineEnd = areaRingEnd$1;
        },
        polygonEnd: function() {
            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
            areaSum$1.add(abs(areaRingSum$1));
            areaRingSum$1 = new d3Array.Adder();
        },
        result: function() {
            var area = areaSum$1 / 2;
            areaSum$1 = new d3Array.Adder();
            return area;
        }
    };

    function areaRingStart$1() {
        areaStream$1.point = areaPointFirst$1;
    }

    function areaPointFirst$1(x, y) {
        areaStream$1.point = areaPoint$1;
        x00 = x0$1 = x, y00 = y0$1 = y;
    }

    function areaPoint$1(x, y) {
        areaRingSum$1.add(y0$1 * x - x0$1 * y);
        x0$1 = x, y0$1 = y;
    }

    function areaRingEnd$1() {
        areaPoint$1(x00, y00);
    }

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream$1 = {
        point: boundsPoint$1,
        lineStart: noop,
        lineEnd: noop,
        polygonStart: noop,
        polygonEnd: noop,
        result: function() {
            var bounds = [
                [x0$2, y0$2],
                [x1, y1]
            ];
            x1 = y1 = -(y0$2 = x0$2 = Infinity);
            return bounds;
        }
    };

    function boundsPoint$1(x, y) {
        if (x < x0$2) x0$2 = x;
        if (x > x1) x1 = x;
        if (y < y0$2) y0$2 = y;
        if (y > y1) y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0$1 = 0,
        Y0$1 = 0,
        Z0$1 = 0,
        X1$1 = 0,
        Y1$1 = 0,
        Z1$1 = 0,
        X2$1 = 0,
        Y2$1 = 0,
        Z2$1 = 0,
        x00$1,
        y00$1,
        x0$3,
        y0$3;

    var centroidStream$1 = {
        point: centroidPoint$1,
        lineStart: centroidLineStart$1,
        lineEnd: centroidLineEnd$1,
        polygonStart: function() {
            centroidStream$1.lineStart = centroidRingStart$1;
            centroidStream$1.lineEnd = centroidRingEnd$1;
        },
        polygonEnd: function() {
            centroidStream$1.point = centroidPoint$1;
            centroidStream$1.lineStart = centroidLineStart$1;
            centroidStream$1.lineEnd = centroidLineEnd$1;
        },
        result: function() {
            var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1] :
                Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1] :
                Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1] :
                [NaN, NaN];
            X0$1 = Y0$1 = Z0$1 =
                X1$1 = Y1$1 = Z1$1 =
                X2$1 = Y2$1 = Z2$1 = 0;
            return centroid;
        }
    };

    function centroidPoint$1(x, y) {
        X0$1 += x;
        Y0$1 += y;
        ++Z0$1;
    }

    function centroidLineStart$1() {
        centroidStream$1.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
        centroidStream$1.point = centroidPointLine;
        centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function centroidPointLine(x, y) {
        var dx = x - x0$3,
            dy = y - y0$3,
            z = sqrt(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function centroidLineEnd$1() {
        centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingStart$1() {
        centroidStream$1.point = centroidPointFirstRing;
    }

    function centroidRingEnd$1() {
        centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
        centroidStream$1.point = centroidPointRing;
        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
    }

    function centroidPointRing(x, y) {
        var dx = x - x0$3,
            dy = y - y0$3,
            z = sqrt(dx * dx + dy * dy);

        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;

        z = y0$3 * x - x0$3 * y;
        X2$1 += z * (x0$3 + x);
        Y2$1 += z * (y0$3 + y);
        Z2$1 += z * 3;
        centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function PathContext(context) {
        this._context = context;
    }

    PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function(_) {
            return this._radius = _, this;
        },
        polygonStart: function() {
            this._line = 0;
        },
        polygonEnd: function() {
            this._line = NaN;
        },
        lineStart: function() {
            this._point = 0;
        },
        lineEnd: function() {
            if (this._line === 0) this._context.closePath();
            this._point = NaN;
        },
        point: function(x, y) {
            switch (this._point) {
                case 0:
                    {
                        this._context.moveTo(x, y);
                        this._point = 1;
                        break;
                    }
                case 1:
                    {
                        this._context.lineTo(x, y);
                        break;
                    }
                default:
                    {
                        this._context.moveTo(x + this._radius, y);
                        this._context.arc(x, y, this._radius, 0, tau);
                        break;
                    }
            }
        },
        result: noop
    };

    var lengthSum$1 = new d3Array.Adder(),
        lengthRing,
        x00$2,
        y00$2,
        x0$4,
        y0$4;

    var lengthStream$1 = {
        point: noop,
        lineStart: function() {
            lengthStream$1.point = lengthPointFirst$1;
        },
        lineEnd: function() {
            if (lengthRing) lengthPoint$1(x00$2, y00$2);
            lengthStream$1.point = noop;
        },
        polygonStart: function() {
            lengthRing = true;
        },
        polygonEnd: function() {
            lengthRing = null;
        },
        result: function() {
            var length = +lengthSum$1;
            lengthSum$1 = new d3Array.Adder();
            return length;
        }
    };

    function lengthPointFirst$1(x, y) {
        lengthStream$1.point = lengthPoint$1;
        x00$2 = x0$4 = x, y00$2 = y0$4 = y;
    }

    function lengthPoint$1(x, y) {
        x0$4 -= x, y0$4 -= y;
        lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
        x0$4 = x, y0$4 = y;
    }

    function PathString() {
        this._string = [];
    }

    PathString.prototype = {
        _radius: 4.5,
        _circle: circle$1(4.5),
        pointRadius: function(_) {
            if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
            return this;
        },
        polygonStart: function() {
            this._line = 0;
        },
        polygonEnd: function() {
            this._line = NaN;
        },
        lineStart: function() {
            this._point = 0;
        },
        lineEnd: function() {
            if (this._line === 0) this._string.push("Z");
            this._point = NaN;
        },
        point: function(x, y) {
            switch (this._point) {
                case 0:
                    {
                        this._string.push("M", x, ",", y);
                        this._point = 1;
                        break;
                    }
                case 1:
                    {
                        this._string.push("L", x, ",", y);
                        break;
                    }
                default:
                    {
                        if (this._circle == null) this._circle = circle$1(this._radius);
                        this._string.push("M", x, ",", y, this._circle);
                        break;
                    }
            }
        },
        result: function() {
            if (this._string.length) {
                var result = this._string.join("");
                this._string = [];
                return result;
            } else {
                return null;
            }
        }
    };

    function circle$1(radius) {
        return "m0," + radius +
            "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius +
            "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius +
            "z";
    }

    function index(projection, context) {
        var pointRadius = 4.5,
            projectionStream,
            contextStream;

        function path(object) {
            if (object) {
                if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
                geoStream(object, projectionStream(contextStream));
            }
            return contextStream.result();
        }

        path.area = function(object) {
            geoStream(object, projectionStream(areaStream$1));
            return areaStream$1.result();
        };

        path.measure = function(object) {
            geoStream(object, projectionStream(lengthStream$1));
            return lengthStream$1.result();
        };

        path.bounds = function(object) {
            geoStream(object, projectionStream(boundsStream$1));
            return boundsStream$1.result();
        };

        path.centroid = function(object) {
            geoStream(object, projectionStream(centroidStream$1));
            return centroidStream$1.result();
        };

        path.projection = function(_) {
            return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
        };

        path.context = function(_) {
            if (!arguments.length) return context;
            contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
            if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
            return path;
        };

        path.pointRadius = function(_) {
            if (!arguments.length) return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };

        return path.projection(projection).context(context);
    }

    function transform(methods) {
        return {
            stream: transformer(methods)
        };
    }

    function transformer(methods) {
        return function(stream) {
            var s = new TransformStream;
            for (var key in methods) s[key] = methods[key];
            s.stream = stream;
            return s;
        };
    }

    function TransformStream() {}

    TransformStream.prototype = {
        constructor: TransformStream,
        point: function(x, y) { this.stream.point(x, y); },
        sphere: function() { this.stream.sphere(); },
        lineStart: function() { this.stream.lineStart(); },
        lineEnd: function() { this.stream.lineEnd(); },
        polygonStart: function() { this.stream.polygonStart(); },
        polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
        var clip = projection.clipExtent && projection.clipExtent();
        projection.scale(150).translate([0, 0]);
        if (clip != null) projection.clipExtent(null);
        geoStream(object, projection.stream(boundsStream$1));
        fitBounds(boundsStream$1.result());
        if (clip != null) projection.clipExtent(clip);
        return projection;
    }

    function fitExtent(projection, extent, object) {
        return fit(projection, function(b) {
            var w = extent[1][0] - extent[0][0],
                h = extent[1][1] - extent[0][1],
                k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
                x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
                y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
            projection.scale(150 * k).translate([x, y]);
        }, object);
    }

    function fitSize(projection, size, object) {
        return fitExtent(projection, [
            [0, 0], size
        ], object);
    }

    function fitWidth(projection, width, object) {
        return fit(projection, function(b) {
            var w = +width,
                k = w / (b[1][0] - b[0][0]),
                x = (w - k * (b[1][0] + b[0][0])) / 2,
                y = -k * b[0][1];
            projection.scale(150 * k).translate([x, y]);
        }, object);
    }

    function fitHeight(projection, height, object) {
        return fit(projection, function(b) {
            var h = +height,
                k = h / (b[1][1] - b[0][1]),
                x = -k * b[0][0],
                y = (h - k * (b[1][1] + b[0][1])) / 2;
            projection.scale(150 * k).translate([x, y]);
        }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
        return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
        return transformer({
            point: function(x, y) {
                x = project(x, y);
                this.stream.point(x[0], x[1]);
            }
        });
    }

    function resample$1(project, delta2) {

        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0,
                dy = y1 - y0,
                d2 = dx * dx + dy * dy;
            if (d2 > 4 * delta2 && depth--) {
                var a = a0 + a1,
                    b = b0 + b1,
                    c = c0 + c1,
                    m = sqrt(a * a + b * b + c * c),
                    phi2 = asin(c /= m),
                    lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
                    p = project(lambda2, phi2),
                    x2 = p[0],
                    y2 = p[1],
                    dx2 = x2 - x0,
                    dy2 = y2 - y0,
                    dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > delta2 // perpendicular projected distance
                    ||
                    abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
                    ||
                    a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
                }
            }
        }
        return function(stream) {
            var lambda00, x00, y00, a00, b00, c00, // first point
                lambda0, x0, y0, a0, b0, c0; // previous point

            var resampleStream = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function() { stream.polygonStart();
                    resampleStream.lineStart = ringStart; },
                polygonEnd: function() { stream.polygonEnd();
                    resampleStream.lineStart = lineStart; }
            };

            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }

            function lineStart() {
                x0 = NaN;
                resampleStream.point = linePoint;
                stream.lineStart();
            }

            function linePoint(lambda, phi) {
                var c = cartesian([lambda, phi]),
                    p = project(lambda, phi);
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }

            function lineEnd() {
                resampleStream.point = point;
                stream.lineEnd();
            }

            function ringStart() {
                lineStart();
                resampleStream.point = ringPoint;
                resampleStream.lineEnd = ringEnd;
            }

            function ringPoint(lambda, phi) {
                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resampleStream.point = linePoint;
            }

            function ringEnd() {
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
                resampleStream.lineEnd = lineEnd;
                lineEnd();
            }

            return resampleStream;
        };
    }

    var transformRadians = transformer({
        point: function(x, y) {
            this.stream.point(x * radians, y * radians);
        }
    });

    function transformRotate(rotate) {
        return transformer({
            point: function(x, y) {
                var r = rotate(x, y);
                return this.stream.point(r[0], r[1]);
            }
        });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
        function transform(x, y) {
            x *= sx;
            y *= sy;
            return [dx + k * x, dy - k * y];
        }
        transform.invert = function(x, y) {
            return [(x - dx) / k * sx, (dy - y) / k * sy];
        };
        return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
        if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
        var cosAlpha = cos(alpha),
            sinAlpha = sin(alpha),
            a = cosAlpha * k,
            b = sinAlpha * k,
            ai = cosAlpha / k,
            bi = sinAlpha / k,
            ci = (sinAlpha * dy - cosAlpha * dx) / k,
            fi = (sinAlpha * dx + cosAlpha * dy) / k;

        function transform(x, y) {
            x *= sx;
            y *= sy;
            return [a * x - b * y + dx, dy - b * x - a * y];
        }
        transform.invert = function(x, y) {
            return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
        };
        return transform;
    }

    function projection(project) {
        return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
        var project,
            k = 150, // scale
            x = 480,
            y = 250, // translate
            lambda = 0,
            phi = 0, // center
            deltaLambda = 0,
            deltaPhi = 0,
            deltaGamma = 0,
            rotate, // pre-rotate
            alpha = 0, // post-rotate angle
            sx = 1, // reflectX
            sy = 1, // reflectX
            theta = null,
            preclip = clipAntimeridian, // pre-clip angle
            x0 = null,
            y0, x1, y1, postclip = identity, // post-clip extent
            delta2 = 0.5, // precision
            projectResample,
            projectTransform,
            projectRotateTransform,
            cache,
            cacheStream;

        function projection(point) {
            return projectRotateTransform(point[0] * radians, point[1] * radians);
        }

        function invert(point) {
            point = projectRotateTransform.invert(point[0], point[1]);
            return point && [point[0] * degrees, point[1] * degrees];
        }

        projection.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
        };

        projection.preclip = function(_) {
            return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
        };

        projection.postclip = function(_) {
            return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
        };

        projection.clipAngle = function(_) {
            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
        };

        projection.clipExtent = function(_) {
            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
                [x0, y0],
                [x1, y1]
            ];
        };

        projection.scale = function(_) {
            return arguments.length ? (k = +_, recenter()) : k;
        };

        projection.translate = function(_) {
            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
        };

        projection.center = function(_) {
            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
        };

        projection.rotate = function(_) {
            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
        };

        projection.angle = function(_) {
            return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
        };

        projection.reflectX = function(_) {
            return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
        };

        projection.reflectY = function(_) {
            return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
        };

        projection.precision = function(_) {
            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
        };

        projection.fitExtent = function(extent, object) {
            return fitExtent(projection, extent, object);
        };

        projection.fitSize = function(size, object) {
            return fitSize(projection, size, object);
        };

        projection.fitWidth = function(width, object) {
            return fitWidth(projection, width, object);
        };

        projection.fitHeight = function(height, object) {
            return fitHeight(projection, height, object);
        };

        function recenter() {
            var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
                transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
            rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
            projectTransform = compose(project, transform);
            projectRotateTransform = compose(rotate, projectTransform);
            projectResample = resample(projectTransform, delta2);
            return reset();
        }

        function reset() {
            cache = cacheStream = null;
            return projection;
        }

        return function() {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return recenter();
        };
    }

    function conicProjection(projectAt) {
        var phi0 = 0,
            phi1 = pi / 3,
            m = projectionMutator(projectAt),
            p = m(phi0, phi1);

        p.parallels = function(_) {
            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
        };

        return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
        var cosPhi0 = cos(phi0);

        function forward(lambda, phi) {
            return [lambda * cosPhi0, sin(phi) / cosPhi0];
        }

        forward.invert = function(x, y) {
            return [x / cosPhi0, asin(y * cosPhi0)];
        };

        return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
        var sy0 = sin(y0),
            n = (sy0 + sin(y1)) / 2;

        // Are the parallels symmetrical around the Equator?
        if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

        var c = 1 + sy0 * (2 * n - sy0),
            r0 = sqrt(c) / n;

        function project(x, y) {
            var r = sqrt(c - 2 * n * sin(y)) / n;
            return [r * sin(x *= n), r0 - r * cos(x)];
        }

        project.invert = function(x, y) {
            var r0y = r0 - y,
                l = atan2(x, abs(r0y)) * sign(r0y);
            if (r0y * n < 0)
                l -= pi * sign(x) * sign(r0y);
            return [l / n, asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
        };

        return project;
    }

    function conicEqualArea() {
        return conicProjection(conicEqualAreaRaw)
            .scale(155.424)
            .center([0, 33.6442]);
    }

    function albers() {
        return conicEqualArea()
            .parallels([29.5, 45.5])
            .scale(1070)
            .translate([480, 250])
            .rotate([96, 0])
            .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
        var n = streams.length;
        return {
            point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
            sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
            lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
            lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
            polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
            polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
        };
    }

    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
        var cache,
            cacheStream,
            lower48 = albers(),
            lower48Point,
            alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
            alaskaPoint, // EPSG:3338
            hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
            hawaiiPoint, // ESRI:102007
            point, pointStream = { point: function(x, y) { point = [x, y]; } };

        function albersUsa(coordinates) {
            var x = coordinates[0],
                y = coordinates[1];
            return point = null,
                (lower48Point.point(x, y), point) ||
                (alaskaPoint.point(x, y), point) ||
                (hawaiiPoint.point(x, y), point);
        }

        albersUsa.invert = function(coordinates) {
            var k = lower48.scale(),
                t = lower48.translate(),
                x = (coordinates[0] - t[0]) / k,
                y = (coordinates[1] - t[1]) / k;
            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska :
                y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii :
                lower48).invert(coordinates);
        };

        albersUsa.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
        };

        albersUsa.precision = function(_) {
            if (!arguments.length) return lower48.precision();
            lower48.precision(_), alaska.precision(_), hawaii.precision(_);
            return reset();
        };

        albersUsa.scale = function(_) {
            if (!arguments.length) return lower48.scale();
            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };

        albersUsa.translate = function(_) {
            if (!arguments.length) return lower48.translate();
            var k = lower48.scale(),
                x = +_[0],
                y = +_[1];

            lower48Point = lower48
                .translate(_)
                .clipExtent([
                    [x - 0.455 * k, y - 0.238 * k],
                    [x + 0.455 * k, y + 0.238 * k]
                ])
                .stream(pointStream);

            alaskaPoint = alaska
                .translate([x - 0.307 * k, y + 0.201 * k])
                .clipExtent([
                    [x - 0.425 * k + epsilon, y + 0.120 * k + epsilon],
                    [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]
                ])
                .stream(pointStream);

            hawaiiPoint = hawaii
                .translate([x - 0.205 * k, y + 0.212 * k])
                .clipExtent([
                    [x - 0.214 * k + epsilon, y + 0.166 * k + epsilon],
                    [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]
                ])
                .stream(pointStream);

            return reset();
        };

        albersUsa.fitExtent = function(extent, object) {
            return fitExtent(albersUsa, extent, object);
        };

        albersUsa.fitSize = function(size, object) {
            return fitSize(albersUsa, size, object);
        };

        albersUsa.fitWidth = function(width, object) {
            return fitWidth(albersUsa, width, object);
        };

        albersUsa.fitHeight = function(height, object) {
            return fitHeight(albersUsa, height, object);
        };

        function reset() {
            cache = cacheStream = null;
            return albersUsa;
        }

        return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
        return function(x, y) {
            var cx = cos(x),
                cy = cos(y),
                k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
            return [
                k * cy * sin(x),
                k * sin(y)
            ];
        }
    }

    function azimuthalInvert(angle) {
        return function(x, y) {
            var z = sqrt(x * x + y * y),
                c = angle(z),
                sc = sin(c),
                cc = cos(c);
            return [
                atan2(x * sc, z * cc),
                asin(z && y * sc / z)
            ];
        }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
        return sqrt(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
        return 2 * asin(z / 2);
    });

    function azimuthalEqualArea() {
        return projection(azimuthalEqualAreaRaw)
            .scale(124.75)
            .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
        return (c = acos(c)) && c / sin(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
        return z;
    });

    function azimuthalEquidistant() {
        return projection(azimuthalEquidistantRaw)
            .scale(79.4188)
            .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
        return [lambda, log(tan((halfPi + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
        return [x, 2 * atan(exp(y)) - halfPi];
    };

    function mercator() {
        return mercatorProjection(mercatorRaw)
            .scale(961 / tau);
    }

    function mercatorProjection(project) {
        var m = projection(project),
            center = m.center,
            scale = m.scale,
            translate = m.translate,
            clipExtent = m.clipExtent,
            x0 = null,
            y0, x1, y1; // clip extent

        m.scale = function(_) {
            return arguments.length ? (scale(_), reclip()) : scale();
        };

        m.translate = function(_) {
            return arguments.length ? (translate(_), reclip()) : translate();
        };

        m.center = function(_) {
            return arguments.length ? (center(_), reclip()) : center();
        };

        m.clipExtent = function(_) {
            return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [
                [x0, y0],
                [x1, y1]
            ];
        };

        function reclip() {
            var k = pi * scale(),
                t = m(rotation(m.rotate()).invert([0, 0]));
            return clipExtent(x0 == null ?
                [
                    [t[0] - k, t[1] - k],
                    [t[0] + k, t[1] + k]
                ] : project === mercatorRaw ?
                [
                    [Math.max(t[0] - k, x0), y0],
                    [Math.min(t[0] + k, x1), y1]
                ] :
                [
                    [x0, Math.max(t[1] - k, y0)],
                    [x1, Math.min(t[1] + k, y1)]
                ]);
        }

        return reclip();
    }

    function tany(y) {
        return tan((halfPi + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
        var cy0 = cos(y0),
            n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
            f = cy0 * pow(tany(y0), n) / n;

        if (!n) return mercatorRaw;

        function project(x, y) {
            if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; } else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
            var r = f / pow(tany(y), n);
            return [r * sin(n * x), f - r * cos(n * x)];
        }

        project.invert = function(x, y) {
            var fy = f - y,
                r = sign(n) * sqrt(x * x + fy * fy),
                l = atan2(x, abs(fy)) * sign(fy);
            if (fy * n < 0)
                l -= pi * sign(x) * sign(fy);
            return [l / n, 2 * atan(pow(f / r, 1 / n)) - halfPi];
        };

        return project;
    }

    function conicConformal() {
        return conicProjection(conicConformalRaw)
            .scale(109.5)
            .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
        return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
        return projection(equirectangularRaw)
            .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
        var cy0 = cos(y0),
            n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
            g = cy0 / n + y0;

        if (abs(n) < epsilon) return equirectangularRaw;

        function project(x, y) {
            var gy = g - y,
                nx = n * x;
            return [gy * sin(nx), g - gy * cos(nx)];
        }

        project.invert = function(x, y) {
            var gy = g - y,
                l = atan2(x, abs(gy)) * sign(gy);
            if (gy * n < 0)
                l -= pi * sign(x) * sign(gy);
            return [l / n, g - sign(n) * sqrt(x * x + gy * gy)];
        };

        return project;
    }

    function conicEquidistant() {
        return conicProjection(conicEquidistantRaw)
            .scale(131.154)
            .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
        var l = asin(M * sin(phi)),
            l2 = l * l,
            l6 = l2 * l2 * l2;
        return [
            lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
            l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
        ];
    }

    equalEarthRaw.invert = function(x, y) {
        var l = y,
            l2 = l * l,
            l6 = l2 * l2 * l2;
        for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
            fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
            fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
            l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
            if (abs(delta) < epsilon2) break;
        }
        return [
            M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
            asin(sin(l) / M)
        ];
    };

    function equalEarth() {
        return projection(equalEarthRaw)
            .scale(177.158);
    }

    function gnomonicRaw(x, y) {
        var cy = cos(y),
            k = cos(x) * cy;
        return [cy * sin(x) / k, sin(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
        return projection(gnomonicRaw)
            .scale(144.049)
            .clipAngle(60);
    }

    function identity$1() {
        var k = 1,
            tx = 0,
            ty = 0,
            sx = 1,
            sy = 1, // scale, translate and reflect
            alpha = 0,
            ca, sa, // angle
            x0 = null,
            y0, x1, y1, // clip extent
            kx = 1,
            ky = 1,
            transform = transformer({
                point: function(x, y) {
                    var p = projection([x, y]);
                    this.stream.point(p[0], p[1]);
                }
            }),
            postclip = identity,
            cache,
            cacheStream;

        function reset() {
            kx = k * sx;
            ky = k * sy;
            cache = cacheStream = null;
            return projection;
        }

        function projection(p) {
            var x = p[0] * kx,
                y = p[1] * ky;
            if (alpha) {
                var t = y * ca - x * sa;
                x = x * ca + y * sa;
                y = t;
            }
            return [x + tx, y + ty];
        }
        projection.invert = function(p) {
            var x = p[0] - tx,
                y = p[1] - ty;
            if (alpha) {
                var t = y * ca + x * sa;
                x = x * ca - y * sa;
                y = t;
            }
            return [x / kx, y / ky];
        };
        projection.stream = function(stream) {
            return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
        };
        projection.postclip = function(_) {
            return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
        };
        projection.clipExtent = function(_) {
            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [
                [x0, y0],
                [x1, y1]
            ];
        };
        projection.scale = function(_) {
            return arguments.length ? (k = +_, reset()) : k;
        };
        projection.translate = function(_) {
            return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
        };
        projection.angle = function(_) {
            return arguments.length ? (alpha = _ % 360 * radians, sa = sin(alpha), ca = cos(alpha), reset()) : alpha * degrees;
        };
        projection.reflectX = function(_) {
            return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
        };
        projection.reflectY = function(_) {
            return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
        };
        projection.fitExtent = function(extent, object) {
            return fitExtent(projection, extent, object);
        };
        projection.fitSize = function(size, object) {
            return fitSize(projection, size, object);
        };
        projection.fitWidth = function(width, object) {
            return fitWidth(projection, width, object);
        };
        projection.fitHeight = function(height, object) {
            return fitHeight(projection, height, object);
        };

        return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
        var phi2 = phi * phi,
            phi4 = phi2 * phi2;
        return [
            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
        ];
    }

    naturalEarth1Raw.invert = function(x, y) {
        var phi = y,
            i = 25,
            delta;
        do {
            var phi2 = phi * phi,
                phi4 = phi2 * phi2;
            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
                (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
        } while (abs(delta) > epsilon && --i > 0);
        return [
            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
            phi
        ];
    };

    function naturalEarth1() {
        return projection(naturalEarth1Raw)
            .scale(175.295);
    }

    function orthographicRaw(x, y) {
        return [cos(y) * sin(x), sin(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin);

    function orthographic() {
        return projection(orthographicRaw)
            .scale(249.5)
            .clipAngle(90 + epsilon);
    }

    function stereographicRaw(x, y) {
        var cy = cos(y),
            k = 1 + cos(x) * cy;
        return [cy * sin(x) / k, sin(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
        return 2 * atan(z);
    });

    function stereographic() {
        return projection(stereographicRaw)
            .scale(250)
            .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
        return [log(tan((halfPi + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
        return [-y, 2 * atan(exp(x)) - halfPi];
    };

    function transverseMercator() {
        var m = mercatorProjection(transverseMercatorRaw),
            center = m.center,
            rotate = m.rotate;

        m.center = function(_) {
            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };

        m.rotate = function(_) {
            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };

        return rotate([0, 0, 90])
            .scale(159.155);
    }

    exports.geoAlbers = albers;
    exports.geoAlbersUsa = albersUsa;
    exports.geoArea = area;
    exports.geoAzimuthalEqualArea = azimuthalEqualArea;
    exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
    exports.geoAzimuthalEquidistant = azimuthalEquidistant;
    exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
    exports.geoBounds = bounds;
    exports.geoCentroid = centroid;
    exports.geoCircle = circle;
    exports.geoClipAntimeridian = clipAntimeridian;
    exports.geoClipCircle = clipCircle;
    exports.geoClipExtent = extent;
    exports.geoClipRectangle = clipRectangle;
    exports.geoConicConformal = conicConformal;
    exports.geoConicConformalRaw = conicConformalRaw;
    exports.geoConicEqualArea = conicEqualArea;
    exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
    exports.geoConicEquidistant = conicEquidistant;
    exports.geoConicEquidistantRaw = conicEquidistantRaw;
    exports.geoContains = contains;
    exports.geoDistance = distance;
    exports.geoEqualEarth = equalEarth;
    exports.geoEqualEarthRaw = equalEarthRaw;
    exports.geoEquirectangular = equirectangular;
    exports.geoEquirectangularRaw = equirectangularRaw;
    exports.geoGnomonic = gnomonic;
    exports.geoGnomonicRaw = gnomonicRaw;
    exports.geoGraticule = graticule;
    exports.geoGraticule10 = graticule10;
    exports.geoIdentity = identity$1;
    exports.geoInterpolate = interpolate;
    exports.geoLength = length;
    exports.geoMercator = mercator;
    exports.geoMercatorRaw = mercatorRaw;
    exports.geoNaturalEarth1 = naturalEarth1;
    exports.geoNaturalEarth1Raw = naturalEarth1Raw;
    exports.geoOrthographic = orthographic;
    exports.geoOrthographicRaw = orthographicRaw;
    exports.geoPath = index;
    exports.geoProjection = projection;
    exports.geoProjectionMutator = projectionMutator;
    exports.geoRotation = rotation;
    exports.geoStereographic = stereographic;
    exports.geoStereographicRaw = stereographicRaw;
    exports.geoStream = geoStream;
    exports.geoTransform = transform;
    exports.geoTransverseMercator = transverseMercator;
    exports.geoTransverseMercatorRaw = transverseMercatorRaw;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
$('#carousel').hide();

if (isSafariBrwsr) {
    //  $('.emotional.owl-carousel img.owl-lazy').eq(0).attr("onload", " if($(this).height()>0){ $('.emotional.owl-carousel, .emotional.owl-carousel .owl-stage, .emotional.owl-carousel .owl-stage-outer').css('height', $(this).height()); } ");
    $('.emotional.owl-carousel img.owl-lazy').eq(0).attr("onload", "if($(this).height()>0){ $(this).closest('.owl-carousel').css('height', $(this).height()); $(this).closest('.owl-carousel .owl-stage-outer').css('height', $(this).height()); $(this).closest('.owl-carousel .owl-stage').css('height', $(this).height()); } ");
}
carTimerCnt = 0;

function setObjectFitCover() {
    // Riduce proporzionalmente le dimensioni dello slider partendo da un height:580px (schermo >= 1023px)
    var screen_width = window.screen.width;
    var setObjFit = 0;
    var cruscottoTop = 0;




    if ((screen_width < 1023) && (screen_width > 767)) {
        setObjFit = 0.567 * parseInt(screen_width);
        cruscottoTop = 0.2586 * parseInt(setObjFit);

        //$('head').append('<style>@media screen and (max-width:1023px){#trainSearchTitle{box-shadow:0px -3px 5px rgba(0,0,0,0.5)}}</style>');

        $('head').append('<style>@media screen and (max-width:1023px) and (min-width:768px)and (orientation: portrait){#carousel .item img{height:' + setObjFit + 'px}#cruscotto{margin-top:-' + cruscottoTop + 'px}}</style>');
    } else if (screen_width == 1023) {
        setObjFit = 580;
        cruscottoTop = 150;
        $('head').append('<style>@media screen and (max-width:1023px) and (min-width:768px)and (orientation: portrait){#carousel .item img{height:' + setObjFit + 'px}#cruscotto{margin-top:-' + cruscottoTop + 'px}}</style>');
    }
}

function setNavigationeSlider() {
    /* Controllo se esiste il cruscotto altrimenti abbasso la navigazione dello slider*/
    var isCruscottoNewExist = !!document.getElementById("cruscottoNew")
    var isCruscottoExist = !!document.getElementById("cruscotto")
    if (!isCruscottoNewExist && !isCruscottoExist) {
        $("#carousel .owl-theme .owl-dots").css("bottom", "50px");
    } else {
        $("#carousel .owl-theme .owl-dots").css("bottom", "200px");
    }
}

function loadSlideShow() {
    //$('#preCarousel').remove();
    changeImgsSetByScreenWidth('.owl-carousel', '.item img', false, false);
    var owl = $('.owl-carousel');

    owl.owlCarousel({
        isOwlCarouselResized: false,
        itemsRemoved: false,
        /* custom properties tcom responsive slides... */
        items: 1,
        lazyLoad: true,
        /* lazyContent: true, */
        autoplay: true,
        autoplayTimeout: 7500,
        autoplayHoverPause: true,
        smartSpeed: 600,
        animateIn: tcomHpCarouselTransitionEffects.animateIn,
        animateOut: tcomHpCarouselTransitionEffects.animateOut,
        nav: true,
        navText: ["<img src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/hp/carousel-arrow-left.png' alt='' />", "<img src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/hp/carousel-arrow-right.png' alt='' />"],
        loop: true,
        autoHeight: true
    });

    var carTimer = setInterval(function() {
        carTimerCnt = carTimerCnt + 1;
        if ((owl.height() > 1) || (carTimerCnt > 120)) {
            clearInterval(carTimer);
        }
        owl.trigger('refresh.owl.carousel', [100]);
    }, 500);

    /* fix 'autoplayHoverPause' missing re-animation after mouse-over */
    owl.mouseover(function() {
        owl.trigger('stop.owl.autoplay');
    });
    if (isSafariBrwsr) {
        owl.mouseleave(function() {
            owl.trigger('play.owl.autoplay', [7000]);
        });
    } else {
        owl.mouseleave(function() {
            owl.trigger('play.owl.autoplay', [1000]);
        });
    }

    /* preloader for lazyLoad */
    owl.on('loaded.owl.lazy', function(event) {
        $('#preCarousel').remove();
        $('#carousel').show();
        var totitem = event.item.count + 2;
        var nextitem = event.item.index + 1;
        //alert('totitem='+totitem+', nextitem='+nextitem);
        if (nextitem <= totitem) {
            var imgsrc = $(event.target).find('.item').eq(nextitem).find('img').data('src');

            $(event.target).find('.item').eq(nextitem).find('img').attr("src", imgsrc).css("opacity", "1");
        }

        var componentIndex = 0;
        $('.item a[data-launch]').each(function(i,e){
            //console.log($(this).data('launch'));
            var oldAttr = $(this).data('launch');
            /*var urlTitle = window.location.href;
            var pageTitle = urlTitle.substring(urlTitle.lastIndexOf('/') + 1, urlTitle.lastIndexOf('.html'));*/
            var pageTitle = document.title;
            var parentClass = this.closest('.section').classList[0];
            var elementClass = this.parentElement.id !== '' ? this.parentElement.id : this.parentElement.classList[0];
            var newAttr = oldAttr + "_" + formatString(pageTitle) + "_" + parentClass + "_" + elementClass + "_" + componentIndex;
            $(this).attr("data-launch",newAttr);
            componentIndex +=1 ;
        });
        function formatString(str){
            return str.replace(/[^\w]/g, "_");
        }

        function transformUrl(oldUrl){
            oldUrl.searchParams.append('referrer', referrer);
            if(src != '' && src != null) oldUrl.searchParams.append('src', src);
            if(cid != '') oldUrl.searchParams.append('cid', cid);
            return oldUrl.href;
        }
    });

    /* load right Images-Set for current screen width */
    var owlCarouselData = $('.owl-carousel').data('owl.carousel');
    owl.on('resized.owl.carousel', function(event) {
        changeImgsSetByScreenWidth('.owl-carousel', '.owl-item img', true, event);
        owlCarouselData.options.isOwlCarouselResized = true;
    });
    owl.on('translate.owl.carousel', function(event) {
        if (owlCarouselData.options.isOwlCarouselResized) { changeImgsSetByScreenWidth('.owl-carousel', '.owl-item img', true, event); }
    });
    setObjectFitCover();
    setNavigationeSlider();
    setHeightSlider();

    $('#breadcrumbs>a').focusin(function() {
        $("#menu ul.second-lvl").slideUp(300, "swing");
    });
}

function loadSlider() {
    var $geoDiv = $('div.slideshow-container');
    var nodePath = $('#nodePath').val();
    var isRegion = $('input#isRegionAval').val();
    if ($geoDiv.length && nodePath) {

        function sliderCall(region) {
            $.ajax({
                type: 'GET',
                url: nodePath + '.html?wcmmode=disabled&region=' + region,
                success: function(data) {
                    $geoDiv.html(data);
                    loadSlideShow();
                    fs.ytPlayer.init();
                    fs.ytPlayerDialog.init()
                }
            });
        }

        if ('geolocation' in navigator && isRegion == "true") {
            var pos;

            function callback() {
                $.getJSON("/etc.clientlibs/tcom/clientlibs/clientlib-homepage/resources/regions.json", function(json) {
                    var tJson = topojson.feature(json, 'regions').features;

                    var actualRegion = 'all';

                    if (pos && pos.coords.latitude && pos.coords.longitude) {
                        var position = [pos.coords.longitude, pos.coords.latitude];

                        for (var i = 0; i < tJson.length; i++) {
                            var region = tJson[i];
                            if (d3.geoContains(region, position)) {
                                actualRegion = region.properties.reg_name;
                                break;
                            }
                        }
                    }

                    sliderCall(actualRegion);
                });
            };

            function errorCallback() {
                sliderCall('all');
            };

            function _onSuccess(callback, position) {
                pos = position
                callback();
            };

            function _onError(errCallback, error) {
                errCallback();
            };

            var onS = _onSuccess.bind(this, callback);
            var onE = _onError.bind(this, errorCallback);


            try {
                navigator.geolocation.getCurrentPosition(onS, onE, { maximumAge: 0, timeout: 2000, enableHighAccuracy: false });
            } catch (evt) {
                errorCallback();
            }
        } else {
            sliderCall('all');
        }
    }
}

$(document).ready(function() {
    setObjectFitCover();
    //loadSlider();
    setTimeout(loadSlider, 400);
});

function setHeightSlider() {
	/* Imposta l'altezza dello slider partendo dall'immagine che viene inserita */
	var screen_width = window.screen.width;
	if (screen_width > 1023) {

		const nodeList = document.querySelectorAll(".slideshow-container #carousel .owl-lazy");
		console.log(nodeList)
		heightBackCruscotto = 180
		for (let i = 0; i < nodeList.length; i++) {
			nodeList[i].onload = function () {
				let heightSlider = nodeList[i].naturalHeight
				console.log(nodeList[i])
				const topBackCruscotto = heightSlider - heightBackCruscotto
				$("#carousel .item img").css("height", nodeList[i].naturalHeight + "px");
				$(".back_cruscotto").css("top", topBackCruscotto + "px");
			}
		}
	}
}

var changeImgsSetByScreenWidth = function(carouselSelector, ImagesSelectorToChange, isResize, event) {
    var itemsToRemove = [];
    $(carouselSelector).find(ImagesSelectorToChange).each(function(index) {
        if (($(window).width() <= 1023) && ($(window).height() <= 1023)) {
            // item-slide NOT visible on smartphones on page load!
            if ((!isResize) && ($(this).attr('data-mobSrc').length == 0)) {
                $(this).parents('div.item').eq(0).remove();
            }
            if ((isResize) && ($(this).attr('data-mobSrc').length == 0) && (parseInt($(this).attr('data-slideIdx')) < event.item.count)) {
                itemsToRemove.push(parseInt($(this).attr('data-slideIdx')));
            }
            $(this).attr('data-src', $(this).attr('data-mobSrc'));
            if (isResize) {
                $(this).attr('src', $(this).attr('data-mobSrc'));
            }
        } else /* if(($(window).width() >= 1024) && ($(window).height() >= 1024)) */ {
            $(this).attr('data-src', $(this).attr('data-deskSrc'));
            if (isResize) {
                $(this).attr('src', $(this).attr('data-deskSrc'));
            }
        }
    }).promise().done(function() {
        var carouselData = $(carouselSelector).data('owl.carousel');
        itemsToRemove = $.unique(itemsToRemove);
        if ((itemsToRemove.length > 0) && (!carouselData.options.itemsRemoved)) {
            for (var i = itemsToRemove.length - 1; i >= 0; i--) {
                $(carouselSelector).trigger('remove.owl.carousel', [itemsToRemove[i]]).trigger('refresh.owl.carousel');

            }
            carouselData.options.itemsRemoved = true;
        }
    });
};

//Start Section 03/09/2020
(function($) {
    if (!this.fs) this.fs = new Object;
})(jQuery);

//Start Module: YouTube Player
(function($) {
    'use strict';

    var playerContainer;
    var ytPlayerDialog = window.fs.ytPlayerDialog || new Object({});

    ytPlayerDialog.init = function() {
        playerContainer = $('.youtube-player-dialog-container');

        ytPlayerDialog.players = [];
        playerContainer.each(function(i, pc) {
            var container = $(pc);
            container.append('<div class="youtube-player-dialog-container--overlay"></div>')
                .append('<a class="youtube-player-dialog-container--controls--play" href="javascript:void(0)" title= "Play the video">Play</a>');
        });

        $('#carousel').on('click', '.youtube-player-dialog-container--overlay,.youtube-player-dialog-container--controls--play', function(e) {
            e.stopPropagation();
            e.preventDefault();

            var $pc = $(this).parent();

            var modal = $('#' + $pc.data('player-modal-id'));
            var modalTitle = modal.find('.modal-title');
            var modalPlayerContainer = modal.find('.modal-body .player-container');

            modalPlayerContainer.append('<div class=\"player\"></div>');
            modalPlayerContainer.addClass('loading');

            var modalPlayer = modalPlayerContainer.find('.player');

            modalTitle.text($pc.data('player-modal-title'));
            modalPlayer.attr('id', $pc.data('video-id'));

            var vidId = $pc.data('video-id');
            var isLoop = $pc.data('video-enable-loop') || false;
            var plrVars = {}
            if (isLoop) {
                plrVars = {
                    rel: 0,
                    iv_load_policy: 3,
                    showinfo: 0,
                    loop: 1,
                    playlist: vidId
                }
            } else {
                plrVars = {
                    rel: 0,
                    iv_load_policy: 3,
                    showinfo: 0
                }
            }

            var player = new YT.Player(vidId, {
                videoId: vidId,
                playerVars: plrVars,
                events: {
                    'onReady': function() {
                        modalPlayerContainer.removeClass('loading');
                        window.setTimeout(function() {
                            player.playVideo();
                        }, 1000);
                    }
                }
            });

            modal.modal('show');

            modal.on('hide.bs.modal', function() {
                modalPlayerContainer.find('iframe').remove();
            });
        });
    };

    window.fs.ytPlayerDialog = ytPlayerDialog;
})(jQuery);
//End Module: YouTube Player
; //Start Module: YouTube Player
(function($) {
    'use strict';

    var playerContainer;
    var ytPlayer = window.fs.ytPlayer || new Object({});

    ytPlayer.init = function() {
        playerContainer = $('.youtube-player-container');

        ytPlayer.players = [];
        playerContainer.each(function(i, e) {
            var topLabel = $(e).siblings('.fs-card--category');
            var bottomLabel = $(e).siblings('.fs-card--content');
            var overlay = $(e).find('.youtube-player--overlay');
            var controls = $(e).find('.youtube-player--overlay--controls');
            var player = new YT.Player($(e).data('video-id'), {
                videoId: $(e).data('video-id'),
                playerVars: {
                    rel: 0,
                    iv_load_policy: 3,
                    showinfo: 0
                },
                events: {
                    'onReady': function() {
                        $(e).addClass('player-ready'); //This state will place the icon on overlay layer
                    },
                    'onStateChange': function() {
                        if (player.getPlayerState() == YT.PlayerState.CUED || player.getPlayerState() == YT.PlayerState.ENDED) {
                            ytPlayer.showCustomLayers(player);
                        }
                    }
                }
            });

            ytPlayer.players.push(player);

            topLabel.addClass('sliding-item');
            bottomLabel.addClass('sliding-item');

            topLabel
                .on('mouseenter', function() {
                    overlay.addClass('active');
                    controls.addClass('active');
                })
                .on('mouseout', function() {
                    overlay.removeClass('active');
                    controls.removeClass('active');
                });

            bottomLabel
                .on('mouseenter', function() {
                    overlay.addClass('active');
                    controls.addClass('active');
                })
                .on('mouseout', function() {
                    overlay.removeClass('active');
                    controls.removeClass('active');
                });

            overlay.on('click', function() {
                player.playVideo();
                ytPlayer.hideCustomLayers(player);
            });
        });
    };

    ytPlayer.showCustomLayers = function(player) {
        var topLabel = $('#' + player.getIframe().id).parent().siblings('.fs-card--category');
        var bottomLabel = $('#' + player.getIframe().id).parent().siblings('.fs-card--content');
        var overlay = $('#' + player.getIframe().id).siblings('.youtube-player--overlay');

        if (topLabel.length) topLabel.css('margin-top', '0');
        if (bottomLabel.length) bottomLabel.css('margin-bottom', '0');
        if (overlay.length) overlay.removeClass('hide fade');
    };

    ytPlayer.hideCustomLayers = function(player) {
        var topLabel = $('#' + player.getIframe().id).parent().siblings('.fs-card--category');
        var bottomLabel = $('#' + player.getIframe().id).parent().siblings('.fs-card--content');
        var overlay = $('#' + player.getIframe().id).siblings('.youtube-player--overlay');

        if (topLabel.length) topLabel.css('margin-top', -1 * (topLabel.position().top + topLabel.outerHeight(true)).toString() + 'px');
        if (bottomLabel.length) bottomLabel.css('margin-bottom', -1 * (parseInt(bottomLabel.css('bottom')) + bottomLabel.outerHeight(true)) + 'px');
        if (overlay.length) {
            overlay.addClass('fade');
            window.setTimeout(function() {
                overlay.addClass('hide');
            }, 400);
        }
    };

    window.fs.ytPlayer = ytPlayer;
})(jQuery);
//End Module: YouTube Player
// Disabilita le freccette se il numero di grafiche visibili e pari a quelle caricate - START
function checkServiceSlider() {
  var nItem = 0;
    if ($("body").width() < 480) {
        nItem = 2;
    }else if($("body").width() < 640){
        nItem = 3;
    }else if($("body").width() < 768){
        nItem = 4;
    }else if($("body").width() < 1024){
        nItem = 5;
    }else if($("body").width() > 1023){
        nItem = 6;
    }
    var nListElem = $('#servizi-disp').find('.swiper-slide').length;
    var disabilito = disabilitaFrecceCarosello(nItem, nListElem, $('#servizi-disp').find('>div'));

    if(disabilito == true){
        $(".box-container-swiper .swiper-button-prev").addClass("nascondi");
        $(".box-container-swiper .swiper-button-next").addClass("nascondi");
    }else{
        $(".box-container-swiper .swiper-button-prev").removeClass("nascondi");
        $(".box-container-swiper .swiper-button-next").removeClass("nascondi");
    }

    var swiper = new Swiper('.box-container-swiper .swiper-container', {
        slidesPerView: nItem,
        spaceBetween: 0,
        slidesPerGroup: 3,
        loop: true,
        loopFillGroupWithBlank: false,
        allowTouchMove: !(disabilito),
        navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
        },
        breakpoints: {
            315: {
              slidesPerView: 2,
              slidesPerGroup: 1,
              spaceBetween: 0,
            },
            480: {
              slidesPerView: 3,
              slidesPerGroup: 1,
              spaceBetween: 0,
            },
            640: {
              slidesPerView: 4,
              slidesPerGroup: 1,
              spaceBetween: 0,
            },
            768: {
              slidesPerView: 5,
              slidesPerGroup: 2,
              spaceBetween: 0,
            },
            1024: {
              slidesPerView: 6,
              slidesPerGroup: 3,
              spaceBetween: 0,
            },
        }
    });
}

$(window).on('load', function() {
    checkServiceSlider();
});

$(window).resize(function() {
  checkServiceSlider();
});
(function(jQuery) {
	$.fn.breakingNews = function(params) {
		var defaults = {
			width: '100%',
			modul: 'breakingNews',
			//color			:'light',
			//border		:false,
			effect: 'fade"',
			fontstyle: 'normal',
			autoplay: true,
			timer: 3000,
			dynamicDelayMult: 5,
			animationSpeedMult: 10
		};
		var feeds = [];
		var labels = [];
		var params = $.extend(defaults, params);
		var myTimeout;
		return this.each(function() {
			//Variables------------------------------------
			params.modul = $("#" + $(this).attr("id"));
			var newslist = $(this).find(".news-list");
			var timername = "";
			var active = 0;
			var previous = 0;
			var count = params.modul.find("ul li").length;

			var changestate = true;
			changeNews(true)
			/*
				params.modul.find("ul li").eq(active).fadeIn();
				var elToAnimate=params.modul.find("ul li").eq(active).find("div");
				var containerSize=params.modul.find("ul li").eq(active).width();
				var elToAnimateSize=elToAnimate.width();
				var offset=elToAnimateSize-containerSize;
				var dynamicDelay=(containerSize*5)+200;



                $('.breakingNews>.news-list>ul>li div').stop().stop().css('left',0);
                if (elToAnimateSize > containerSize){
                    elToAnimate.delay(dynamicDelay).animate({left:-offset},offset*10,'linear',function() {
                        if (params.autoplay && (count > 1)){

                            myTimeout=setTimeout(function(){

                                autoPlay()
                            },params.timer);

                        }
                    })
                }*/
			//resizeEvent();

			if (params.autoplay && (count > 1)) {
				//timername=setInterval(function(){autoPlay()},params.timer);

				/*$('.breakingNews>.news-list>ul>li:first-child a').animate({left:-(1374-937)},1000,'linear',function() {


				/*
				//$(params.modul).on("mouseenter",function (){
				$(newslist).on("mouseenter",function (){
					clearInterval(timername);
				});

				//$(params.modul).on("mouseleave",function (){
				$(newslist).on("mouseleave",function (){
					timername=setInterval(function(){autoPlay()},params.timer);
				});
				*/
			} else {
				//clearInterval(timername);
			}

			//if (!params.border)
			//{
			//	params.modul.addClass("bn-bordernone");
			//}

			//if (params.fontstyle=="italic")
			//	params.modul.addClass("bn-italic");

			//if (params.fontstyle=="bold")
			//	params.modul.addClass("bn-bold");

			//if (params.fontstyle=="bold-italic")
			//	params.modul.addClass("bn-bold bn-italic");

			//params.modul.addClass("bn-"+params.color);

			//Events---------------------------------------
			$(window).on("resize", function() {
				resizeEvent();
			});

			params.modul.find(".bn-navi span").on("click", function() {
				if (changestate) {
					changestate = false;
					clearTimeout(myTimeout);
					/*previous*/
					if ($(this).index() == 0) {
						active--;
						if (active < 0)
							active = count - 1;
						changeNews();
					}

					/*play-pause*/
					if ($(this).index() == 1) {
						var p = $(this).attr("class");

						if (p == "pause") {
							$(this).attr("class", "play");
							//clearInterval(timername);

						} else {
							$(this).attr("class", "pause");
							//timername=setInterval(function(){autoPlay()},params.timer);
							autoPlay();

						}
						changestate = true;
					}

					/*next*/
					if ($(this).index() == 2) {
						active++;
						if (active == count)
							active = 0;

						changeNews();
					}
				}
			});
			var interval = null;
			var width = $(window).width();
			var numi = 0; //can be removed in production
			function resizeEvent(functionCall) {

				/*if (params.modul.width()<480)
					{
						params.modul.find(".bn-title h2").css({"display":"none"});
						params.modul.find(".bn-title").css({"width":10});
						//params.modul.find("ul").css({"left":8});
						//if (window.screen.width > 479){params.modul.find("ul").css({"left":28});}
					}
					else
					{
						params.modul.find(".bn-title h2").css({"display":"none"});
						params.modul.find(".bn-title").css({"width":"auto"});
						//params.modul.find("ul").css({"left":$(params.modul).find(".bn-title").width()+30});
						//params.modul.find("ul").css({"left":27});
						//if (window.screen.width > 1023){params.modul.find("ul").css({"left":3});}
					}
                    if(params.modul.find("ul li").eq(active).find("div").width()){

					    clearTimeout(myTimeout);
					    $('.breakingNews>.news-list>ul>li div').stop(true,true).css('left',0);
                        changeNews();
                    }*/

				//check for null interval
				if (!interval) {
					//set to new interval
					interval = setInterval(function() {
						//get width to compare
						width2 = $(window).width();
						//if stored width equals new width
						if (width === width2) {
							//clear interval, set to null, and call passed function
							clearInterval(interval);
							interval = null; //precaution
							clearTimeout(myTimeout);
							$('.breakingNews>.news-list>ul>li div').stop(true, true).css('left', 0);
							changeNews(false, true);

						}
						//set width to compare on next interval after half a second
						width = $(window).width();
					}, 500);

				} else {
					//logging that should be removed in production


				}
			}


			function autoPlay() {
				active++;
				if (active == count)
					active = 0;

				changeNews();
			}

			function changeNews(isFirstCall, skipDelay) {

				if (params.effect == "fade") {
					if (!skipDelay) {
						if (isFirstCall) {
							params.modul.find("ul li").eq(active).fadeIn();
						} else {
							params.modul.find("ul li").css({
								"display": "none"
							});
							params.modul.find("ul li").eq(active).fadeIn("slow", function() {
								changestate = true;
							});
						}
					}

					//params.modul.find("ul li").eq(active).find("div").animate({left:-(200)},1000,'linear');
					var elToAnimate = params.modul.find("ul li").eq(active).find("div");
					var containerSize = params.modul.find("ul li").eq(active).width();
					var elToAnimateSize = elToAnimate.width();
					var offset = elToAnimateSize - containerSize + 20;
					var dynamicDelay = (containerSize * params.dynamicDelayMult) + 200;

					$('.breakingNews>.news-list>ul>li div').stop().css('left', 0);

					if (elToAnimateSize > containerSize) {

						elToAnimate.delay(skipDelay ? 500 : dynamicDelay).animate({
							left: -offset
						}, offset * params.animationSpeedMult, 'linear', function() {
							if (params.autoplay && (count > 1)) {
								clearTimeout(myTimeout);

								myTimeout = setTimeout(function() {
									if (params.modul.find(".bn-navi span").hasClass("pause")) {

										autoPlay()
									}
								}, params.timer);
							}
						})
					} else {
						dynamicDelay = (elToAnimateSize * 8) + params.timer;
						clearTimeout(myTimeout);


						myTimeout = setTimeout(function() {
							if (params.modul.find(".bn-navi span").hasClass("pause")) {
								autoPlay();
							}
						}, dynamicDelay);
					}
				} else if (params.effect == "slide-h") {
					params.modul.find("ul li").eq(previous).animate({
						width: 0
					}, function() {
						$(this).css({
							"display": "none",
							"width": "100%"
						});
						params.modul.find("ul li").eq(active).css({
							"width": 0,
							"display": "block"
						});
						params.modul.find("ul li").eq(active).animate({
							width: "100%"
						}, function() {
							changestate = true;
							previous = active;
						});
					});
				} else if (params.effect == "slide-v") {
					if (previous <= active) {
						params.modul.find("ul li").eq(previous).animate({
							top: -60
						});
						params.modul.find("ul li").eq(active).css({
							top: 60,
							"display": "block"
						});
						params.modul.find("ul li").eq(active).animate({
							top: 0
						}, function() {
							previous = active;
							changestate = true;
						});
					} else {
						params.modul.find("ul li").eq(previous).animate({
							top: 60
						});
						params.modul.find("ul li").eq(active).css({
							top: -60,
							"display": "block"
						});
						params.modul.find("ul li").eq(active).animate({
							top: 0
						}, function() {
							previous = active;
							changestate = true;
						});
					}
				}
			}

		});
	};
})(jQuery);


try {
	$("#bn1").breakingNews({
		autoplay: true,
		timer: 3000,
		dynamicDelayMult: 5,
		animationSpeedMult: 20,
		//color		:'light',
		effect: 'fade',
		border: false
	});
} catch (e) {}

try {
	$("#bn2").breakingNews({
		autoplay: true,
		timer: 3000,
		dynamicDelayMult: 5,
		animationSpeedMult: 20,
		//color		:'light',
		effect: 'fade',
		border: false
	});
} catch (e) {}
/* #common script.js - Ver. 28-01-2014 (disable responseTime)# */
/* PREV #common script.js - Ver. 05-06-2013 (intro responseTime)# */

function addOnLoadEvent(func) {
    // aggiunge ONLOAD handler x hacking UNAPPROVE...
    var oldonload = window.onload;
    if (typeof window.onload != 'function') {
        window.onload = func;
    } else {
        window.onload = function() {
            if (oldonload) {
                oldonload();
            }
            func();
        }
    }
}

//window.onload = intercetta;
//addOnLoadEvent(intercetta);


// Site Catalyst: client-side download-time of all hits linked in page-body
/* var ONLOAD_TRACK_TIMEOUT = 60000; */
/* 1 minuto */
/* var _preBodyLoadTimestampValue = new Date().getTime(); */
/* var loadEventTimeRoundedValue = {}; */
/* var trackBodyOnLoadEventTimeOut = setTimeout(function(){ debugLog("(!)Body_Onload_TimedOut(!)"); trackBodyOnLoadEventEsTime(); }, ONLOAD_TRACK_TIMEOUT); */
/* debugLog("Initialized _preBodyLoadTimestampValue=["+_preBodyLoadTimestampValue+"] #"); */
/* addOnLoadEvent(trackBodyOnLoadEventEsTime); */


function intercetta() {
    var url = "";
    for (var i = 0; i < document.links.length; i++) {
        url = document.links[i].href;
        if (url.substring(0, 7) != "mailto:") {
            url = url.split("'");
            url = url.join("\\'");

            if (document.links[i].className.indexOf('linkEsterno') != -1) {
                //document.links[i].href="javascript:open_linkEsterno('"+url+"');";
                $(document.links[i])
                    .off('click')
                    .on('click', function (e) {
                        let eventUrl = $(e.currentTarget).attr('href');
						eventUrl = eventUrl.split("'");
						eventUrl = eventUrl.join("\\'");
						open_linkEsterno(eventUrl);
						return false;
                    });
            }

            if (document.links[i].className.indexOf('linkExt_amico') != -1) {
                var params = "width=516,height=255,status=yes";
                document.links[i].href = "javascript:open_linkEsterno('" + url + "', '" + params + "');";
            }
            if (document.links[i].className.indexOf('linkExt_print') != -1) {
                var params = "width=660,menubar=yes,scrollbars=yes,resizable=yes,status=yes";
                document.links[i].href = "javascript:open_linkEsterno('" + url + "', '" + params + "');";
            }
        }
    }

    if (document.getElementById("formcruscotto") || document.getElementById("formGen")) {
        if (document.getElementById("ar")) {
            enableAndataRitorno();
        }
        if (document.getElementById("datag")) {
            if (document.getElementById("datag").value == "") {
                setFormDefault();
            }
        }
    }

    if (document.getElementById("traffic_scroll") || document.getElementById("banner_meteo") ||
        document.getElementById("emotional") || document.getElementById("mediagallery_scroll")) {
        onload_function();
    }
}
//window.onload = intercetta;
addOnLoadEvent(intercetta);


function open_linkEsterno(url, params) {
    var o;
    if (params)
        o = window.open(url, '_blank', params);
    else
        o = window.open(url, '_blank');

    if (o == undefined) {
        if (confirm("E' stata bloccata l'apertura della pagina in una nuova finestra:\n\n" + url + "\n\nVuoi aprire la pagina nella finestra corrente?")) document.location.href = url;
    }
}


/*About HP FORM */
function setFormDefault() {

    now = new Date();
    d = zeroFill(now.getDate(), 2);
    m = zeroFill(now.getMonth() + 1, 2);
    Y = now.getFullYear();
    H = zeroFill(now.getHours(), 2);
    if (H >= 15 && document.FHOTEL) {
        d++;
    }
    i = zeroFill(now.getMinutes(), 2);

    // Default date per form bigliettazione
    if (document.getElementById("datag")) {
        setField("datag", d);
        setField("datam", m);
        setField("dataa", Y);
        setField("timsh", H);
        setField("timsm", i);
    }
    if (document.getElementById("datag_r")) {
        setField("datag_r", d);
        setField("datam_r", m);
        setField("dataa_r", Y);
        setField("timsh_r", H);
        setField("timsm_r", i);
    }
}

function enableAndataRitorno() {
    if (document.getElementById("ar").checked == false) {
        disattivaRitorno();
    } else {
        attivaRitorno();
    }
}

/*About HP FORM Abbonamenti - OrariAcquisto*/
function setFormAbbDefault() {
    now = new Date();
    now.setDate(now.getDate() + 1); //la data odierna diventa la data di domani

    d = zeroFill(now.getDate(), 2);
    m = zeroFill(now.getMonth() + 1, 2);
    Y = now.getFullYear();
    if (document.getElementById("datag")) {
        setField("datag", d);
        setField("datam", m);
        setField("dataa", Y);
    }
}

function setField(q, v) {
    if (document.getElementById(q)) {
        document.getElementById(q).value = v;
    }
}

function zeroFill(q, z) {
    q = String(q);
    while (q.length < z) q = "0" + q;
    return q;
}

function addDay() {
    var myDate = new Date();
    d1 = zeroFill(myDate.getDate(), 2);
    m1 = zeroFill(myDate.getMonth() + 1, 2);
    Y1 = myDate.getFullYear();

    myDate.setDate(myDate.getDate() + 1); //ottengo la data di domani
    d2 = zeroFill(myDate.getDate(), 2);
    m2 = zeroFill(myDate.getMonth() + 1, 2);
    Y2 = myDate.getFullYear();
    if (document.getElementById("datag")) datag = document.getElementById("datag").value;
    else datag = "";
    if (document.getElementById("datam")) datam = document.getElementById("datam").value;
    else datam = "";
    if (document.getElementById("dataa")) dataa = document.getElementById("dataa").value;
    else dataa = "";
    if (datag == d1 && datam == m1 && dataa == Y1) {
        document.getElementById("datag").value = d2;
        document.getElementById("datam").value = m2;
        document.getElementById("dataa").value = Y2;
    }
}


function setRitorno() {
    var stazin = document.getElementById("stazin");
    var stazout = document.getElementById("stazout");
    var stazin_r = document.getElementById("stazin_r");
    var stazout_r = document.getElementById("stazout_r");

    stazin_r.value = stazout.value;
    stazout_r.value = stazin.value;
};

function attivaRitorno() {
    if (document.getElementById("datag_r")) {
        document.getElementById("datag_r").disabled = false;
        document.getElementById("datam_r").disabled = false;
        document.getElementById("dataa_r").disabled = false;
        document.getElementById("timsh_r").disabled = false;
    }
};

function disattivaRitorno() {
    if (document.getElementById("datag_r")) {
        document.getElementById("datag_r").disabled = true;
        document.getElementById("datam_r").disabled = true;
        document.getElementById("dataa_r").disabled = true;
        document.getElementById("timsh_r").disabled = true;
    }
};

function checkForm() {

    var Y_a = parseInt(document.getElementById("dataa").value, 10);
    var M_a = parseInt(document.getElementById("datam").value, 10);
    var D_a = parseInt(document.getElementById("datag").value, 10);
    var H_a = parseInt(document.getElementById("timsh").value, 10);

    var data_a = new Date(Y_a, M_a - 1, D_a, H_a);

    if (valiDate(data_a, Y_a, M_a, D_a)) {
        if (document.getElementById("ar").checked == true) {
            var Y_r = parseInt(document.getElementById("dataa_r").value, 10);
            var M_r = parseInt(document.getElementById("datam_r").value, 10);
            var D_r = parseInt(document.getElementById("datag_r").value, 10);
            var H_r = parseInt(document.getElementById("timsh_r").value, 10);
            var data_r = new Date(Y_r, M_r - 1, D_r, H_r);

            if (valiDate(data_r, Y_r, M_r, D_r)) {
                if (data_r < data_a) {
                    if (document.getElementById("lang").value == "it") alert("Attenzione: la data del viaggio di ritorno deve essere uguale o successiva a quella di andata");
                    if (document.getElementById("lang").value == "en") alert("Attention: your return journey must occur in the same date or after your departure ");
                    return false;
                } else {
                    setRitorno();
                    return true;
                }
            }
            return false;
        }
        return true;
    }
    return false;
}

function valiDate(td, year, month, day) {
    var result = (td.getFullYear() == year && (td.getMonth() + 1 == month) && td.getDate() == day);
    if (result == false) {
        if (document.getElementById("lang").value == "it") alert("Data non valida");
        if (document.getElementById("lang").value == "en") alert("Wrong Date");
    }
    return result;
}


/* Check Area Riservata */
function controlloAR(formObj) {
    var code = "ok";
    if ((formObj.elements[0].value == '') || (formObj.elements[1].value == '')) {
        alert('ATTENZIONE inserire user e password.');
        code = "ko";
    }
    if (!encrypt(formObj.elements[1].value)) {
        code = "ko";
    }
    if (code != "ko") {
        /*formObj.setAttribute('target', '_blank');*/
        formObj.submit();
    }
    return false;
}

/* Check Area Riservata */
function encrypt(Input) {
    var car = new Array(Input.length);
    for (i = 0; i < Input.length; i++) {
        car[i] = Input.charCodeAt(i);
        if (((car[i] >= 48) && (car[i] <= 57)) ||
            ((car[i] >= 65) && (car[i] <= 90)) ||
            ((car[i] >= 97) && (car[i] <= 122))) {} else {
            alert('La password deve essere formata da lettere e numeri.');
            return false;
        }
    }
    return true;
}

function Tclear(el) {
    if (el.defaultValue == el.value) el.value = ""
}

function openViaggiaTrenoApplicaz(url) {
    if (screen.width > 1024) {
        var w = 1012;
        var h = 715;
        var l = (screen.width - w) / 2;
        var t = (screen.height - h) / 2;
        window.open(url, "", "width=" + w + ",height=" + h + ",top=" + t + ",left=" + l);
    } else {
        var w = screen.width;
        var h = screen.height;
        window.open(url, "", "width=" + w + ",height=" + h + ",top=0,left=0");
    }
}

// #EFFETTUA IL TRIM DI UNA STRINGA#
function Trim(stringa) {
    reTrim = /\s+$|^\s+/g;
    return stringa.replace(reTrim, "");
}

// Site Catalyst: Analisi interazione con l'Homepage FS Italiane
function setSCVarsForm(tabName) {
    if (typeof s_gi != 'undefined') {
        eval("var s=s_gi(s_account);s.linkTrackVars='events';");
        if (tabName === 'biglietti') {
            eval("s.linkTrackEvents='event34';s.events='event34';");
        } else if (tabName === 'abbonamenti') {
            eval("s.linkTrackEvents='event35';s.events='event35';");
        } else if (tabName === 'hotel') {
            eval("s.linkTrackEvents='event36';s.events='event36';");
        }
        eval("s.tl(this,'o','Inizio ricerca '+tabName);");
    }
}

// Site Catalyst: Analisi condivisione di contenuti con social bookmarking
function setSCVarsSocial(socialName) {
    if (typeof s_gi != 'undefined') {
        eval("var s=s_gi(s_account);s.linkTrackVars='eVar34,events';s.linkTrackEvents='event21';s.events='event21';s.eVar34=socialName;s.tl(this,'o','Segnalazione '+socialName);");
    }
}


function trackBodyOnLoadEventEsTime() {
    //debugLog("Running trackBodyOnLoadEventEsTime() #");
    clearTimeout(trackBodyOnLoadEventTimeOut);
    //debugLog("TIMEOUT REMOVED(!) - loadEventTimeRoundedValue=["+trackBodyOnLoadEventTimeOut+"] #");

    /* check if current page is under Site Catalyst */
    if (typeof s_gi != 'undefined') {
        var loadEventTimeTmp = 0;
        var curLocationHostName = '';
        try {
            loadEventTimeTmp = ((new Date().getTime()) - _preBodyLoadTimestampValue);
            loadEventTimeRoundedValue = loadEventTimeTmp / 1000;
            loadEventTimeRoundedValue = (Math.round(loadEventTimeRoundedValue));
            if ((!isNumberObj(loadEventTimeTmp)) || (!isNumberObj(loadEventTimeRoundedValue))) {
                loadEventTimeTmp = ONLOAD_TRACK_TIMEOUT + 1;
                loadEventTimeRoundedValue = 61;
            }
            curLocationHostName = location.hostname;
            curLocationHostName = curLocationHostName.replace('www.', '');
        } catch (e) {
            loadEventTimeTmp = ONLOAD_TRACK_TIMEOUT + 1;
            loadEventTimeRoundedValue = 61;
        } finally {};

        if (loadEventTimeTmp < 1000) {
            /* MIN value */
            loadEventTimeRoundedValue = "1";
        }
        if (loadEventTimeTmp > ONLOAD_TRACK_TIMEOUT) {
            /* MAX value */
            loadEventTimeRoundedValue = "Onload_TimedOut";
        }
        /* value must be a string object */
        loadEventTimeRoundedValue = "" + loadEventTimeRoundedValue + "";

        var debugStr = "loadEventTimeTmp=[" + loadEventTimeTmp + "] " + "# loadEventTimeRoundedValue=[" +
            loadEventTimeRoundedValue + "] " + "# loadEventTimeTmp/1000=[" + (loadEventTimeTmp / 1000) + "] #";
        //debugLog(debugStr);

        var s = s_gi(s_account);
        if ((s.linkInternalFilters.indexOf(curLocationHostName)) < 0) {
            return;
        }
        /* Send value to Site Catalyst */
        //s.linkTrackVars='eVar35,events';
        //s.linkTrackEvents='event4';
        //s.eVar35=loadEventTimeRoundedValue;
        //s.events='event4';
        //s.tl(this,'o','Tempo di risposta '+loadEventTimeRoundedValue);
        //debugLog(" PageOnloadTimingInfo Sent["+loadEventTimeRoundedValue+"] \n#");
    }
}

function isNumberObj(obj){
    return ((typeof obj == "number") || (typeof obj == "object" && obj.constructor === Number));
}
function parseDateObj(dateStr) {
		try {
			if (dateStr.length == 10) {
				var ggD = parseInt(dateStr.substring(0, 2));
				var mmD = parseInt(dateStr.substring(3, 5)) - 1;
				var aaaaD = parseInt(dateStr.substring(6, 10));
				var d = new Date(aaaaD, mmD, ggD);
				return d;
			}
		} catch (e) {
		}
		return null;
	}
	$('#forminfoutili').on(
			"submit",
			function(event) {
				event.preventDefault();
				if(validateFormInfoutili()){
					$form = $(this); //wrap this in jQuery
					action = $form.attr('action');
					$form.attr('action', action + "?fromDate="
							+ $("#dataInizio").val() + "&toDate="
							+ $("#dataFine").val())

					window.location.href = $form.attr('action');
				}
			});
	function validateFormInfoutili() {
		try {
			tcom18.parseDate();
				var encodedMissingDate = "Il formato corretto della data &egrave; gg-mm-aaaa";
				var encodedWrongDate = "Attenzione! L'intervallo di date inserito non &egrave; valido!";
				var decodedMissingDate = $("<div/>").html(encodedMissingDate).text();
				var decodedWrongDate = $("<div/>").html(encodedWrongDate).text();
			 	var diuInizio = parseDateObj($("#dataInizio").val()), diuFine = parseDateObj($("#dataFine").val());
				if ((diuInizio == null) || (diuFine == null)) {
					alert(decodedMissingDate);
					return false;
				}
				if (diuInizio > diuFine) {
					alert(decodedWrongDate);
					return false;
				}


			return true;
		} catch (e) {
			alert(e);
		}
	}
/*
 * lastTrainSearchList.js
 *
 * last mod: 21-12-2017#13:35
 *
 */


/*JS CODE FOR OLD CRUSCOTTO*/
var $isOldCruscotto = $('form.cruscotto-old');

function generateNoScriptGtag(origin,destinaton,startData,startOur,ar_switch,quantity){
	let noscript = document.createElement('noscript');
	let image = new Image();
	image.src = "https://ad.doubleclick.net/ddm/activity/src=14243071;type=pageview;cat=treni003;u1="+origin+";u2="+destinaton+";u3="+startData+";u4="+startOur+";u5="+ar_switch+";u6="+quantity+";dc_lat=;dc_rdid=;tag_for_child_directed_treatment=;tfua=;npa=;gdpr=${GDPR};gdpr_consent=${GDPR_CONSENT_755};ord=1?";
	image.setAttribute("width", "1");
	image.setAttribute("height", "1");
	image.setAttribute("alt", " ");
	noscript.appendChild(image);
	document.body.appendChild(noscript);
}

function generateScriptGlobalFloodlight(){
    let script = document.createElement('script');
    script.setAttribute('async','');
    script.setAttribute('src', 'https://www.googletagmanager.com/gtag/js?id=DC-14243071');
    document.head.appendChild(script);
}

function checkValueCookie(cname) {
  let name = cname + "=";
  let decodedCookie = decodeURIComponent(document.cookie);
  let ca = decodedCookie.split(';');
  for(let i = 0; i <ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }
    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
}

function checkGroupConsents(cookieValue){
	let cookieObj = cookieValue.split("&").reduce(function(obj, str, index) {	
  		let strParts = str.split("=");
	  	if (strParts[0] && strParts[1]) { 
	    	obj[strParts[0]] = strParts[1];
	  	}
	  return obj;
	}, {});
	
	//ritorna true se è presente il campo groups nel cookie e il codice C0004 è 1;
	return !!cookieObj.groups && !!cookieObj.groups.split(',').filter((cods) => cods.toUpperCase() === 'C0004:1').length;
}

function getGroupConsents(cookieValue){
	let cookieObj = cookieValue.split("&").reduce(function(obj, str, index) {	
  		let strParts = str.split("=");
	  	if (strParts[0] && strParts[1]) { 
	    	obj[strParts[0]] = strParts[1];
	  	}
	  return obj;
	}, {});
	
	if(cookieObj.groups){
		let replaceConsent = cookieObj.groups.replaceAll(',','&');
		let cookieParams = replaceConsent.replaceAll(':','=');
		return cookieParams.toLowerCase();
	}else{
		return '';
	}
}
	
if ($isOldCruscotto.length) {

    var MLSIZE = 5,
        MAXCOOKIELEN = 200;
    var trainSearchListCookie = "trainSearchList",
        splt = "||";
    var _whrToAdd = '#ultime-ricerche-placeholder';

    /* gets, sets, removes the value of a cookie */
    function getCookie(sName) {
        sName = sName.toLowerCase();
        var oCrumbles = document.cookie.split(';');
        for (var i = 0; i < oCrumbles.length; i++) {
            var oPair = oCrumbles[i].split('=');
            var sKey = decodeURIComponent(oPair[0].trim().toLowerCase());
            var sValue = oPair.length > 1 ? oPair[1] : '';
            if (sKey == sName) { return decodeURIComponent(sValue); }
        }
        return '';
    }

    function setCookie(sName, sValue, eDate) {
        var cookieNewVers= getCookie('cookieNewVers');
        var oDate = new Date();
        if (eDate && cookieNewVers != '') {
            oDate = eDate;
        }
        else {
            oDate.setYear(oDate.getFullYear() + 1);
            document.cookie = encodeURIComponent('cookieNewVers') + '=' + encodeURIComponent('1');
        }
        var sCookie = encodeURIComponent(sName) + '=' + encodeURIComponent(sValue) + ';expires=' + oDate.toGMTString() + ';path=/';
        document.cookie = sCookie;
    }

    function clearCookie(sName) {
        setCookie(sName, '');
    }

    function removeOldSearch() {


        var tsllen = trainSearchList.length;


        if (tsllen > MLSIZE) {
            var itemsToRemove = tsllen - MLSIZE;
            for (var i = tsllen - 1; i >= (tsllen - itemsToRemove); i--) {
                removeTrainSearchItem(i);
            }
        }
    }

    function getCheckSearchCookieStr() {
        var tmpStr = getCookie(trainSearchListCookie);

        if (tmpStr.length > MAXCOOKIELEN) {
            var idx = tmpStr.lastIndexOf(splt);
            tmpStr = tmpStr.substring(0, idx);
        }
        setCookie(trainSearchListCookie, tmpStr, null);
        return tmpStr;
    }

    function addToLastTrainSearchList() {

        trainSearchListStr = getCookie(trainSearchListCookie);
        var curSearch = $('#biglietti_fromNew').val() + "$" + $('#biglietti_toNew').val();


        if (trainSearchListStr.indexOf(curSearch) < 0) {

            if (trainSearchListStr.length > 0) {
                trainSearchListStr = splt + trainSearchListStr;
            }
            trainSearchListStr = curSearch + trainSearchListStr;
            setCookie(trainSearchListCookie, trainSearchListStr, null);
            trainSearchList.push(curSearch);
        }
    }

    function chooseTrainSearchItem() {
        var itemIndex = $(this).parent().index();

        var stationsSel = (trainSearchList[itemIndex]).split('$');
        if (stationsSel.length == 2) {
            $('#biglietti_fromNew').val(stationsSel[0]);
            $('#biglietti_toNew').val(stationsSel[1]);
        }
        $("#trainSearchListSelBox").toggle();
        openCruscottoMob();
        return false;
    }

    function openCruscottoMob(){
        $(".DateOreMOB").css('display', "block");
        $("#numero-passeggeriNEW").css('display', "block");
        $("#ar-miglior-prezzo-mobile").css('display', "flex");

        $('#ultime-ricerche').removeClass('mobileClosed');
    }

    function removeTrainSearchListItem() {
        var itemIndex = $(this).parent().index();

        $(this).parent().remove();
        if ($("#trainSearchListSel li").length == 0) {
            $("#trainSearchListSelBox").hide();
            //rimuovo anche il link "Ultime ricerche" dal cruscotto.
            $("#overlay-bg").hide();
            $(".ultime-ricerche-reg").addClass('hidden-search');
        }
        removeTrainSearchItem(itemIndex);
        return false;
    }

    function removeTrainSearchItem(index) {
        if ((index == 0) && (trainSearchList.length == 1)) {
            trainSearchListStr = trainSearchListStr.replace(trainSearchList[index], '');
        } else {
            trainSearchListStr = trainSearchListStr.replace(splt + trainSearchList[index], '');
        }
        trainSearchList.splice(index, 1);
        if (trainSearchList.length == 0) { trainSearchListStr = ''; }
        setCookie(trainSearchListCookie, trainSearchListStr, null);
    }

    function toggleLastTrainSearchList() {
        if (($("#trainSearchListSelBox").css('display') == 'none')) {
            if (trainSearchList.length > 0) {
                $("#trainSearchListSel").empty();
                var myTabIndexA = 731;
                var myTabIndexB = 0;
                for (var j = 0; j < trainSearchList.length; j++) {
                    myTabIndexB = myTabIndexA + 1;
                    $("#trainSearchListSel").append("<li><a tabindex='" + myTabIndexA + "' href='#' class='chooseTrainSearchItem' role='text'>" + trainSearchList[j].replace('$', ' <label id="deskS">-</label><label id="mobS"> - </label> ') + "</a><a tabindex='" + myTabIndexB + "' href='#' class='removeTrainSearchListItem' role='text' aria-label='elimina ricerca effettuata'><img src='/etc.clientlibs/tcom/clientlibs/common/resources/restylingDam/close-icon-black.png'></a><div class='cl'></div></li>");
                    myTabIndexA = myTabIndexA + 2;
                }
                $(".removeTrainSearchListItem").on("click", removeTrainSearchListItem);
                $(".chooseTrainSearchItem").on("click", chooseTrainSearchItem);

                calcolaTopUltimeRicerche();

                $("#trainSearchListSelBox").show();
                $("#trainSearchTitle a").focus();
            }
        } else {
            $("#trainSearchListSelBox").hide();
            $("#overlay-bg").hide();
            //alert("eccolo 3");
            //$("#others-options").focus();
            $("#trainSearchListSel").empty();
        }
        return false;
    }

    function clearFromTo() {
        $('#biglietti_fromNew').val('');
        $('#biglietti_toNew').val('');
        return false;
    }

    function checkIsIE9orLess() {
        try {
            if (/MSIE\s([\d.]+)/.test(navigator.userAgent)) {
                var bVersion = new Number(RegExp.$1); // Get the IE version.
                if (bVersion <= 9) { return true; }
            }
        } catch (e) {}
        return false;
    }

    function calcolaTopUltimeRicerche() {

        var screen_width = window.screen.width;

        //alert("eccolo qui");

        if ((screen_width < 1024)) {

            //var appo = $(".DateOreMOB").css('display');
            //alert("appo: "+appo);

            if ($('.DateOreMOB').is(":visible")) {
                $('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{top:-118px!important;}}</style>');
            } else {
                $('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{top:0px!important;}}</style>');
            }
        }
    }


    window.addEventListener("orientationchange", function() {
        var orientationLandscape = false;
        orientationLandscape = detectOrientation();
        calcolaTopUltimeRicerche(orientationLandscape);
    });

    function detectOrientation() {
        // Calcola l'orientamento del dispositivo mobile
        var flag = false;
        switch (window.orientation) {
            case 0:
            case 180:
                // Portrait
                orientationLandscape = false;

                //alert("Sono Portrait");
                flag = false;
                break;
            case 90:
            case -90:
                // Landscape
                orientationLandscape = true;
                //alert("Sono Landscape");

                flag = true;
                break;
            default:
                return flag;
        }
        return flag;
    }

    /**
     *
     * Cookie-String: "Stazione01a$Stazione01A||Stazione02Da$Stazione02A||..." <===> JS-Array: ["Stazione01a$Stazione01A", "Stazione02Da$Stazione02A", ... ]
     *
     * STRINGHE STAZIONI + LUNGHE: "San Martino V.C.-M.Sarchio-Pannarano" , "Sluderno-Glorenza Schluderns-Glurns"
     */
    trainSearchListStr = getCheckSearchCookieStr();
    if (trainSearchListStr.length > 2) {
        if (trainSearchListStr.substring(0, 2) == splt) { trainSearchListStr = trainSearchListStr.substring(2); }
        if (trainSearchListStr.substring((trainSearchListStr.length - 2)) == splt) { trainSearchListStr = trainSearchListStr.substring(0, trainSearchListStr.length - 2); }
        trainSearchList = getCookie(trainSearchListCookie).split(splt);
    } else {
        trainSearchList = [];
    }
    removeOldSearch();

    //Adattare la finestra alla stringa di ricerca più lunga
    mustLongString = function() {
        var strLong = '';
        for (var i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] === 'string' && arguments[i].length > strLong.length) {
                strLong = arguments[i];
            };
        };
        return strLong;
    };
    var stringLong = mustLongString.apply(null, trainSearchList).length;
    var widthPopUp = 0;
    //var mytop = 10;


    if (stringLong < 40) {
        widthPopUp = (40 * 100) / 12;
    } else {
        widthPopUp = (stringLong * 100) / 12;
    }

    var enableLastSearch = $('#enable-last-search');
    enableLastSearch = enableLastSearch && enableLastSearch.length ? (enableLastSearch.val() === 'true') : false;

    var closeValue = $('#close-i18n');
    closeValue = closeValue && closeValue.length ? closeValue.val() : '';

    var isIE9orLess = checkIsIE9orLess();
    /*Se il browser è IE9 e minore, non vengono vsualizzate le ultime ricerche*/
    if (isIE9orLess) {
        $(".buttonsLastTrainSearchList").hide();
    } else {
        if (trainSearchList.length > 0 && enableLastSearch) {

            $('.ultime-ricerche-reg').removeClass('hidden-search');

            $('head').append('<style>#mieiviaggi{padding-left:48px;}</style>');
            /* style per gestione lista ultimi-treni per gli ID "trainSearchListSelBox" e "trainSearchListSel" */
            $('head').append('<style>#trainSearchListSelBox{ display: none;max-width:600px; width:' + widthPopUp + 'px !important; background: #fff; z-index: 9999;}</style>');
            $('head').append('<style>#trainSearchListSelBox{ position:absolute; margin-left:0px;  top:-135px; z-index: 9999;}</style>');
            $('head').append('<style>#trainSearchListSelBox{ border-radius: 5px !important; background-color: #ffffff 0% 0% no-repeat padding-box;opacity: 1 !important; border: 1px solid #bababa; }</style>');

            $('head').append('<style>#trainSearchListSel li{display:flex;color: #000; /*float: left;*/ font-weight:bold; width: 97% !important;border-bottom:1px solid #bababa !important; margin-left:7px; line-height:25px !important;height:30px !important; min-height: 25px !important; text-align: left; }</style>');
            $('head').append('<style>#trainSearchListSel li a{ padding-top:2px !important;margin-right:12px}</style>');
            $('head').append('<style>#trainSearchListSel{ width: 100%; min-height: 150px; }</style>');
            $('head').append('<style> #trainSearchListSel  { list-style-type: none; padding-left: 0px; } </style>'); /* fix restyling tcom2018 */
            $('head').append('<style>.removeTrainSearchListItem, .chooseTrainSearchItem{font-family: MontserratMedium;padding-top: 0px !important;font-weight:normal !important;font-size:13px !important; color:#000!important; text-decoration: none !important;}</style>');
            $('head').append('<style>.chooseTrainSearchItem{width:92%!important; float:left; margin-left: 5px;}</style>');
            $('head').append('<style>.removeTrainSearchListItem{display:flex;justify-content:center;align-items:center;width:5%!important;height:100%;float:right; margin-left: 5px;}</style>');
            $('head').append('@media screen and (min-width:702px){<style>.buttonsLastTrainSearchList{ width: 450px; font-size: 12px; color: #4c4c4c; font-weight: normal; text-decoration: none; line-height: 1.8em; position: relative; left: 0px; top: 10px; }} </style>');
            $('head').append('@media screen and (max-width:701px){<style>.buttonsLastTrainSearchList{ width: 450px; font-size: 12px; color: #4c4c4c; font-weight: normal; text-decoration: none; line-height: 1.8em; position: relative; left: 0px; top: 0px; }} </style>');

            //$('head').append('<style>@media screen and (min-device-width: 320px) and (max-device-width:568px) {.buttonsLastTrainSearchList{top: -2px !important; }} </style>');
            //$('head').append('<style>.buttonsLastTrainSearchList{ margin-bottom: 10px; } </style>'); /* SU ATTUALE FORM! */
            $('head').append('<style>.buttonsLastTrainSearchList{ margin-bottom: 35px; } </style>'); /* SU NUOVO FORM CERT SOLO! */
            $('head').append('<!--[if lte IE 9]><style type="text/css">.buttonsLastTrainSearchList{ margin-bottom: 25px; }</style><![endif]-->');
            $('head').append('<style>@media screen and (min-width:702px){.linkCRUSLast{border:1px solid #dcdcdc;border-radius: 6px;padding: 0 4px 0 5px;position:relative;top:-10px;left:7px}}</style>'); /* SU NUOVO FORM CERT SOLO! */
            $('head').append('<style>@media screen and (max-width:701px){.linkCRUSLast{border:1px solid #dcdcdc;border-radius: 6px;padding: 0 4px 0 5px;position:relative;top:0px;left:7px}}</style>'); /* SU NUOVO FORM CERT SOLO! */
            $('head').append('<style> .linkCRUSLast img{position:relative;top:1px;left:7px}</style>'); /* SU NUOVO FORM CERT SOLO! */
            $('head').append('<style> .linkCRUSLast a{font-size:10px;color: #4c4c4c;font-weight: bold;text-decoration: none;}</style>'); /* SU NUOVO FORM CERT SOLO! */


            /*Titolo popup*/
            $('head').append('<style>#trainSearchTitle{display:flex;justify-content:center; background-color: #c41329;line-height:33px;color:#fff;font-size:15px;font-family:MontserratBold;border-radius:5px 5px 0 0}</style>');
            /*
            $('head').append('<style>#trainSearchTitle a{display:block;color:#fff;font-size:0.75em;float:right;margin-right:4px;text-decoration: none !important;}</style>');
            */
            $('head').append('<style>#trainSearchTitle a{display:flex;justify-content:center;align-items:center;width:22px;height:100%;color:#fff;font-size:0.75em;float:right;text-decoration: none !important;margin-right:15px}</style>');

            $('head').append('<style>@media screen and (max-width:1023px){#trainSearchTitle{box-shadow:0px -3px 5px rgba(0,0,0,0.5)}}</style>');

            /*$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{width:100%!important;position:absolute;left:0;margin-left:0;border-top:0;border-right:0;border-left:0;border-bottom:0px solid #bababa;z-index: 9999;}}</style>');*/
            $('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{width:100%!important;position:relative;top:0px;left:0;margin-left:0;margin-top:-198px;border-top:0;border-right:0;border-left:0;border-bottom:0px solid #bababa;z-index: 9999;}}</style>');

            $('head').append('<style>@media screen and (max-width:701px){#trainSearchListSel li{display:flex;align-items:center;color: #000; /*float: left;*/ font-weight:bold;width:96%!important;border-bottom:1px solid #bababa !important; margin-left:7px; line-height:20px !important;height:45px !important; min-height: 25px !important; text-align: left; }}</style>');
            $('head').append('<style>@media screen and (max-width:1023px){ul#trainSearchListSel li:first-child{border-top:1px solid #bababa!important;margin-top:5px}}</style>');
            $('head').append('<style>@media screen and (max-width:701px){#mobS{display:inline;}#deskS{display:none;}}</style>');
            $('head').append('<style>@media screen and (min-width:702px){#mobS{display:none;}#deskS{display:inline;}}</style>');
            $('head').append('<style>.chiudi p{width:164px;height:30px;display:flex;justify-content:center;align-items:center;background-color:#C41228;color:#ffffff;border-radius:6px;margin:18px 0 0 0;font-size:14px;letter-spacing:1px;cursor:pointer}</style>');
            $('head').append('<style>.removeTrainSearchListItem img{width:12px;opacity:1}</style>');
            $('head').append('<style>.chiudi{display:flex;justify-content:center;}</style>');
            $('head').append('<style>@media screen and (max-width:1023px){.removeTrainSearchListItem{margin:0px;}}</style>');
            $('head').append('<style>@media screen and (min-width:702px){.imgUltimeRIC{position:relative;top:-3px;margin-left:7px}}</style>');
            $('head').append('<style>@media screen and (max-width:701px){.imgUltimeRIC{position:relative;top:-3px;margin-left:1px}}</style>');
            $('head').append('<!--[if lte IE 9]><style type="text/css">.imgUltimeRIC{position:relative;top:-3px;margin-left:15px}</style><![endif]-->');
            $('head').append('<!--[if lte IE 9]><style type="text/css">.buttonsLastTrainSearchList{ margin-bottom: 25px; }</style><![endif]-->');
            $('head').append('<!--[if lte IE 9]><style type="text/css">#trainSearchListSelBox{width:' + widthPopUp + 'px !important;  position:absolute; left: 120px;  top: 120px; z-index: 9999;}</style><![endif]-->');
            $('head').append('<!--[if lte IE 9]><style type="text/css">#trainSearchListSel li{ color: #000; /*float: left;*/ font-weight:bold; width: 97% !important;border-bottom:1px solid #bababa !important; margin-left:7px; line-height:25px !important;height:30px !important; min-height: 25px !important; text-align: left; }</style><![endif]-->');
            $('head').append('<!--[if lte IE 9]><style type="text/css">#mobS{display:none;}#deskS{display:inline;}</style><![endif]-->');
            $('head').append('<!--[if lte IE 9]><style type="text/css">.removeTrainSearchListItem{margin-top:0px;}</style><![endif]-->');



            /* ### Rendering Box e Bottoni x per lista ultimi treni ###  */
            $(_whrToAdd).after("<div id='trainSearchListSelBox'><div id='trainSearchTitle'><div style='flex: 2;text-align: center;'>" + $('input#latestSearchText').val().toUpperCase() + "</div><div id='closeTrainSearchListBox'><a tabindex='730' href='#' aria-label='" + closeValue + "'><img src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/hp/chiudi_ultime ricerche.svg' width='12'></a></div></div><ul id='trainSearchListSel'></ul></div>");

            $('#closeTrainSearchListBox a').on('click', function() {
                toggleLastTrainSearchList();
                return false;
            });

            var appo = $(window).width();

            if (/iPhone/i.test(navigator.userAgent)) {
                $(".buttonsLastTrainSearchList").css("top", "-5px");
                $(".buttonsLastTrainSearchList").css("margin-bottom", "0px");
            }

            $('.buttonsLastTrainSearchList').fadeIn('fast');
            //$('.buttonsLastTrainSearchList').fadeOut('fast').fadeIn('slow');
            //$('.buttonsLastTrainSearchList').fadeOut('slow').fadeIn('fast');
            /* css fix spaziatura form su smartphone Android */
            if ($(window).width() <= tcom18.mSize) {
                $(".linkFineCrus").css("top", "25px");
                $("fieldset.biglietti_buttons").css("margin-top", "0px");
                $(".cruscottoBiglietti").css("height", "445px");
                $(_whrToAdd).css("height", "1px"); // fix blackberry
                //$(".buttonsLastTrainSearchList").css("margin-top", "-15px"); // fix 08-06-2017
            }

            $(document).mouseup(function(e) {
                var test1 = $(e.target).is('#trainSearchListSelBox *');
                var test2 = $(e.target).is('#trainSearchListSelButton');
                if (test1 || test2) {
                    return;
                } else {
                    $('#trainSearchListSelBox').hide();
                }
            });

            //var wBox = $('#trainSearchListSelBox').css("width");

        }
    }

    /* ############### postpone alla fine del metodo tcom18.checkForm POICHE' ABBIAMO LA VALIDAZIONE DELLE STAZIONI!!! */
    tcom18.checkFormOLD = tcom18.checkForm;
    tcom18.checkForm = function(e) {
        var resCheck = tcom18.checkFormOLD(e);

        if (resCheck != false) {
            addToLastTrainSearchList();
        }
        return resCheck;
    };

    //SCRIPT SIZMEK
    function sizmekFunc(form) {
	
        var checkTcom=tcom18.checkForm(form);
        
        let cookieConsent = checkValueCookie("OptanonConsent");
    	let consentFlag = !!cookieConsent ? checkGroupConsents(cookieConsent) : false;
    	let groupCookieConsent = getGroupConsents(cookieConsent);
    	
        if(checkTcom){
	
			if(!!groupCookieConsent){
				let newUrl = $("#formcruscotto").attr("action")+"&"+groupCookieConsent;
    			$("#formcruscotto").attr("action",newUrl);
			}

            let siteParam = "site=tcom";
            let siteParamUrl = $("#formcruscotto").attr("action")+"&"+siteParam;
            $("#formcruscotto").attr("action",siteParamUrl);

            /*versaTagObj.generateRequest("https://www.trenitalia.com/Click/Search.html");
            var szkorigineTratta = document.getElementById("biglietti_fromNew").value;
            var szkdestinazioneTratta = document.getElementById("biglietti_toNew").value;
            var Quantity = Number(document.getElementById("biglietti_adulti").value) + Number(document.getElementById("biglietti_ragazzi").value);
            versaTagObj.setActivityParam("szkorigineTratta", szkorigineTratta);
            versaTagObj.setActivityParam("szkdestinazioneTratta", szkdestinazioneTratta);
            versaTagObj.setActivityParam("Quantity", Quantity);
            versaTagObj.generateRequest();*/
            //Richiesta cambio script TT_0015124349
            var OrderID = "";
            var szkorigineTratta = document.getElementById("biglietti_fromNew").value;
            var szkdestinazioneTratta = document.getElementById("biglietti_toNew").value;
            var Quantity = Number(document.getElementById("biglietti_adulti").value) + Number(document.getElementById("biglietti_ragazzi").value);
            var Revenue = "";
            var startData = document.getElementById('biglietti_data_pVISIBLE').value;
    		var startOur = document.getElementById('biglietti_ora_p').value; 
    		var ar_switch = document.getElementById("biglietti_ar").checked ? "A/R" : "A";

            if (consentFlag) {
                <!-- Start of global snippet: Google tag (gtag.js) -->
                generateScriptGlobalFloodlight();
                window.dataLayer = window.dataLayer || [];
                function gtag() {
                    dataLayer.push(arguments);
                }
                gtag('js', new Date());
                gtag('config', 'DC-14243071');
                <!-- End of global snippet: Please do not remove -->

                <!-- Event snippet for Trenitalia Bottone Cerca -->
                gtag('event', 'conversion', {
                    'allow_custom_scripts': true,
                    'u1': szkorigineTratta, //Stazione di Partenza
                    'u2': szkdestinazioneTratta, //Stazione di Arrivo
                    'u3': startData, //Data partenza
                    'u4': startOur, //Ora di partenza
                    'u5': ar_switch, //Il valore che passiamo in caso di A/R o se preferiamo 0/1.
                    'u6': Quantity, //Somma passeggeri tra adulti e ragazzi
                    'send_to': 'DC-14243071/pageview/treni003+standard'
                });

                generateNoScriptGtag(szkorigineTratta, szkdestinazioneTratta, startData, startOur, ar_switch, Quantity);
                <!-- End of event snippet: Please do not remove -->
            }
            versaTagObj.clearActivityParam();
            versaTagObj.setActivityParam("OrderID", OrderID);
            versaTagObj.setActivityParam("ProductID", szkorigineTratta);
            versaTagObj.setActivityParam("ProductInfo", szkdestinazioneTratta);
            versaTagObj.setActivityParam("Quantity", Quantity);
            versaTagObj.setActivityParam("Citta_Partenza", szkorigineTratta);
            versaTagObj.setActivityParam("Citta_Arrivo", szkdestinazioneTratta);
            versaTagObj.setActivityParam("Value", Revenue);
            versaTagObj.generateRequest("https://www.trenitalia.com/Click/Search.html");
        }else{
                return checkTcom;
        }
    };

    function consentFunction(form) {

        let cookieConsent = checkValueCookie("OptanonConsent");
        let consentFlag = !!cookieConsent ? checkGroupConsents(cookieConsent) : false;
        let groupCookieConsent = getGroupConsents(cookieConsent);
        let siteParam = "site=tcom";

        if(!!groupCookieConsent){
            let newUrl = $("#searchForm").attr("action")+"&"+groupCookieConsent;
            $("#searchForm").attr("action",newUrl);
        }

        let siteParamUrl = $("#searchForm").attr("action")+"&"+siteParam;
        $("#searchForm").attr("action",siteParamUrl);

    };

} else {
    var MLSIZE=5, MAXCOOKIELEN=200;
    var trainSearchListCookie="trainSearchList", splt="||";
    var _whrToAdd = '#ultime-ricerche-placeholder';
    var ultimeRicercheLabel = $('#ultime-ricerche-label-hidden').text();
    var chiudiUltimeRicercheLabel = $('#chiudi-ultime-ricerche-label-hidden').text();

    var enableLastSearch = $('#enable-last-search');
        enableLastSearch = enableLastSearch && enableLastSearch.length ? (enableLastSearch.val() === 'true') : false;

    /* gets, sets, removes the value of a cookie */
    function getCookie(sName){
        sName = sName.toLowerCase();
        var oCrumbles = document.cookie.split(';');
        for(var i=0; i<oCrumbles.length;i++){
            var oPair= oCrumbles[i].split('=');
            var sKey = decodeURIComponent(oPair[0].trim().toLowerCase());
            var sValue = oPair.length>1?oPair[1]:'';
            if(sKey == sName){ return decodeURIComponent(sValue); }
        }
        return '';
    }
    function setCookie(sName,sValue,eDate){
        var oDate = new Date();
    	if(eDate){
    		oDate = eDate;
    	}else{
    		oDate.setYear(oDate.getFullYear()+5);
    	}
        var sCookie = encodeURIComponent(sName) + '=' + encodeURIComponent(sValue) + ';expires=' + oDate.toGMTString() + ';path=/';
        document.cookie= sCookie;
    }
    function clearCookie(sName){
        setCookie(sName,'');
    }
    function removeOldSearch(){
    	console.log("Sono nella removeOldSearch");

    	var tsllen=trainSearchList.length;
    	console.log("tsllen: "+tsllen);
    	console.log("MLSIZE: "+MLSIZE);
    	if(tsllen > MLSIZE){
    		var itemsToRemove = tsllen-MLSIZE;
    		for(var i=tsllen-1;i>=(tsllen-itemsToRemove);i--){
    			removeTrainSearchItem(i);
    		}
    	}
    }
    function getCheckSearchCookieStr(){
    	var tmpStr=getCookie(trainSearchListCookie);
    	console.log("tmpStr: "+tmpStr);
    	if(tmpStr.length>MAXCOOKIELEN){
    		var idx=tmpStr.lastIndexOf(splt);
    		tmpStr=tmpStr.substring(0, idx);
    	}
    	setCookie(trainSearchListCookie, tmpStr, null);
    	return tmpStr;
    }
    function addToLastTrainSearchList(){
    	console.log("Sono nella addToLastTrainSearchList");
    	trainSearchListStr=getCookie(trainSearchListCookie);
    	console.log("trainSearchListStr: "+trainSearchListStr);

    	var curSearch = $('#biglietti_fromNew').val()+"$"+$('#biglietti_toNew').val();
    	//console.log("curSearch: "+curSearch);
    	//console.log("trainSearchListStr.indexOf(curSearch): "+trainSearchListStr.indexOf(curSearch));
    	if(trainSearchListStr.indexOf(curSearch)<0){
    		console.log("Sono nella if");
    		if(trainSearchListStr.length>0){
    			trainSearchListStr = splt+trainSearchListStr;
    		}
    		trainSearchListStr = curSearch+trainSearchListStr;
    		setCookie(trainSearchListCookie, trainSearchListStr, null);
    		trainSearchList.push(curSearch);
    	}
    }
    function chooseTrainSearchItem(){
    	var itemIndex = $(this).parent().index();
    	console.log("click on: "+ itemIndex + " - " + $(this).text() + " CHOOSE, arrList: ["+trainSearchList[itemIndex] + "]");
    	var stationsSel=(trainSearchList[itemIndex]).split('$');
    	if(stationsSel.length==2){
    		$('#biglietti_fromNew').val(stationsSel[0]);
    		$('#biglietti_toNew').val(stationsSel[1]);
    	}
    	$("#trainSearchListSelBox").toggle();
    	$("#overlay-bg").hide();

    	openCruscottoMob();

    	return false;
    }

    function openCruscottoMob(){
    	var screen_pixel = window.screen.width;

    	if(screen_pixel < 1024){
    		$(".DateOreMOB").css('display',"block");
    		$("#numero-passeggeriNEW").css('display',"block");
    		$("#miglior-prezzo-mobile").css('display',"flex");
    		$("#ar-mobile").css('display',"flex");


    		// if (screen_pixel < 321) {
    		// 	$('head').append('<style>@media screen and (max-width:320px){#ultime-ricerche{margin-top:-254px;}}</style>');
    		// }else if(screen_pixel < 366) {
    		// 	$('head').append('<style>@media screen and (max-width:365px){#ultime-ricerche{margin-top:-258px;}}</style>');
    		// }else if(screen_pixel < 376) {
    		// 	$('head').append('<style>@media screen and (max-width:375px){#ultime-ricerche{margin-top:-251px;}}</style>');
    		// }else if(screen_pixel < 385) {
    		// 	$('head').append('<style>@media screen and (max-width:384px){#ultime-ricerche{margin-top:-259px;}}</style>');
    		// }else if(screen_pixel < 412) {
    		// 	$('head').append('<style>@media screen and (max-width:411px){#ultime-ricerche{margin-top:-255px;}}</style>');
    		// }else if(screen_pixel < 415) {
    		// 	$('head').append('<style>@media screen and (max-width:414px){#ultime-ricerche{margin-top:-252px;}}</style>');
    		// }else if(screen_pixel < 569) {
    		// 	$('head').append('<style>@media screen and (max-width:568px){#ultime-ricerche{margin-top:-254px;}}</style>');
    		// }else if(screen_pixel < 601) {
    		// 	$('head').append('<style>@media screen and (max-width:600px){#ultime-ricerche{margin-top:-254px;}}</style>');
    		// }else if(screen_pixel < 641) {
    		// 	$('head').append('<style>@media screen and (max-width:640px){#ultime-ricerche{margin-top:-259px;}}</style>');
    		// }else if(screen_pixel < 668) {
    		// 	$('head').append('<style>@media screen and (max-width:667px){#ultime-ricerche{margin-top:-254px;}}</style>');
    		// }else if(screen_pixel < 737) {
    		// 	$('head').append('<style>@media screen and (max-width:736px){#ultime-ricerche{margin-top:-257px;}}</style>');
    		// }else if(screen_pixel < 769) {
    		// 	$('head').append('<style>@media screen and (max-width:768px){#ultime-ricerche{margin-top:-260px;}}</style>');
    		// }else if(screen_pixel < 801) {
    		// 	$('head').append('<style>@media screen and (max-width:800px){#ultime-ricerche{margin-top:-265px;}}</style>');
    		// }else if(screen_pixel < 813) {
    		// 	$('head').append('<style>@media screen and (max-width:812px){#ultime-ricerche{margin-top:-261px;}}</style>');
    		// }else{
    		// 	$('head').append('<style>@media screen and (max-width:1023px){#ultime-ricerche{margin-top:-265px;}}</style>');
    		// }
    	}
    }

    function removeTrainSearchListItem(){
    	var itemIndex = $(this).parent().index();
    	console.log("click on: "+ itemIndex + " - " + $(this).text() + " REMOVE, arrList: ["+trainSearchList[itemIndex] + "]");
    	$(this).parent().remove();
    	if($("#trainSearchListSel li").length==0){
    		$("#trainSearchListSelBox").hide();
    		$("#overlay-bg").hide();
    		//rimuovo anche il link "Ultime ricerche" dal cruscotto.
    		$(".buttonsLastTrainSearchList").hide();
    		$(_whrToAdd).after("<div class='boxUltimeRicerche' style='height:35px'></div>")
    		// $('head').append('<style>#mieiviaggi{padding-left:48px;}</style>');
    		$('head').append('<style>.boxUltimeRicerche{width: 150px}</style>');
    	}
    	removeTrainSearchItem(itemIndex);
    	return false;
    }
    function removeTrainSearchItem(index){
    	if((index==0) &&(trainSearchList.length==1)){
    		trainSearchListStr = trainSearchListStr.replace(trainSearchList[index], '');
    	}else{
    		trainSearchListStr = trainSearchListStr.replace(splt+trainSearchList[index], '');
    	}
    	trainSearchList.splice(index, 1);
    	if(trainSearchList.length==0){ trainSearchListStr=''; }
    	setCookie(trainSearchListCookie, trainSearchListStr, null);
    }
    function toggleLastTrainSearchList(){
    	if( ($("#trainSearchListSelBox").css('display')=='none') ){
    		if(trainSearchList.length>0){
    			$("#trainSearchListSel").empty();
    			// fabio start
    			//var myTabIndexA = 731;
    			var myTabIndexA = 642;
    			// fabio end
    			var myTabIndexB = 0;
    			for (var j = 0; j < trainSearchList.length; j++){
    				//$("#trainSearchListSel").append("<li><a href='#' class='chooseTrainSearchItem'>"+ trainSearchList[j].replace('$',' <label id="deskS">-</label><label id="mobS"> - </label> ') +"</a><a href='#' class='removeTrainSearchListItem'><img src='content/dam/tcom/sites/themes/trenitalia2018/001/img/common/close-icon-white.png'></a><div class='cl'></div></li>");

    				myTabIndexB = myTabIndexA + 1;
    				$("#trainSearchListSel").append("<li><a tabindex='"+myTabIndexA+"' href='#' class='chooseTrainSearchItem' role='text'>"+ trainSearchList[j].replace('$',' <label id="deskS">-</label><label id="mobS"> - </label> ') +"</a><a tabindex='"+myTabIndexB+"' href='#' class='removeTrainSearchListItem' role='text' aria-label='elimina ricerca effettuata'><img src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/delete-icon.svg'></a><div class='cl'></div></li>");
    				myTabIndexA = myTabIndexA + 2;
    			}
    			$(".removeTrainSearchListItem" ).on("click", removeTrainSearchListItem);
    			$(".chooseTrainSearchItem" ).on("click", chooseTrainSearchItem);
    			calcolaTopUltimeRicerche();
    			$("#overlay-bg").show();
    			$("#trainSearchListSelBox").show();
    			$("#trainSearchTitle a").focus();
    		}
    	} else {
    		$("#trainSearchListSelBox").hide();
    		//alert("eccolo 3");
    		//$("#others-options").focus();
    		$("#overlay-bg").hide();

    		$("#trainSearchListSel").empty();
    	}
    	return false;
    }
    function clearFromTo(){
    	$('#biglietti_fromNew').val('');
    	$('#biglietti_toNew').val('');
    	return false;
    }
    function checkIsIE9orLess(){
    	try{
    		if(/MSIE\s([\d.]+)/.test(navigator.userAgent)){
    			var bVersion = new Number(RegExp.$1); // Get the IE version.
    			if(bVersion <= 9){ return true; }
    		}
    	}catch(e){}
    	return false;
    }

    function calcolaTopUltimeRicerche(){

    	var screen_width = window.screen.width;
    	//console.log("screen_width: "+screen_width+"\n");
    	//alert("eccolo qui");

    	if ((screen_width<1024)){

    		//var appo = $(".DateOreMOB").css('display');
    		//alert("appo: "+appo);

    		if ($('.DateOreMOB').is(":visible")){
    			$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{bottom:0!important;}}</style>');
    		}else{
    			$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{bottom:0!important;}}</style>');
    		}

    		/*
    		if($(".DateOreMOB").css('display')=="block"){
    			console.log("sono block"):
    			$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{top:-118px!important;}}</style>');
    		}else{
    			$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{top:0px!important;}}</style>');
    			console.log("NON sono block"):
    		}
    		*/

    		/*
    		var boxSceltaTreni = $("#boxScegliTreni").css('height');

    		console.log("boxSceltaTreni: "+boxSceltaTreni);

    		if (boxSceltaTreni != undefined){
    			var logoInfo = 36;
    			boxSceltaTreni = $("#boxScegliTreni").css('height').split("px");
    			var menuMobile = $("#menu-mobile").css('height').split("px");
    			//var boxSceltaTreni = $("#boxScegliTreni").css('height').split("px");
    			var	carosello_h;
    			var myTopLastRicerche = 0;
    			var boxCruscotto = parseInt($("#boxCruscotto").css('padding-left').split("px"));
    			//console.log("boxCruscotto: "+boxCruscotto);

    			if (screen_width>767){
    				// Sono Tablet
    				carosello_h = 440;
    			}else{
    				// Sono Smartphone
    				carosello_h = parseInt(screen_width) * 0.888888;
    			}

    			if (screen_width<=610){
    				boxCruscotto = 0;
    			}

    			myTopLastRicerche = parseInt(menuMobile) + parseInt(logoInfo) + parseInt(carosello_h) + parseInt(boxSceltaTreni);
    			//console.log("menuMobile: "+menuMobile+"\nlogoInfo: "+logoInfo+"\ncarosello_h: "+carosello_h+"\nboxSceltaTreni: "+boxSceltaTreni+"\nboxCruscotto: "+boxCruscotto);
    			$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{top:'+myTopLastRicerche+'px!important;left:'+boxCruscotto+'px!important}}</style>');
    		}
    		*/
    	}
    }
    /*
    $(window).on('load',function () {
    	var screen_width = window.screen.width;
    	calcolaTopUltimeRicerche();
    });
    $(window).resize(function(){
    	calcolaTopUltimeRicerche();
    });
    $(document).ready(function () {
    	calcolaTopUltimeRicerche();
    });
    */
    window.addEventListener("orientationchange", function() {
    	var orientationLandscape = false;
    	orientationLandscape = detectOrientation();
    	calcolaTopUltimeRicerche(orientationLandscape);
    });
    function detectOrientation(){
    // Calcola l'orientamento del dispositivo mobile
    	var flag = false;
    	switch (window.orientation)
    	{
    		case 0:
    		case 180:
    			// Portrait
    			orientationLandscape = false;
    			//console.log("Sono Portrait");
    			//alert("Sono Portrait");
    			flag = false;
    			break;
    		case 90:
    		case -90:
    			// Landscape
    			orientationLandscape = true;
    			//alert("Sono Landscape");
    			//console.log("Sono Landscape");
    			flag = true;
    			break;
    		default:
    			return flag;
    	}
    	return flag;
    }

    /**
     *
     * Cookie-String: "Stazione01a$Stazione01A||Stazione02Da$Stazione02A||..." <===> JS-Array: ["Stazione01a$Stazione01A", "Stazione02Da$Stazione02A", ... ]
     *
     * STRINGHE STAZIONI + LUNGHE: "San Martino V.C.-M.Sarchio-Pannarano" , "Sluderno-Glorenza Schluderns-Glurns"
     */
    trainSearchListStr=getCheckSearchCookieStr();
    if(trainSearchListStr.length>2){
    	if(trainSearchListStr.substring(0, 2)==splt){ trainSearchListStr=trainSearchListStr.substring(2); }
    	if(trainSearchListStr.substring((trainSearchListStr.length-2))==splt){ trainSearchListStr=trainSearchListStr.substring(0, trainSearchListStr.length-2); }
    	trainSearchList=getCookie(trainSearchListCookie).split(splt);
    }else{
    	trainSearchList = [];
    }
    removeOldSearch();

    //Adattare la finestra alla stringa di ricerca più lunga
    mustLongString=function(){
    	var strLong='';
    	for(var i = 0; i < arguments.length; i++) {
    	   if(typeof arguments[i]==='string'&&arguments[i].length>strLong.length){
    			strLong=arguments[i];
    	   };
    	};
    	return strLong;
    };
    var stringLong = mustLongString.apply(null,trainSearchList).length;
    var widthPopUp = 0;
    //var mytop = 10;
    //console.log("\nmytop: "+mytop);

    if(stringLong<40){
    	widthPopUp = (40*100)/12;
    	console.log("widthPopUp: "+widthPopUp);
    }else{
    	widthPopUp = (stringLong*100)/12;
    	console.log("widthPopUp: "+widthPopUp);
    }



    var isIE9orLess = checkIsIE9orLess();
    /*Se il browser è IE9 e minore, non vengono vsualizzate le ultime ricerche*/
    if (isIE9orLess){
    	$(".buttonsLastTrainSearchList").hide();
    }else{
    	if(trainSearchList.length>0 && enableLastSearch){
            /*leftVal = $('#sel-soluzioni-div').length ? '-285px' : '0';*/

    		$('head').append('<style>#mieiviaggi{padding-left:48px;}</style>');
    		/* style per gestione lista ultimi-treni per gli ID "trainSearchListSelBox" e "trainSearchListSel" */
    		$('head').append('<style>#trainSearchListSelBox{ display: none; width:578px; background:#ffffff; z-index: 9999;}</style>');
    		$('head').append('<style>#trainSearchListSelBox{ position:absolute; bottom:100px; left:0; z-index:9999;}</style>');
    		$('head').append('<style>#trainSearchListSelBox{ border-radius: 5px !important; background-color: #000000 0% 0% no-repeat padding-box;opacity:1!important; border: 1px solid #bababa!important;}</style>');

    		$('head').append('<style>#trainSearchListSel li{display:flex;color: #000; /*float: left;*/ font-weight:bold; width: 96% !important;border-bottom:1px solid #bababa !important; margin-left:2%; line-height:25px !important;height:30px !important; min-height: 25px !important; text-align: left; }</style>');
    		$('head').append('<style>#trainSearchListSel li a{ padding-top:2px !important;margin-right:0;}</style>');
    		$('head').append('<style>#trainSearchListSel{ width: 100%; min-height: 150px; }</style>');
    		$('head').append('<style> #trainSearchListSel  { list-style-type: none; padding-left: 0px; } </style>'); /* fix restyling tcom2018 */
    		$('head').append('<style>.removeTrainSearchListItem, .chooseTrainSearchItem{font-family: MontserratMedium;padding-top: 0px !important;font-weight:normal !important;font-size:13px !important; color:#000000!important; text-decoration: none !important;}</style>');
    		$('head').append('<style>.chooseTrainSearchItem{width:93%!important; float:left; margin-left: 5px;}</style>');
    		$('head').append('<style>.removeTrainSearchListItem{display:flex;justify-content:center;align-items:center;width:5%!important;height:100%;float:right; margin-left: 5px;}</style>');
    		$('head').append('@media screen and (min-width:702px){<style>.buttonsLastTrainSearchList{ width: 450px; font-size: 14px; color: #4c4c4c; font-weight: normal; text-decoration: none; line-height: 1.8em; position: relative; left: 0px; top: 10px; }} </style>');
    		$('head').append('@media screen and (max-width:701px){<style>.buttonsLastTrainSearchList{ width: 450px; font-size: 12px; color: #4c4c4c; font-weight: normal; text-decoration: none; line-height: 1.8em; position: relative; left: 0px; top: 0px; }} </style>');

    		//$('head').append('<style>@media screen and (min-device-width: 320px) and (max-device-width:568px) {.buttonsLastTrainSearchList{top: -2px !important; }} </style>');
    		//$('head').append('<style>.buttonsLastTrainSearchList{ margin-bottom: 10px; } </style>'); /* SU ATTUALE FORM! */
    		$('head').append('<style>.buttonsLastTrainSearchList{ margin-bottom: 35px; } </style>'); /* SU NUOVO FORM CERT SOLO! */
    		$('head').append('<!--[if lte IE 9]><style type="text/css">.buttonsLastTrainSearchList{ margin-bottom: 25px; }</style><![endif]-->');
    		$('head').append('<style>@media screen and (min-width:702px){.linkCRUSLast{border:1px solid #dcdcdc;border-radius: 6px;padding: 0 4px 0 5px;position:relative;top:-10px;left:7px}}</style>'); /* SU NUOVO FORM CERT SOLO! */
    		$('head').append('<style>@media screen and (max-width:701px){.linkCRUSLast{border:1px solid #dcdcdc;border-radius: 6px;padding: 0 4px 0 5px;position:relative;top:0px;left:7px}}</style>'); /* SU NUOVO FORM CERT SOLO! */
    		$('head').append('<style> .linkCRUSLast img{position:relative;top:1px;left:7px}</style>'); /* SU NUOVO FORM CERT SOLO! */
    		$('head').append('<style> .linkCRUSLast a{font-size:10px;color: #4c4c4c;font-weight: bold;text-decoration: none;}</style>'); /* SU NUOVO FORM CERT SOLO! */


    		/*Titolo popup*/
    		$('head').append('<style>#trainSearchTitle{display:flex;justify-content:center; background-color: #c41329;line-height:33px;color:#fff;font-size:15px;font-family:MontserratBold;border-radius:5px 5px 0 0}</style>');
    		/*
    		$('head').append('<style>#trainSearchTitle a{display:block;color:#fff;font-size:0.75em;float:right;margin-right:4px;text-decoration: none !important;}</style>');
    		*/
    		$('head').append('<style>#trainSearchTitle a{display:flex;justify-content:center;align-items:center;width:22px;height:100%;color:#fff;font-size:0.75em;float:right;text-decoration: none !important;margin-right:15px}</style>');

    		$('head').append('<style>@media screen and (max-width:1023px){#trainSearchTitle{box-shadow:0px -3px 5px rgba(0,0,0,0.5)}}</style>');

    		/*$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{width:100%!important;position:absolute;left:0;margin-left:0;border-top:0;border-right:0;border-left:0;border-bottom:0px solid #bababa;z-index: 9999;}}</style>');*/
    		$('head').append('<style>@media screen and (max-width:1023px){#trainSearchListSelBox{width:100%!important;position:fixed;left:0;margin-left:0;border-top:0;border-right:0;border-left:0;border-bottom:0px solid #bababa;z-index: 9999;}}</style>');

    		$('head').append('<style>@media screen and (max-width:701px){#trainSearchListSel li{display:flex;align-items:center;color: #000; /*float: left;*/ font-weight:bold;width:96%!important;border-bottom:1px solid #bababa !important; margin-left:7px; line-height:20px !important;height:45px !important; min-height: 25px !important; text-align: left; }}</style>');
    		// $('head').append('<style>@media screen and (max-width:1023px){ul#trainSearchListSel li:first-child{border-top:1px solid #bababa!important;margin-top:5px}}</style>');
    		$('head').append('<style>@media screen and (max-width:701px){#mobS{display:inline;}#deskS{display:none;}}</style>');
    		$('head').append('<style>@media screen and (min-width:702px){#mobS{display:none;}#deskS{display:inline;}}</style>');
    		$('head').append('<style>.chiudi p{width:164px;height:30px;display:flex;justify-content:center;align-items:center;background-color:#C41228;color:#ffffff;border-radius:6px;margin:18px 0 0 0;font-size:14px;letter-spacing:1px;cursor:pointer}</style>');
    		$('head').append('<style>.removeTrainSearchListItem img{width:12px;opacity:1}</style>');
    		$('head').append('<style>.chiudi{display:flex;justify-content:center;}</style>');
    		$('head').append('<style>@media screen and (max-width:1023px){.removeTrainSearchListItem{margin:0px;}}</style>');
    		$('head').append('<style>@media screen and (min-width:702px){.imgUltimeRIC{position:relative;top:-3px;margin-left:7px}}</style>');
    		$('head').append('<style>@media screen and (max-width:701px){.imgUltimeRIC{position:relative;top:-3px;margin-left:1px}}</style>');
    		$('head').append('<!--[if lte IE 9]><style type="text/css">.imgUltimeRIC{position:relative;top:-3px;margin-left:15px}</style><![endif]-->');
    		$('head').append('<!--[if lte IE 9]><style type="text/css">.buttonsLastTrainSearchList{ margin-bottom: 25px; }</style><![endif]-->');
    		$('head').append('<!--[if lte IE 9]><style type="text/css">#trainSearchListSelBox{width:'+widthPopUp+'px !important;  position:absolute; left: 120px;  top: 120px; z-index: 9999;}</style><![endif]-->');
    		$('head').append('<!--[if lte IE 9]><style type="text/css">#trainSearchListSel li{ color: #000; /*float: left;*/ font-weight:bold; width: 97% !important;border-bottom:1px solid #bababa !important; margin-left:7px; line-height:25px !important;height:30px !important; min-height: 25px !important; text-align: left; }</style><![endif]-->');
    		$('head').append('<!--[if lte IE 9]><style type="text/css">#mobS{display:none;}#deskS{display:inline;}</style><![endif]-->');
    		$('head').append('<!--[if lte IE 9]><style type="text/css">.removeTrainSearchListItem{margin-top:0px;}</style><![endif]-->');


    		/* ### Rendering Box e Bottoni x per lista ultimi treni ###  */
    		$('.boxUltimeRicerche').remove();
    		/* fabio tabindex='730' */

    		$(_whrToAdd).after("<div id='trainSearchListSelBox'><div id='trainSearchTitle'><div style='flex: 2;text-align: center;'>"+ultimeRicercheLabel+"</div><div><a tabindex='641' href='#'  aria-label='"+chiudiUltimeRicercheLabel+"'><img src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/hp/chiudi_ultime ricerche.svg' width='12'></a></div></div><ul id='trainSearchListSel'></ul></div>");
    		var appo = $(window).width();
    		// var strUltimeRicerche;
    		// if($(document).width() < 1024){
    		// 	// mobile
    		// 	strUltimeRicerche = "<img class='arrow-icon' src='etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/ultime_ricerche-mobile.png' alt='' /> Ultime ricerche";
    		// }else{
    		// 	// desktop
    		// 	strUltimeRicerche = "<img class='arrow-icon' src='etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/ultime_ricerche.png' alt='' /> Ultime ricerche";
    		// }

    		let iconaLenteUltimeRicercheMobile = "<img class='lente-icon mobile' id='lente-icon-mobile' src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/ultime_ricerche-mobile.png' alt='' />";
    		let iconaLenteUltimeRicercheDesktop = "<img class='lente-icon desk' id='lente-icon-desk' src='/etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/ultime_ricerche.png' alt='' />";
    		let labelUltimeRicerche = ultimeRicercheLabel

    		$(_whrToAdd).after(
    			"<div class='buttonsLastTrainSearchList' style=''>" +
    			"<div id='ultime-ricerche' class='ultime-ricerche-reg'>" +
    			/* fabio tabindex='725' */
    			"<a href='#' tabindex='640' id='trainSearchListSelButton' title='' aria-label='"+ultimeRicercheLabel+"'>" +
    			/*"Ultime ricerche <img class='arrow-icon' src='etc.clientlibs/tcom/clientlibs/common/resources/sites/img/common/icona-lente-ingranaggio.png' alt='' />" +*/
    			// strUltimeRicerche +
    			iconaLenteUltimeRicercheMobile +
    			iconaLenteUltimeRicercheDesktop +
    			labelUltimeRicerche +
    			"</a>" +
    			"</div>" +
    			"</div>"
    		);

    		$('#trainSearchListSelButton').on('click', function() {
                   toggleLastTrainSearchList();
                   return false;
            });
			$('#trainSearchListSelBox a').on('click', function() {
					toggleLastTrainSearchList();
					return false;
			});

    		if( /iPhone/i.test(navigator.userAgent) ){
    			$(".buttonsLastTrainSearchList").css("top", "0");
    			$(".buttonsLastTrainSearchList").css("margin-bottom", "0px");
    		}

    		$('.buttonsLastTrainSearchList').fadeIn('fast');
    		//$('.buttonsLastTrainSearchList').fadeOut('fast').fadeIn('slow');
    		//$('.buttonsLastTrainSearchList').fadeOut('slow').fadeIn('fast');
    		/* css fix spaziatura form su smartphone Android */
    		if($(window).width() <= tcom18.mSize){
    			$(".linkFineCrus").css("top", "25px");
    			$("fieldset.biglietti_buttons").css("margin-top", "0px");
    			$(".cruscottoBiglietti").css("height","445px");
    			$(_whrToAdd).css("height", "1px"); // fix blackberry
    			//$(".buttonsLastTrainSearchList").css("margin-top", "-15px"); // fix 08-06-2017
    		}

    		$(document).mouseup(function(e){
    			var test1= $(e.target).is('#trainSearchListSelBox *');
    			var test2= $(e.target).is('#trainSearchListSelButton');
    			if(test1 || test2){
    				return;
    			}else{
    				$('#trainSearchListSelBox').hide();
    			}
    		});

    		//var wBox = $('#trainSearchListSelBox').css("width");
    		//console.log("wBox: "+wBox);
    	}
    }

    /* ############### postpone alla fine del metodo tcom18.checkForm POICHE' ABBIAMO LA VALIDAZIONE DELLE STAZIONI!!! */
    tcom18.checkFormOLD = tcom18.checkForm;
    tcom18.checkForm = function(e){
    	var resCheck=tcom18.checkFormOLD(e);
    	console.log("resCheck: "+resCheck);
    	if(resCheck!=false){
    		addToLastTrainSearchList();
    	}
    	return resCheck;
    };
    
    //SCRIPT SIZMEK
    function sizmekFunc(form) {

    	var checkTcom=tcom18.checkForm(form);
    	
    	let cookieConsent = checkValueCookie("OptanonConsent");
    	let consentFlag = !!cookieConsent ? checkGroupConsents(cookieConsent) : false;
    	let groupCookieConsent = getGroupConsents(cookieConsent);
    	
    	if(checkTcom){
	
			if(!!groupCookieConsent){
				let newUrl = $("#formcruscotto").attr("action")+"&"+groupCookieConsent;
    			$("#formcruscotto").attr("action",newUrl);
			}

			let siteParam = "site=tcom";
            let siteParamUrl = $("#formcruscotto").attr("action")+"&"+siteParam;
            $("#formcruscotto").attr("action",siteParamUrl);
    	
    		/*versaTagObj.generateRequest("https://www.trenitalia.com/Click/Search.html");
    		var szkorigineTratta = document.getElementById("biglietti_fromNew").value;
    	    var szkdestinazioneTratta = document.getElementById("biglietti_toNew").value;
    	    var Quantity = Number(document.getElementById("biglietti_adulti").value) + Number(document.getElementById("biglietti_ragazzi").value);
    	    versaTagObj.setActivityParam("szkorigineTratta", szkorigineTratta);
    	    versaTagObj.setActivityParam("szkdestinazioneTratta", szkdestinazioneTratta);
    	    versaTagObj.setActivityParam("Quantity", Quantity);
    	    versaTagObj.generateRequest();*/
    		//Richiesta cambio script TT_0015124349
    		var OrderID = "";
    		var szkorigineTratta = document.getElementById("biglietti_fromNew").value;
    		var szkdestinazioneTratta = document.getElementById("biglietti_toNew").value;
    		var Quantity = Number(document.getElementById("biglietti_adulti").value) + Number(document.getElementById("biglietti_ragazzi").value);
    		var Revenue = "";
    		var startData = document.getElementById('biglietti_data_pVISIBLE').value;
    		var startOur = document.getElementById('biglietti_ora_p').value; 
    		var ar_switch = document.getElementById("biglietti_ar").checked ? "A/R" : "A";

            if (consentFlag) {
                <!-- Start of global snippet: Google tag (gtag.js) -->
                generateScriptGlobalFloodlight();
                window.dataLayer = window.dataLayer || [];
                function gtag() {
                    dataLayer.push(arguments);
                }
                gtag('js', new Date());
                gtag('config', 'DC-14243071');
                <!-- End of global snippet: Please do not remove -->

                <!-- Event snippet for Trenitalia Bottone Cerca -->
                gtag('event', 'conversion', {
                    'allow_custom_scripts': true,
                    'u1': szkorigineTratta, //Stazione di Partenza
                    'u2': szkdestinazioneTratta, //Stazione di Arrivo
                    'u3': startData, //Data partenza
                    'u4': startOur, //Ora di partenza
                    'u5': ar_switch, //Il valore che passiamo in caso di A/R o se preferiamo 0/1.
                    'u6': Quantity, //Somma passeggeri tra adulti e ragazzi
                    'send_to': 'DC-14243071/pageview/treni003+standard'
                });

                generateNoScriptGtag(szkorigineTratta, szkdestinazioneTratta, startData, startOur, ar_switch, Quantity);
                <!-- End of event snippet: Please do not remove -->
            }
            versaTagObj.clearActivityParam();
            versaTagObj.setActivityParam("OrderID", OrderID);
            versaTagObj.setActivityParam("ProductID", szkorigineTratta);
            versaTagObj.setActivityParam("ProductInfo", szkdestinazioneTratta);
            versaTagObj.setActivityParam("Quantity", Quantity);
            versaTagObj.setActivityParam("Citta_Partenza", szkorigineTratta);
            versaTagObj.setActivityParam("Citta_Arrivo", szkdestinazioneTratta);
            versaTagObj.setActivityParam("Value", Revenue);
            versaTagObj.generateRequest("https://www.trenitalia.com/Click/Search.html");

    	}else{
    			return checkTcom;
    	}
    };

    function consentFunction(form) {

        let cookieConsent = checkValueCookie("OptanonConsent");
        let consentFlag = !!cookieConsent ? checkGroupConsents(cookieConsent) : false;
        let groupCookieConsent = getGroupConsents(cookieConsent);
        let siteParam = "site=tcom";

        if(!!groupCookieConsent){
            let newUrl = $("#searchForm").attr("action")+"&"+groupCookieConsent;
            $("#searchForm").attr("action",newUrl);
        }

        let siteParamUrl = $("#searchForm").attr("action")+"&"+siteParam;
        $("#searchForm").attr("action",siteParamUrl);

    };

    /* modalità di inclusione utilizzata in tcom_engine.js
    if(navigator.cookieEnabled){
    	setTimeout(function(){
    		$.getScript('/cms-file/html/trenitalia2014/lastTrainSearchList.js');
    	}, 1000);
    }
    */
}


/*FINE JS CODE FOR OLD CRUSCOTTO*/



